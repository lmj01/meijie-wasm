/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "170";
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const ConstantColorFactor = 211;
const OneMinusConstantColorFactor = 212;
const ConstantAlphaFactor = 213;
const OneMinusConstantAlphaFactor = 214;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const AgXToneMapping = 6;
const NeutralToneMapping = 7;
const AttachedBindMode = "attached";
const DetachedBindMode = "detached";
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const UnsignedInt5999Type = 35902;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RGB_BPTC_SIGNED_Format = 36494;
const RGB_BPTC_UNSIGNED_Format = 36495;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const NoColorSpace = "";
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const LinearTransfer = "linear";
const SRGBTransfer = "srgb";
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const NeverCompare = 512;
const LessCompare = 513;
const EqualCompare = 514;
const LessEqualCompare = 515;
const GreaterCompare = 516;
const NotEqualCompare = 517;
const GreaterEqualCompare = 518;
const AlwaysCompare = 519;
const StaticDrawUsage = 35044;
const GLSL3 = "300 es";
const WebGLCoordinateSystem = 2e3;
const WebGPUCoordinateSystem = 2001;
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0) return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l2 = array.length; i < l2; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
}
function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}
function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
}
function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
}
function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s2) {
  if (s2 !== void 0) _seed = s2;
  let t = _seed += 1831565813;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize,
  denormalize
};
class Vector2 {
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s2) {
    this.x += v.x * s2;
    this.y += v.y * s2;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s2 = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s2 + center.x;
    this.y = x * s2 + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[3] *= s2;
    te[6] *= s2;
    te[1] *= s2;
    te[4] *= s2;
    te[7] *= s2;
    te[2] *= s2;
    te[5] *= s2;
    te[8] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m = this.elements;
    tmp2 = m[1];
    m[1] = m[3];
    m[3] = tmp2;
    tmp2 = m[2];
    m[2] = m[6];
    m[6] = tmp2;
    tmp2 = m[5];
    m[5] = m[7];
    m[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s2,
      -sx * (c * cx + s2 * cy) + cx + tx,
      -sy * s2,
      sy * c,
      -sy * (-s2 * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(
        1,
        0,
        x.x,
        0,
        1,
        x.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x,
        0,
        1,
        y,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s2 = Math.sin(theta);
    this.set(
      c,
      -s2,
      0,
      s2,
      c,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y) {
    this.set(
      x,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = /* @__PURE__ */ new Matrix3();
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true;
  }
  return false;
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
const _cache = {};
function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}
function probeAsync(gl, sync, interval) {
  return new Promise(function(resolve, reject) {
    function probe() {
      switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case gl.WAIT_FAILED:
          reject();
          break;
        case gl.TIMEOUT_EXPIRED:
          setTimeout(probe, interval);
          break;
        default:
          resolve();
      }
    }
    setTimeout(probe, interval);
  });
}
function toNormalizedProjectionMatrix(projectionMatrix) {
  const m = projectionMatrix.elements;
  m[2] = 0.5 * m[2] + 0.5 * m[3];
  m[6] = 0.5 * m[6] + 0.5 * m[7];
  m[10] = 0.5 * m[10] + 0.5 * m[11];
  m[14] = 0.5 * m[14] + 0.5 * m[15];
}
function toReversedProjectionMatrix(projectionMatrix) {
  const m = projectionMatrix.elements;
  const isPerspectiveMatrix = m[11] === -1;
  if (isPerspectiveMatrix) {
    m[10] = -m[10] - 1;
    m[14] = -m[14];
  } else {
    m[10] = -m[10];
    m[14] = -m[14] + 1;
  }
}
const ColorManagement = {
  enabled: true,
  workingColorSpace: LinearSRGBColorSpace,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(color, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }
    if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
      color.r = SRGBToLinear(color.r);
      color.g = SRGBToLinear(color.g);
      color.b = SRGBToLinear(color.b);
    }
    if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
      color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
      color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
    }
    if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
      color.r = LinearToSRGB(color.r);
      color.g = LinearToSRGB(color.g);
      color.b = LinearToSRGB(color.b);
    }
    return color;
  },
  fromWorkingColorSpace: function(color, targetColorSpace) {
    return this.convert(color, this.workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this.workingColorSpace);
  },
  getPrimaries: function(colorSpace) {
    return this.spaces[colorSpace].primaries;
  },
  getTransfer: function(colorSpace) {
    if (colorSpace === NoColorSpace) return LinearTransfer;
    return this.spaces[colorSpace].transfer;
  },
  getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
    return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
  },
  define: function(colorSpaces) {
    Object.assign(this.spaces, colorSpaces);
  },
  // Internal APIs
  _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
    return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(colorSpace) {
    return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
    return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
  }
};
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
const D65 = [0.3127, 0.329];
const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
);
const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
ColorManagement.define({
  [LinearSRGBColorSpace]: {
    primaries: REC709_PRIMARIES,
    whitePoint: D65,
    transfer: LinearTransfer,
    toXYZ: LINEAR_REC709_TO_XYZ,
    fromXYZ: XYZ_TO_LINEAR_REC709,
    luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
    workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
    outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
  },
  [SRGBColorSpace]: {
    primaries: REC709_PRIMARIES,
    whitePoint: D65,
    transfer: SRGBTransfer,
    toXYZ: LINEAR_REC709_TO_XYZ,
    fromXYZ: XYZ_TO_LINEAR_REC709,
    luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
    outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
  }
});
let _canvas;
class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0) _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i++) {
        data[i] = SRGBToLinear(data[i] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i = 0; i < data.length; i++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
        } else {
          data[i] = SRGBToLinear(data[i]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
}
let _sourceId = 0;
class Source {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i = 0, l2 = data.length; i < l2; i++) {
          if (data[i].isDataTexture) {
            url.push(serializeImage(data[i].image));
          } else {
            url.push(serializeImage(data[i]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
}
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
let _textureId = 0;
class Texture extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.colorSpace = colorSpace;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0) output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  set needsPMREMUpdate(value) {
    if (value === true) {
      this.pmremVersion++;
    }
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s2) {
    this.x += v.x * s2;
    this.y += v.y * s2;
    this.z += v.z * s2;
    this.w += v.w * s2;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    this.w /= v.w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s2 = Math.sqrt(1 - q.w * q.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s2;
      this.y = q.y / s2;
      this.z = q.z / s2;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3) s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    this.w = e[15];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  constructor(width = 1, height = 1, options = {}) {
    super();
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: 1 };
    options = Object.assign({
      generateMipmaps: false,
      internalFormat: null,
      minFilter: LinearFilter,
      depthBuffer: true,
      stencilBuffer: false,
      resolveDepthBuffer: true,
      resolveStencilBuffer: true,
      depthTexture: null,
      samples: 0,
      count: 1
    }, options);
    const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    texture.flipY = false;
    texture.generateMipmaps = options.generateMipmaps;
    texture.internalFormat = options.internalFormat;
    this.textures = [];
    const count = options.count;
    for (let i = 0; i < count; i++) {
      this.textures[i] = texture.clone();
      this.textures[i].isRenderTargetTexture = true;
    }
    this.depthBuffer = options.depthBuffer;
    this.stencilBuffer = options.stencilBuffer;
    this.resolveDepthBuffer = options.resolveDepthBuffer;
    this.resolveStencilBuffer = options.resolveStencilBuffer;
    this.depthTexture = options.depthTexture;
    this.samples = options.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(value) {
    this.textures[0] = value;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i = 0, il = this.textures.length; i < il; i++) {
        this.textures[i].image.width = width;
        this.textures[i].image.height = height;
        this.textures[i].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.textures.length = 0;
    for (let i = 0, il = source.textures.length; i < il; i++) {
      this.textures[i] = source.textures[i].clone();
      this.textures[i].isRenderTargetTexture = true;
    }
    const image = Object.assign({}, source.texture.image);
    this.texture.source = new Source(image);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.resolveDepthBuffer = source.resolveDepthBuffer;
    this.resolveStencilBuffer = source.resolveStencilBuffer;
    if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isWebGLRenderTarget = true;
  }
}
class DataArrayTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(layerIndex) {
    this.layerUpdates.add(layerIndex);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Data3DTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s2 = Math.sin(s2 * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w0 = w0 * s2 + w1 * tDir;
      if (s2 === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update = true) {
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t;
      this._w = s2 * w + t * this._w;
      this._x = s2 * x + t * this._x;
      this._y = s2 * y + t * this._y;
      this._z = s2 * z + t * this._z;
      this.normalize();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    this._onChangeCallback();
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
}
class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0) z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s2) {
    this.x += v.x * s2;
    this.y += v.y * s2;
    this.z += v.z * s2;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u = Math.random() * 2 - 1;
    const c = Math.sqrt(1 - u * u);
    this.x = c * Math.cos(theta);
    this.y = u;
    this.z = c * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    this.makeEmpty();
    for (let i = 0, il = array.length; i < il; i += 3) {
      this.expandByPoint(_vector$b.fromArray(array, i));
    }
    return this;
  }
  setFromBufferAttribute(attribute) {
    this.makeEmpty();
    for (let i = 0, il = attribute.count; i < il; i++) {
      this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
    }
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
        for (let i = 0, l2 = positionAttribute.count; i < l2; i++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i, _vector$b);
          } else {
            _vector$b.fromBufferAttribute(positionAttribute, i);
          }
          _vector$b.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$4.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$4.copy(geometry.boundingBox);
        }
        _box$4.applyMatrix4(object.matrixWorld);
        this.union(_box$4);
      }
    }
    const children = object.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      this.expandByObject(children[i], precise);
    }
    return this;
  }
  containsPoint(point) {
    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle3) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$3.subVectors(triangle3.a, _center);
    _v1$7.subVectors(triangle3.b, _center);
    _v2$4.subVectors(triangle3.c, _center);
    _f0.subVectors(_v1$7, _v0$3);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$3, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$b).distanceTo(point);
  }
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
    }
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$4 = /* @__PURE__ */ new Box3();
const _v0$3 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$4 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
const _box$3 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$3.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq = _v1$6.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length);
      this.radius += delta;
    }
    return this;
  }
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
let Ray$1 = class Ray {
  constructor(origin = new Vector3(), direction2 = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction2;
  }
  set(origin, direction2) {
    this.origin.copy(origin);
    this.direction.copy(direction2);
    return this;
  }
  copy(ray2) {
    this.origin.copy(ray2.origin);
    this.direction.copy(ray2.direction);
    return this;
  }
  at(t, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0) return null;
    if (t0 < 0) return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || isNaN(tmin)) tmin = tymin;
    if (tymax < tmax || isNaN(tmax)) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray2) {
    return ray2.origin.equals(this.origin) && ray2.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[4] *= s2;
    te[8] *= s2;
    te[12] *= s2;
    te[1] *= s2;
    te[5] *= s2;
    te[9] *= s2;
    te[13] *= s2;
    te[2] *= s2;
    te[6] *= s2;
    te[10] *= s2;
    te[14] *= s2;
    te[3] *= s2;
    te[7] *= s2;
    te[11] *= s2;
    te[15] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(
        1,
        0,
        0,
        x.x,
        0,
        1,
        0,
        x.y,
        0,
        0,
        1,
        x.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x,
        0,
        1,
        0,
        y,
        0,
        0,
        1,
        z,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s2,
      0,
      0,
      s2,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      c,
      0,
      s2,
      0,
      0,
      1,
      0,
      0,
      -s2,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      c,
      -s2,
      0,
      0,
      s2,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s2 * z,
      tx * z + s2 * y,
      0,
      tx * y + s2 * z,
      ty * y + c,
      ty * z - s2 * x,
      0,
      tx * z - s2 * y,
      ty * z + s2 * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$4.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$4.elements[0] *= invSX;
    _m1$4.elements[1] *= invSX;
    _m1$4.elements[2] *= invSX;
    _m1$4.elements[4] *= invSY;
    _m1$4.elements[5] *= invSY;
    _m1$4.elements[6] *= invSY;
    _m1$4.elements[8] *= invSZ;
    _m1$4.elements[9] *= invSZ;
    _m1$4.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$4);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    let z, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$4 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$2 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix$2.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$2, order, update);
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0) this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$3 = /* @__PURE__ */ new Matrix4();
const _target = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
const _childaddedEvent = { type: "childadded", child: null };
const _childremovedEvent = { type: "childremoved", child: null };
class Object3D extends EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
  }
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$3.lookAt(_position$3, _target, this.up);
    } else {
      _m1$3.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$3);
    if (parent) {
      _m1$3.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$3);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
      _childremovedEvent.child = object;
      this.dispatchEvent(_childremovedEvent);
      _childremovedEvent.child = null;
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$3.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$3.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$3);
    object.removeFromParent();
    object.parent = this;
    this.children.push(object);
    object.updateWorldMatrix(false, true);
    object.dispatchEvent(_addedEvent);
    _childaddedEvent.child = object;
    this.dispatchEvent(_childaddedEvent);
    _childaddedEvent.child = null;
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value) return this;
    for (let i = 0, l2 = this.children.length; i < l2; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getObjectsByProperty(name, value, result = []) {
    if (this[name] === value) result.push(this);
    const children = this.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      children[i].getObjectsByProperty(name, value, result);
    }
    return result;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      children[i].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      children[i].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.matrixWorldAutoUpdate === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      const child = children[i];
      child.updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldAutoUpdate === true) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l2 = children.length; i < l2; i++) {
        const child = children[i];
        child.updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    }
    if (this.isBatchedMesh) {
      object.type = "BatchedMesh";
      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
      object.sortObjects = this.sortObjects;
      object.drawRanges = this._drawRanges;
      object.reservedRanges = this._reservedRanges;
      object.visibility = this._visibility;
      object.active = this._active;
      object.bounds = this._bounds.map((bound) => ({
        boxInitialized: bound.boxInitialized,
        boxMin: bound.box.min.toArray(),
        boxMax: bound.box.max.toArray(),
        sphereInitialized: bound.sphereInitialized,
        sphereRadius: bound.sphere.radius,
        sphereCenter: bound.sphere.center.toArray()
      }));
      object.maxInstanceCount = this._maxInstanceCount;
      object.maxVertexCount = this._maxVertexCount;
      object.maxIndexCount = this._maxIndexCount;
      object.geometryInitialized = this._geometryInitialized;
      object.geometryCount = this._geometryCount;
      object.matricesTexture = this._matricesTexture.toJSON(meta);
      if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
      if (this.boundingSphere !== null) {
        object.boundingSphere = {
          center: object.boundingSphere.center.toArray(),
          radius: object.boundingSphere.radius
        };
      }
      if (this.boundingBox !== null) {
        object.boundingBox = {
          min: object.boundingBox.min.toArray(),
          max: object.boundingBox.max.toArray()
        };
      }
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l2 = shapes.length; i < l2; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l2 = this.material.length; i < l2; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$2 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
const _v40 = /* @__PURE__ */ new Vector4();
const _v41 = /* @__PURE__ */ new Vector4();
const _v42 = /* @__PURE__ */ new Vector4();
class Triangle {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static getNormal(a, b, c, target) {
    target.subVectors(c, b);
    _v0$2.subVectors(a, b);
    target.cross(_v0$2);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point, a, b, c, target) {
    _v0$2.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point, a);
    const dot00 = _v0$2.dot(_v0$2);
    const dot01 = _v0$2.dot(_v1$3);
    const dot02 = _v0$2.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      target.set(0, 0, 0);
      return null;
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point, a, b, c) {
    if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
      return false;
    }
    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
    if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
      target.x = 0;
      target.y = 0;
      if ("z" in target) target.z = 0;
      if ("w" in target) target.w = 0;
      return null;
    }
    target.setScalar(0);
    target.addScaledVector(v1, _v3$2.x);
    target.addScaledVector(v2, _v3$2.y);
    target.addScaledVector(v3, _v3$2.z);
    return target;
  }
  static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
    _v40.setScalar(0);
    _v41.setScalar(0);
    _v42.setScalar(0);
    _v40.fromBufferAttribute(attr, i1);
    _v41.fromBufferAttribute(attr, i2);
    _v42.fromBufferAttribute(attr, i3);
    target.setScalar(0);
    target.addScaledVector(_v40, barycoord.x);
    target.addScaledVector(_v41, barycoord.y);
    target.addScaledVector(_v42, barycoord.z);
    return target;
  }
  static isFrontFacing(a, b, c, direction2) {
    _v0$2.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$2.cross(_v1$3).dot(direction2) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle3) {
    this.a.copy(triangle3.a);
    this.b.copy(triangle3.b);
    this.c.copy(triangle3.c);
    return this;
  }
  getArea() {
    _v0$2.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$2.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getInterpolation(point, v1, v2, v3, target) {
    return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction2) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction2);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    const a = this.a, b = this.b, c = this.c;
    let v, w;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  equals(triangle3) {
    return triangle3.a.equals(this.a) && triangle3.b.equals(this.b) && triangle3.c.equals(this.c);
  }
}
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
class Color {
  constructor(r, g, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g, b);
  }
  set(r, g, b) {
    if (g === void 0 && b === void 0) {
      const value = r;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r, g, b);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r;
    this.g = g;
    this.b = b;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h, s2, l2, colorSpace = ColorManagement.workingColorSpace) {
    h = euclideanModulo(h, 1);
    s2 = clamp(s2, 0, 1);
    l2 = clamp(l2, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const q = 2 * l2 - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0) return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(255, parseInt(color[1], 10)) / 255,
              Math.min(255, parseInt(color[2], 10)) / 255,
              Math.min(255, parseInt(color[3], 10)) / 255,
              colorSpace
            );
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(100, parseInt(color[1], 10)) / 100,
              Math.min(100, parseInt(color[2], 10)) / 100,
              Math.min(100, parseInt(color[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setHSL(
              parseFloat(color[1]) / 360,
              parseFloat(color[2]) / 100,
              parseFloat(color[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color$2.copy(this), colorSpace);
    return Math.round(clamp(_color$2.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color$2.g * 255, 0, 255)) * 256 + Math.round(clamp(_color$2.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color$2.copy(this), colorSpace);
    const r = _color$2.r, g = _color$2.g, b = _color$2.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color$2.copy(this), colorSpace);
    target.r = _color$2.r;
    target.g = _color$2.g;
    target.b = _color$2.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color$2.copy(this), colorSpace);
    const r = _color$2.r, g = _color$2.g, b = _color$2.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
    }
    return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
  }
  offsetHSL(h, s2, l2) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h, _hslA.s + s2, _hslA.l + l2);
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = lerp(_hslA.h, _hslB.h, alpha);
    const s2 = lerp(_hslA.s, _hslB.s, alpha);
    const l2 = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s2, l2);
    return this;
  }
  setFromVector3(v) {
    this.r = v.x;
    this.g = v.y;
    this.b = v.z;
    return this;
  }
  applyMatrix3(m) {
    const r = this.r, g = this.g, b = this.b;
    const e = m.elements;
    this.r = e[0] * r + e[3] * g + e[6] * b;
    this.g = e[1] * r + e[4] * g + e[7] * b;
    this.b = e[2] * r + e[5] * g + e[8] * b;
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
}
const _color$2 = /* @__PURE__ */ new Color();
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(_value) {
  }
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.sheen !== void 0) data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.dispersion !== void 0) data.dispersion = this.dispersion;
    if (this.iridescence !== void 0) data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data.combine = this.combine;
    }
    if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();
    if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors === true) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
    if (this.depthTest === false) data.depthTest = this.depthTest;
    if (this.depthWrite === false) data.depthWrite = this.depthWrite;
    if (this.colorWrite === false) data.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaHash === true) data.alphaHash = true;
    if (this.alphaToCoverage === true) data.alphaToCoverage = true;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
    if (this.forceSinglePass === true) data.forceSinglePass = true;
    if (this.wireframe === true) data.wireframe = true;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data.flatShading = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (this.fog === false) data.fog = false;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class MeshBasicMaterial extends Material {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
const _vector$9 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.gpuType = FloatType;
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l2 = this.itemSize; i < l2; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l2 = this.count; i < l2; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l2 = this.count; i < l2; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix3(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m) {
    for (let i = 0, l2 = this.count; i < l2; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyMatrix4(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l2 = this.count; i < l2; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyNormalMatrix(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l2 = this.count; i < l2; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.transformDirection(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized) value = normalize(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }
  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  setX(index, x) {
    if (this.normalized) x = normalize(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }
  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized) y = denormalize(y, this.array);
    return y;
  }
  setY(index, y) {
    if (this.normalized) y = normalize(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }
  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  setW(index, w) {
    if (this.normalized) w = normalize(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }
  setXY(index, x, y) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y = normalize(y, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y = normalize(y, this.array);
      z = normalize(z, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y = normalize(y, this.array);
      z = normalize(z, this.array);
      w = normalize(w, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
    return data;
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
let _id$2 = 0;
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3();
const _box$2 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.indirect = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  setIndirect(indirect) {
    this.indirect = indirect;
    return this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q) {
    _m1$2.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateX(angle) {
    _m1$2.makeRotationX(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateY(angle) {
    _m1$2.makeRotationY(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateZ(angle) {
    _m1$2.makeRotationZ(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  translate(x, y, z) {
    _m1$2.makeTranslation(x, y, z);
    this.applyMatrix4(_m1$2);
    return this;
  }
  scale(x, y, z) {
    _m1$2.makeScale(x, y, z);
    this.applyMatrix4(_m1$2);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute === void 0) {
      const position = [];
      for (let i = 0, l2 = points.length; i < l2; i++) {
        const point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
    } else {
      for (let i = 0, l2 = positionAttribute.count; i < l2; i++) {
        const point = points[i];
        positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);
      }
      if (points.length > positionAttribute.count) {
        console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");
      }
      positionAttribute.needsUpdate = true;
    }
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$8);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++) {
        _vector$8.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const positionAttribute = attributes.position;
    const normalAttribute = attributes.normal;
    const uvAttribute = attributes.uv;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
    }
    const tangentAttribute = this.getAttribute("tangent");
    const tan1 = [], tan2 = [];
    for (let i = 0; i < positionAttribute.count; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a, b, c) {
      vA.fromBufferAttribute(positionAttribute, a);
      vB.fromBufferAttribute(positionAttribute, b);
      vC.fromBufferAttribute(positionAttribute, c);
      uvA.fromBufferAttribute(uvAttribute, a);
      uvB.fromBufferAttribute(uvAttribute, b);
      uvC.fromBufferAttribute(uvAttribute, c);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: index.count
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(
          index.getX(j + 0),
          index.getX(j + 1),
          index.getX(j + 2)
        );
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n = new Vector3(), n2 = new Vector3();
    function handleVertex(v) {
      n.fromBufferAttribute(normalAttribute, v);
      n2.copy(n);
      const t = tan1[v];
      tmp2.copy(t);
      tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp22.crossVectors(n2, t);
      const test = tmp22.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangentAttribute.setXYZW(v, tmp2.x, tmp2.y, tmp2.z, w);
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(index.getX(j + 0));
        handleVertex(index.getX(j + 1));
        handleVertex(index.getX(j + 2));
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$8.fromBufferAttribute(normals, i);
      _vector$8.normalize();
      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i = 0, l2 = indices2.length; i < l2; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l2 = groups.length; i < l2; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, l2 = morphAttribute.length; i < l2; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l2 = groups.length; i < l2; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox2 = source.boundingBox;
    if (boundingBox2 !== null) {
      this.boundingBox = boundingBox2.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
const _ray$3 = /* @__PURE__ */ new Ray$1();
const _sphere$6 = /* @__PURE__ */ new Sphere();
const _sphereHitAt = /* @__PURE__ */ new Vector3();
const _vA$1$1 = /* @__PURE__ */ new Vector3();
const _vB$1$1 = /* @__PURE__ */ new Vector3();
const _vC$1$1 = /* @__PURE__ */ new Vector3();
const _tempA = /* @__PURE__ */ new Vector3();
const _morphA = /* @__PURE__ */ new Vector3();
const _intersectionPoint$1 = /* @__PURE__ */ new Vector3();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
  getVertexPosition(index, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i = 0, il = morphPosition.length; i < il; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morphAttribute, index);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$6.copy(geometry.boundingSphere);
    _sphere$6.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$6.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$3);
  }
  _computeIntersections(raycaster, intersects2, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const uv = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = index.getX(j);
            const b = index.getX(j + 1);
            const c = index.getX(j + 2);
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = index.getX(i);
          const b = index.getX(i + 1);
          const c = index.getX(i + 2);
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = j;
            const b = j + 1;
            const c = j + 2;
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = i;
          const b = i + 1;
          const c = i + 2;
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    }
  }
}
function checkIntersection$1(object, material, raycaster, ray2, pA, pB, pC, point) {
  let intersect2;
  if (material.side === BackSide) {
    intersect2 = ray2.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect2 = ray2.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
  }
  if (intersect2 === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray2, uv, uv1, normal, a, b, c) {
  object.getVertexPosition(a, _vA$1$1);
  object.getVertexPosition(b, _vB$1$1);
  object.getVertexPosition(c, _vC$1$1);
  const intersection = checkIntersection$1(object, material, raycaster, ray2, _vA$1$1, _vB$1$1, _vC$1$1, _intersectionPoint$1);
  if (intersection) {
    const barycoord = new Vector3();
    Triangle.getBarycoord(_intersectionPoint$1, _vA$1$1, _vB$1$1, _vC$1$1, barycoord);
    if (uv) {
      intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());
    }
    if (uv1) {
      intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());
    }
    if (normal) {
      intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());
      if (intersection.normal.dot(ray2.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1$1, _vB$1$1, _vC$1$1, face.normal);
    intersection.face = face;
    intersection.barycoord = barycoord;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u][p] = null;
        } else {
          dst[u][p] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u]);
    for (const p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u = 0; u < src.length; u++) {
    dst.push(src[u].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer) {
  const currentRenderTarget = renderer.getRenderTarget();
  if (currentRenderTarget === null) {
    return renderer.outputColorSpace;
  }
  if (currentRenderTarget.isXRRenderTarget === true) {
    return currentRenderTarget.texture.colorSpace;
  }
  return ColorManagement.workingColorSpace;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      clipCullDistance: false,
      // set to use vertex shader clipping
      multiDraw: false
      // set to use vertex shader multi_draw / enable gl_DrawID
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv1": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    data.lights = this.lights;
    data.clipping = this.clipping;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
  }
}
class Camera extends Object3D {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
    this.coordinateSystem = WebGLCoordinateSystem;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  getWorldDirection(target) {
    return super.getWorldDirection(target).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _v3$1 = /* @__PURE__ */ new Vector3();
const _minTarget = /* @__PURE__ */ new Vector2();
const _maxTarget = /* @__PURE__ */ new Vector2();
class PerspectiveCamera extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(distance, minTarget, maxTarget) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(distance, target) {
    this.getViewBounds(distance, _minTarget, _maxTarget);
    return target.subVectors(_maxTarget, _minTarget);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
const fov = -90;
const aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    this.activeMipmapLevel = 0;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
    for (const camera of cameras) this.remove(camera);
    if (coordinateSystem === WebGLCoordinateSystem) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
    }
    for (const camera of cameras) {
      this.add(camera);
      camera.updateMatrixWorld();
    }
  }
  update(renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const { renderTarget, activeMipmapLevel } = this;
    if (this.coordinateSystem !== renderer.coordinateSystem) {
      this.coordinateSystem = renderer.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentActiveCubeFace = renderer.getActiveCubeFace();
    const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
    const currentXrEnabled = renderer.xr.enabled;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, size, options);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.colorSpace = texture.colorSpace;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
let Plane$1 = class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  intersectLine(line, target) {
    const direction2 = line.delta(_vector1);
    const denominator = this.normal.dot(direction2);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction2, t);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const _sphere$5 = /* @__PURE__ */ new Sphere();
const _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(p0 = new Plane$1(), p1 = new Plane$1(), p2 = new Plane$1(), p3 = new Plane$1(), p4 = new Plane$1(), p5 = new Plane$1()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    if (coordinateSystem === WebGLCoordinateSystem) {
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      planes[5].setComponents(me2, me6, me10, me14).normalize();
    } else {
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
    }
    return this;
  }
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null) object.computeBoundingSphere();
      _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSprite(sprite) {
    _sphere$5.center.set(0, 0, 0);
    _sphere$5.radius = 0.7071067811865476;
    _sphere$5.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl) {
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const size = array.byteLength;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version,
      size
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRanges = attribute.updateRanges;
    gl.bindBuffer(bufferType, buffer);
    if (updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      updateRanges.sort((a, b) => a.start - b.start);
      let mergeIndex = 0;
      for (let i = 1; i < updateRanges.length; i++) {
        const previousRange = updateRanges[mergeIndex];
        const range = updateRanges[i];
        if (range.start <= previousRange.start + previousRange.count + 1) {
          previousRange.count = Math.max(
            previousRange.count,
            range.start + range.count - previousRange.start
          );
        } else {
          ++mergeIndex;
          updateRanges[mergeIndex] = range;
        }
      }
      updateRanges.length = mergeIndex + 1;
      for (let i = 0, l2 = updateRanges.length; i < l2; i++) {
        const range = updateRanges[i];
        gl.bufferSubData(
          bufferType,
          range.start * array.BYTES_PER_ELEMENT,
          array,
          range.start,
          range.count
        );
      }
      attribute.clearUpdateRanges();
    }
    attribute.onUploadCallback();
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      if (data.size !== attribute.array.byteLength) {
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      }
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
}
var alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var batching_pars_vertex = "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif";
var batching_vertex = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n		emissiveColor = sRGBTransferEOTF( emissiveColor );\n	#endif\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment = "vec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n		\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n		\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		\n		#else\n		\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}";
const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const ShaderChunk = {
  alphahash_fragment,
  alphahash_pars_fragment,
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  batching_pars_vertex,
  batching_vertex,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  colorspace_fragment,
  colorspace_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphinstance_vertex,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  opaque_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
const UniformsLib = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Matrix3() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 }
  }
};
const ShaderLib = {
  basic: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        specular: { value: /* @__PURE__ */ new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Matrix3() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Matrix3() }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: /* @__PURE__ */ new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: /* @__PURE__ */ mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Color(0) },
      specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
const _rgb = { r: 0, b: 0, g: 0 };
const _e1$1 = /* @__PURE__ */ new Euler();
const _m1$1 = /* @__PURE__ */ new Matrix4();
function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function getBackground(scene) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    return background;
  }
  function render(scene) {
    let forceClear = false;
    const background = getBackground(scene);
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === "alpha-blend") {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer.autoClear || forceClear) {
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
  }
  function addToRenderList(renderList, scene) {
    const background = getBackground(scene);
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      _e1$1.copy(scene.backgroundRotation);
      _e1$1.x *= -1;
      _e1$1.y *= -1;
      _e1$1.z *= -1;
      if (background.isCubeTexture && background.isRenderTargetTexture === false) {
        _e1$1.y *= -1;
        _e1$1.z *= -1;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));
      boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render,
    addToRenderList
  };
}
function WebGLBindingStates(gl, attributes) {
  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    const state = getBindingState(geometry, program, material);
    if (currentState !== state) {
      currentState = state;
      bindVertexArrayObject(currentState.object);
    }
    updateBuffers = needsUpdate(object, geometry, program, index);
    if (updateBuffers) saveCache(object, geometry, program, index);
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    return gl.createVertexArray();
  }
  function bindVertexArrayObject(vao) {
    return gl.bindVertexArray(vao);
  }
  function deleteVertexArrayObject(vao) {
    return gl.deleteVertexArray(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0) return true;
        if (cachedAttribute.attribute !== geometryAttribute) return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      gl.vertexAttribDivisor(attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer = type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size / programAttribute.locationSize * i) * bytesPerElement,
                integer
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                size / programAttribute.locationSize * i * bytesPerElement,
                integer
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0) return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0) continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawArraysInstanced(mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
    let elementCount = 0;
    for (let i = 0; i < drawCount; i++) {
      elementCount += counts[i];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < starts.length; i++) {
        renderInstances(starts[i], counts[i], primcount[i]);
      }
    } else {
      extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i] * primcount[i];
      }
      info.update(elementCount, mode, 1);
    }
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLCapabilities(gl, extensions, parameters, utils) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function textureFormatReadable(textureFormat) {
    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
      return false;
    }
    return true;
  }
  function textureTypeReadable(textureType) {
    const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float"));
    if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    textureType !== FloatType && !halfFloatSupportedByExt) {
      return false;
    }
    return true;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const reverseDepthBuffer = parameters.reverseDepthBuffer === true && extensions.has("EXT_clip_control");
  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const maxSamples = gl.getParameter(gl.MAX_SAMPLES);
  return {
    isWebGL2: true,
    // keeping this for backwards compatibility
    getMaxAnisotropy,
    getMaxPrecision,
    textureFormatReadable,
    textureTypeReadable,
    precision,
    logarithmicDepthBuffer,
    reverseDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane$1(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
  };
  this.setGlobalState = function(planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
class OrthographicCamera extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
}
const LOD_MIN = 4;
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const MAX_SAMPLES = 20;
const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
const _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
let _oldXrEnabled = false;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, 1)
];
class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    _oldXrEnabled = this._renderer.xr.enabled;
    this._renderer.xr.enabled = false;
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    this._renderer.xr.enabled = _oldXrEnabled;
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    _oldXrEnabled = this._renderer.xr.enabled;
    this._renderer.xr.enabled = false;
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = new Mesh(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    const n = this._lodPlanes.length;
    for (let i = 1; i < n; i++) {
      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction2, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction2 !== "latitudinal" && direction2 !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i === 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction2 === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max = 1 + texelSize;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        let renderTarget = cubeUVmaps.get(texture);
        const currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;
        if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          renderTarget.texture.pmremVersion = texture.pmremVersion;
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (renderTarget !== void 0) {
            return renderTarget.texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
              renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              renderTarget.texture.pmremVersion = texture.pmremVersion;
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i = 0; i < length; i++) {
      if (image[i] !== void 0) count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function() {
      getExtension("EXT_color_buffer_float");
      getExtension("WEBGL_clip_cull_distance");
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
      getExtension("WEBGL_render_shared_exponent");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        warnOnce("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    for (const name in geometry.morphAttributes) {
      const array = geometry.morphAttributes[name];
      for (let i = 0, l2 = array.length; i < l2; i++) {
        attributes.remove(array[i]);
      }
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i = 0, l2 = array.length; i < l2; i++) {
        attributes.update(array[i], gl.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i = 0, l2 = array.length; i < l2; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else if (geometryPosition !== void 0) {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i = 0, l2 = array.length / 3 - 1; i < l2; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    } else {
      return;
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
    let elementCount = 0;
    for (let i = 0; i < drawCount; i++) {
      elementCount += counts[i];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < starts.length; i++) {
        renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i]);
      }
    } else {
      extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i] * primcount[i];
      }
      info.update(elementCount, mode, 1);
    }
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  function update(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let entry = morphTextures.get(geometry);
    if (entry === void 0 || entry.count !== morphTargetsCount) {
      let disposeTexture = function() {
        texture.dispose();
        morphTextures.delete(geometry);
        geometry.removeEventListener("dispose", disposeTexture);
      };
      if (entry !== void 0) entry.texture.dispose();
      const hasMorphPosition = geometry.morphAttributes.position !== void 0;
      const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
      const hasMorphColors = geometry.morphAttributes.color !== void 0;
      const morphTargets = geometry.morphAttributes.position || [];
      const morphNormals = geometry.morphAttributes.normal || [];
      const morphColors = geometry.morphAttributes.color || [];
      let vertexDataCount = 0;
      if (hasMorphPosition === true) vertexDataCount = 1;
      if (hasMorphNormals === true) vertexDataCount = 2;
      if (hasMorphColors === true) vertexDataCount = 3;
      let width = geometry.attributes.position.count * vertexDataCount;
      let height = 1;
      if (width > capabilities.maxTextureSize) {
        height = Math.ceil(width / capabilities.maxTextureSize);
        width = capabilities.maxTextureSize;
      }
      const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
      const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
      texture.type = FloatType;
      texture.needsUpdate = true;
      const vertexDataStride = vertexDataCount * 4;
      for (let i = 0; i < morphTargetsCount; i++) {
        const morphTarget = morphTargets[i];
        const morphNormal = morphNormals[i];
        const morphColor = morphColors[i];
        const offset = width * height * 4 * i;
        for (let j = 0; j < morphTarget.count; j++) {
          const stride = j * vertexDataStride;
          if (hasMorphPosition === true) {
            morph.fromBufferAttribute(morphTarget, j);
            buffer[offset + stride + 0] = morph.x;
            buffer[offset + stride + 1] = morph.y;
            buffer[offset + stride + 2] = morph.z;
            buffer[offset + stride + 3] = 0;
          }
          if (hasMorphNormals === true) {
            morph.fromBufferAttribute(morphNormal, j);
            buffer[offset + stride + 4] = morph.x;
            buffer[offset + stride + 5] = morph.y;
            buffer[offset + stride + 6] = morph.z;
            buffer[offset + stride + 7] = 0;
          }
          if (hasMorphColors === true) {
            morph.fromBufferAttribute(morphColor, j);
            buffer[offset + stride + 8] = morph.x;
            buffer[offset + stride + 9] = morph.y;
            buffer[offset + stride + 10] = morph.z;
            buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
          }
        }
      }
      entry = {
        count: morphTargetsCount,
        texture,
        size: new Vector2(width, height)
      };
      morphTextures.set(geometry, entry);
      geometry.addEventListener("dispose", disposeTexture);
    }
    if (object.isInstancedMesh === true && object.morphTexture !== null) {
      program.getUniforms().setValue(gl, "morphTexture", object.morphTexture, textures);
    } else {
      let morphInfluencesSum = 0;
      for (let i = 0; i < objectInfluences.length; i++) {
        morphInfluencesSum += objectInfluences[i];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
    }
    program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
    program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      const skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
class DepthTexture extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat) {
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat) type = UnsignedIntType;
    if (type === void 0 && format === DepthStencilFormat) type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
    return data;
  }
}
const emptyTexture = /* @__PURE__ */ new Texture();
const emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
const emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
const empty3dTexture = /* @__PURE__ */ new Data3DTexture();
const emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0, l2 = a.length; i < l2; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l2 = b.length; i < l2; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2i(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3i(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}
function setValueV2ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2ui(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3ui(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  let emptyTexture2D;
  if (this.type === gl.SAMPLER_2D_SHADOW) {
    emptyShadowTexture.compareFunction = LessEqualCompare;
    emptyTexture2D = emptyShadowTexture;
  } else {
    emptyTexture2D = emptyTexture;
  }
  textures.setTexture2D(v || emptyTexture2D, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT3DArray(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture3D(v[i] || empty3dTexture, units[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
class SingleUniform {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.setValue = getSingularSetter(activeInfo.type);
  }
}
class PureArrayUniform {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
}
class StructuredUniform {
  constructor(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  setValue(gl, value, textures) {
    const seq = this.seq;
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      u.setValue(gl, value[u.id], textures);
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex) id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map2 = container.map;
      let next = map2[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
class WebGLUniforms {
  constructor(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  setValue(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== void 0) u.setValue(gl, value, textures);
  }
  setOptional(gl, object, name) {
    const v = object[name];
    if (v !== void 0) this.setValue(gl, name, v);
  }
  static upload(gl, seq, values, textures) {
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i], v = values[u.id];
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r = [];
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      if (u.id in values) r.push(u);
    }
    return r;
  }
}
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i = from; i < to; i++) {
    const line = i + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
  }
  return lines2.join("\n");
}
const _m0 = /* @__PURE__ */ new Matrix3();
function getEncodingComponents(colorSpace) {
  ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, colorSpace);
  const encodingMatrix = `mat3( ${_m0.elements.map((v) => v.toFixed(4))} )`;
  switch (ColorManagement.getTransfer(colorSpace)) {
    case LinearTransfer:
      return [encodingMatrix, "LinearTransferOETF"];
    case SRGBTransfer:
      return [encodingMatrix, "sRGBTransferOETF"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space: ", colorSpace);
      return [encodingMatrix, "LinearTransferOETF"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "") return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return [
    `vec4 ${functionName}( vec4 value ) {`,
    `	return ${components[1]}( vec4( value.rgb * ${components[0]}, value.a ) );`,
    "}"
  ].join("\n");
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "Cineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case AgXToneMapping:
      toneMappingName = "AgX";
      break;
    case NeutralToneMapping:
      toneMappingName = "Neutral";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
const _v0$1 = /* @__PURE__ */ new Vector3();
function getLuminanceFunction() {
  ColorManagement.getLuminanceCoefficients(_v0$1);
  const r = _v0$1.x.toFixed(4);
  const g = _v0$1.y.toFixed(4);
  const b = _v0$1.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r}, ${g}, ${b} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join("\n");
}
function generateVertexExtensions(parameters) {
  const chunks = [
    parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    parameters.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name;
    let locationSize = 1;
    if (info.type === gl.FLOAT_MAT2) locationSize = 2;
    if (info.type === gl.FLOAT_MAT3) locationSize = 3;
    if (info.type === gl.FLOAT_MAT4) locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
const shaderChunkMap = /* @__PURE__ */ new Map();
function includeReplacer(match, include) {
  let string = ShaderChunk[include];
  if (string === void 0) {
    const newInclude = shaderChunkMap.get(include);
    if (newInclude !== void 0) {
      string = ShaderChunk[newInclude];
      console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
    } else {
      throw new Error("Can not resolve #include <" + include + ">");
    }
  }
  return resolveIncludes(string);
}
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customVertexExtensions = generateVertexExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
      parameters.batching ? "#define USE_BATCHING" : "",
      parameters.batchingColor ? "#define USE_BATCHING_COLOR" : "",
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      //
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
      parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
      parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
      parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
      parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
      parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
      parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
      parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
      parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
      parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
      parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
      parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
      parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
      parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
      parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
      parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
      parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
      parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
      //
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "#ifdef USE_INSTANCING_MORPH",
      "	uniform sampler2D morphTexture;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.dispersion ? "#define USE_DISPERSION" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["colorspace_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
      getLuminanceFunction(),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      customVertexExtensions,
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  function onFirstUse(self2) {
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        runnable = false;
        if (typeof renderer.debug.onShaderError === "function") {
          renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
        } else {
          const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
          const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nMaterial Name: " + self2.name + "\nMaterial Type: " + self2.type + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
          );
        }
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        self2.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    cachedUniforms = new WebGLUniforms(gl, program);
    cachedAttributes = fetchAttributeLocations(gl, program);
  }
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      onFirstUse(this);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      onFirstUse(this);
    }
    return cachedAttributes;
  };
  let programReady = parameters.rendererExtensionParallelShaderCompile === false;
  this.isReady = function() {
    if (programReady === false) {
      programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
    }
    return programReady;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
let _id$1 = 0;
class WebGLShaderCache {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    let set = cache.get(material);
    if (set === void 0) {
      set = /* @__PURE__ */ new Set();
      cache.set(material, set);
    }
    return set;
  }
  _getShaderStage(code) {
    const cache = this.shaderCache;
    let stage = cache.get(code);
    if (stage === void 0) {
      stage = new WebGLShaderStage(code);
      cache.set(code, stage);
    }
    return stage;
  }
}
class WebGLShaderStage {
  constructor(code) {
    this.id = _id$1++;
    this.code = code;
    this.usedTimes = 0;
  }
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const _activeChannels = /* @__PURE__ */ new Set();
  const programs = [];
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getChannel(value) {
    _activeChannels.add(value);
    if (value === 0) return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const reverseDepthBuffer = renderer.state.buffers.depth.getReversed();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const IS_BATCHEDMESH = object.isBatchedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_DISPERSION = material.dispersion > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_ALPHAHASH = !!material.alphaHash;
    const HAS_EXTENSIONS = !!material.extensions;
    let toneMapping = NoToneMapping;
    if (material.toneMapped) {
      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
        toneMapping = renderer.toneMapping;
      }
    }
    const parameters = {
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      batching: IS_BATCHEDMESH,
      batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
      alphaToCoverage: !!material.alphaToCoverage,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      dispersion: HAS_DISPERSION,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      //
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //
      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: !!fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      reverseDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numLightProbes: lights.numLightProbes,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping,
      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
      decodeVideoTextureEmissive: HAS_EMISSIVEMAP && material.emissiveMap.isVideoTexture === true && ColorManagement.getTransfer(material.emissiveMap.colorSpace) === SRGBTransfer,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    parameters.vertexUv1s = _activeChannels.has(1);
    parameters.vertexUv2s = _activeChannels.has(2);
    parameters.vertexUv3s = _activeChannels.has(3);
    _activeChannels.clear();
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.numLightProbes);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.supportsVertexTextures)
      _programLayers.enable(0);
    if (parameters.instancing)
      _programLayers.enable(1);
    if (parameters.instancingColor)
      _programLayers.enable(2);
    if (parameters.instancingMorph)
      _programLayers.enable(3);
    if (parameters.matcap)
      _programLayers.enable(4);
    if (parameters.envMap)
      _programLayers.enable(5);
    if (parameters.normalMapObjectSpace)
      _programLayers.enable(6);
    if (parameters.normalMapTangentSpace)
      _programLayers.enable(7);
    if (parameters.clearcoat)
      _programLayers.enable(8);
    if (parameters.iridescence)
      _programLayers.enable(9);
    if (parameters.alphaTest)
      _programLayers.enable(10);
    if (parameters.vertexColors)
      _programLayers.enable(11);
    if (parameters.vertexAlphas)
      _programLayers.enable(12);
    if (parameters.vertexUv1s)
      _programLayers.enable(13);
    if (parameters.vertexUv2s)
      _programLayers.enable(14);
    if (parameters.vertexUv3s)
      _programLayers.enable(15);
    if (parameters.vertexTangents)
      _programLayers.enable(16);
    if (parameters.anisotropy)
      _programLayers.enable(17);
    if (parameters.alphaHash)
      _programLayers.enable(18);
    if (parameters.batching)
      _programLayers.enable(19);
    if (parameters.dispersion)
      _programLayers.enable(20);
    if (parameters.batchingColor)
      _programLayers.enable(21);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog)
      _programLayers.enable(0);
    if (parameters.useFog)
      _programLayers.enable(1);
    if (parameters.flatShading)
      _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(3);
    if (parameters.reverseDepthBuffer)
      _programLayers.enable(4);
    if (parameters.skinning)
      _programLayers.enable(5);
    if (parameters.morphTargets)
      _programLayers.enable(6);
    if (parameters.morphNormals)
      _programLayers.enable(7);
    if (parameters.morphColors)
      _programLayers.enable(8);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(9);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.useDepthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.transmission)
      _programLayers.enable(15);
    if (parameters.sheen)
      _programLayers.enable(16);
    if (parameters.opaque)
      _programLayers.enable(17);
    if (parameters.pointsUvs)
      _programLayers.enable(18);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(19);
    if (parameters.decodeVideoTextureEmissive)
      _programLayers.enable(20);
    if (parameters.alphaToCoverage)
      _programLayers.enable(21);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function has(object) {
    return properties.has(object);
  }
  function get(object) {
    let map2 = properties.get(object);
    if (map2 === void 0) {
      map2 = {};
      properties.set(object, map2);
    }
    return map2;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    has,
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list;
    if (listArray === void 0) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList();
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r = 0, g = 0, b = 0;
    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    let numLightProbes = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    for (let i = 0, l2 = lights.length; i < l2; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
        numLightProbes++;
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow) numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (extensions.has("OES_texture_float_linear") === true) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      state.numLightProbes = numLightProbes;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      hash.numLightProbes = numLightProbes;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l2 = lights.length; i < l2; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions) {
  const lights = new WebGLLights(extensions);
  const lightsArray = [];
  const shadowsArray = [];
  function init(camera) {
    state.camera = camera;
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    camera: null,
    lights,
    transmissionRenderTarget: {}
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === void 0) {
      renderState = new WebGLRenderState(extensions);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
class MeshDepthMaterial extends Material {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}
class MeshDistanceMaterial extends Material {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(renderer, objects, capabilities) {
  let _frustum2 = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize;
  const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    const currentRenderTarget = renderer.getRenderTarget();
    const activeCubeFace = renderer.getActiveCubeFace();
    const activeMipmapLevel = renderer.getActiveMipmapLevel();
    const _state = renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      renderer.setRenderTarget(shadow.map);
      renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum2 = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.mapPass);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.map);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
          material.addEventListener("dispose", onMaterialDispose);
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum2.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
              renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
          renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
        }
      }
    }
    const children = object.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    for (const id in _materialCache) {
      const cache = _materialCache[id];
      const uuid = event.target.uuid;
      if (uuid in cache) {
        const shadowMaterial = cache[uuid];
        shadowMaterial.dispose();
        delete cache[uuid];
      }
    }
  }
}
const reversedFuncs = {
  [NeverDepth]: AlwaysDepth,
  [LessDepth]: GreaterDepth,
  [EqualDepth]: NotEqualDepth,
  [LessEqualDepth]: GreaterEqualDepth,
  [AlwaysDepth]: NeverDepth,
  [GreaterDepth]: LessDepth,
  [NotEqualDepth]: EqualDepth,
  [GreaterEqualDepth]: LessEqualDepth
};
function WebGLState(gl, extensions) {
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color.set(r, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let reversed = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setReversed: function(value) {
        if (reversed !== value) {
          const ext = extensions.get("EXT_clip_control");
          if (reversed) {
            ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT);
          } else {
            ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.NEGATIVE_ONE_TO_ONE_EXT);
          }
          const oldDepth = currentDepthClear;
          currentDepthClear = null;
          this.setClear(oldDepth);
        }
        reversed = value;
      },
      getReversed: function() {
        return reversed;
      },
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (reversed) depthFunc = reversedFuncs[depthFunc];
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          if (reversed) {
            depth = 1 - depth;
          }
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
        reversed = false;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgramMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentBlendColor = new Color(0, 0, 0);
  let currentBlendAlpha = 0;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
  const viewportParam = gl.getParameter(gl.VIEWPORT);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count, dimensions) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (let i = 0; i < count; i++) {
      if (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) {
        gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      } else {
        gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
  emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (target === gl.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
      }
      if (target === gl.FRAMEBUFFER) {
        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      const textures = renderTarget.textures;
      if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
        for (let i = 0, il = textures.length; i < il; i++) {
          drawBuffers2[i] = gl.COLOR_ATTACHMENT0 + i;
        }
        drawBuffers2.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers2[0] !== gl.BACK) {
        drawBuffers2[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl.drawBuffers(drawBuffers2);
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl.FUNC_ADD,
    [SubtractEquation]: gl.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
  };
  equationToGL[MinEquation] = gl.MIN;
  equationToGL[MaxEquation] = gl.MAX;
  const factorToGL = {
    [ZeroFactor]: gl.ZERO,
    [OneFactor]: gl.ONE,
    [SrcColorFactor]: gl.SRC_COLOR,
    [SrcAlphaFactor]: gl.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl.DST_COLOR,
    [DstAlphaFactor]: gl.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: gl.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlendColor.set(0, 0, 0);
        currentBlendAlpha = 0;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
      gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
      currentBlendColor.copy(blendColor);
      currentBlendAlpha = blendAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexImage3D() {
    try {
      gl.compressedTexImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl.compressedTexSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendColor(0, 0, 0, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
    depthBuffer.setReversed(false);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.clearStencil(0);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);
    gl.polygonOffset(0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentBlendColor = new Color(0, 0, 0);
    currentBlendAlpha = 0;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset
  };
}
function getByteLength(width, height, format, type) {
  const typeByteLength = getTextureTypeByteLength(type);
  switch (format) {
    case AlphaFormat:
      return width * height;
    case LuminanceFormat:
      return width * height;
    case LuminanceAlphaFormat:
      return width * height * 2;
    case RedFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RedIntegerFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RGFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGIntegerFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGBFormat:
      return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAIntegerFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
      return Math.max(width, 16) * Math.max(height, 8) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
      return Math.max(width, 8) * Math.max(height, 8) / 2;
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_4x4_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${format} format.`
  );
}
function getTextureTypeByteLength(type) {
  switch (type) {
    case UnsignedByteType:
    case ByteType:
      return { byteLength: 1, components: 1 };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
      return { byteLength: 2, components: 1 };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
      return { byteLength: 2, components: 4 };
    case UnsignedIntType:
    case IntType:
    case FloatType:
      return { byteLength: 4, components: 1 };
    case UnsignedInt5999Type:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${type}.`);
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
  const _imageDimensions = new Vector2();
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(width, height)
    ) : createElementNS("canvas");
  }
  function resizeImage(image, needsNewCanvas, maxSize) {
    let scale = 1;
    const dimensions = getDimensions(image);
    if (dimensions.width > maxSize || dimensions.height > maxSize) {
      scale = maxSize / Math.max(dimensions.width, dimensions.height);
    }
    if (scale < 1) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap || typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
        const width = Math.floor(scale * dimensions.width);
        const height = Math.floor(scale * dimensions.height);
        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + dimensions.width + "x" + dimensions.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + dimensions.width + "x" + dimensions.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function textureNeedsGenerateMipmaps(texture) {
    return texture.generateMipmaps;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getTargetType(texture) {
    if (texture.isWebGLCubeRenderTarget) return _gl.TEXTURE_CUBE_MAP;
    if (texture.isWebGL3DRenderTarget) return _gl.TEXTURE_3D;
    if (texture.isWebGLArrayRenderTarget || texture.isCompressedArrayTexture) return _gl.TEXTURE_2D_ARRAY;
    return _gl.TEXTURE_2D;
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.R8I;
      if (glType === _gl.SHORT) internalFormat = _gl.R16I;
      if (glType === _gl.INT) internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RG_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
      if (glType === _gl.INT) internalFormat = _gl.RG32I;
    }
    if (glFormat === _gl.RGB_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGB16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGB32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGB8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGB16I;
      if (glType === _gl.INT) internalFormat = _gl.RGB32I;
    }
    if (glFormat === _gl.RGBA_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGBA16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGBA32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGBA8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGBA16I;
      if (glType === _gl.INT) internalFormat = _gl.RGBA32I;
    }
    if (glFormat === _gl.RGB) {
      if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;
    }
    if (glFormat === _gl.RGBA) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getInternalDepthFormat(useStencil, depthType) {
    let glInternalFormat;
    if (useStencil) {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH32F_STENCIL8;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.");
      }
    } else {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH_COMPONENT24;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH_COMPONENT32F;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH_COMPONENT16;
      }
    }
    return glInternalFormat;
  }
  function getMipLevels(texture, image) {
    if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0) return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
      properties.remove(renderTarget.depthTexture);
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        }
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    const textures = renderTarget.textures;
    for (let i = 0, il = textures.length; i < il; i++) {
      const attachmentProperties = properties.get(textures[i]);
      if (attachmentProperties.__webglTexture) {
        _gl.deleteTexture(attachmentProperties.__webglTexture);
        info.memory.textures--;
      }
      properties.remove(textures[i]);
    }
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL
  };
  function setTextureParameters(textureType, texture) {
    if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
      console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.");
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
    if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    if (texture.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture.magFilter === NearestFilter) return;
      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      let image = resizeImage(texture.image, false, capabilities.maxTextureSize);
      image = verifyColorSpace(texture, image);
      const glFormat = utils.convert(texture.format, texture.colorSpace);
      const glType = utils.convert(texture.type);
      let glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
      setTextureParameters(textureType, texture);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      const levels = getMipLevels(texture, image);
      if (texture.isDepthTexture) {
        glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    if (texture.layerUpdates.size > 0) {
                      const layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);
                      for (const layerIndex of texture.layerUpdates) {
                        const layerData = mipmap.data.subarray(
                          layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
                          (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
                        );
                        state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData);
                      }
                      texture.clearLayerUpdates();
                    } else {
                      state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
                    }
                  }
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            if (texture.layerUpdates.size > 0) {
              const layerByteLength = getByteLength(image.width, image.height, texture.format, texture.type);
              for (const layerIndex of texture.layerUpdates) {
                const layerData = image.data.subarray(
                  layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
                  (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT
                );
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);
              }
              texture.clearLayerUpdates();
            } else {
              state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            }
          }
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          }
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
          } else {
            let width = image.width, height = image.height;
            for (let i = 0; i < levels; i++) {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            const dimensions = getDimensions(mipmaps[0]);
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              const dimensions = getDimensions(image);
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], true, capabilities.maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
        cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
      }
      const image = cubeImage[0], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      let levels = getMipLevels(texture, image);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
        }
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0) levels++;
          const dimensions = getDimensions(cubeImage[0]);
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
        }
        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
    const glFormat = utils.convert(texture.format, texture.colorSpace);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    textureProperties.__renderTarget = renderTarget;
    if (!renderTargetProperties.__hasExternalTextures) {
      const width = Math.max(1, renderTarget.width >> level);
      const height = Math.max(1, renderTarget.height >> level);
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer) {
      const depthTexture = renderTarget.depthTexture;
      const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
      const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
      const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
      const samples = getRenderTargetSamples(renderTarget);
      const isUseMultisampledRTT = useMultisampledRTT(renderTarget);
      if (isUseMultisampledRTT) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (isMultisample) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const textures = renderTarget.textures;
      for (let i = 0; i < textures.length; i++) {
        const texture = textures[i];
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    const textureProperties = properties.get(renderTarget.depthTexture);
    textureProperties.__renderTarget = renderTarget;
    if (!textureProperties.__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = textureProperties.__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture) {
      const depthTexture = renderTarget.depthTexture;
      if (renderTargetProperties.__depthDisposeCallback) {
        renderTargetProperties.__depthDisposeCallback();
      }
      if (depthTexture) {
        const disposeEvent = () => {
          delete renderTargetProperties.__boundDepthTexture;
          delete renderTargetProperties.__depthDisposeCallback;
          depthTexture.removeEventListener("dispose", disposeEvent);
        };
        depthTexture.addEventListener("dispose", disposeEvent);
        renderTargetProperties.__depthDisposeCallback = disposeEvent;
      }
      renderTargetProperties.__boundDepthTexture = depthTexture;
    }
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
          if (renderTargetProperties.__webglDepthbuffer[i] === void 0) {
            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
          } else {
            const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
            const renderbuffer = renderTargetProperties.__webglDepthbuffer[i];
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
          }
        }
      } else {
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer === void 0) {
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        } else {
          const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          const renderbuffer = renderTargetProperties.__webglDepthbuffer;
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
        }
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    const textures = renderTarget.textures;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = textures.length > 1;
    if (!isMultipleRenderTargets) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i] = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      }
    } else {
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let level = 0; level < texture.mipmaps.length; level++) {
          renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        for (let i = 0, il = textures.length; i < il; i++) {
          const attachmentProperties = properties.get(textures[i]);
          if (attachmentProperties.__webglTexture === void 0) {
            attachmentProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
          }
        }
      }
      if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          const texture2 = textures[i];
          renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
          const glFormat = utils.convert(texture2.format, texture2.colorSpace);
          const glType = utils.convert(texture2.type);
          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      for (let i = 0; i < 6; i++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      for (let i = 0, il = textures.length; i < il; i++) {
        const attachment = textures[i];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0);
        if (textureNeedsGenerateMipmaps(attachment)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture);
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        for (let level = 0; level < texture.mipmaps.length; level++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
        }
      } else {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const textures = renderTarget.textures;
    for (let i = 0, il = textures.length; i < il; i++) {
      const texture = textures[i];
      if (textureNeedsGenerateMipmaps(texture)) {
        const targetType = getTargetType(renderTarget);
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(targetType, webglTexture);
        generateMipmap(targetType);
        state.unbindTexture();
      }
    }
  }
  const invalidationArrayRead = [];
  const invalidationArrayDraw = [];
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.samples > 0) {
      if (useMultisampledRTT(renderTarget) === false) {
        const textures = renderTarget.textures;
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = _gl.COLOR_BUFFER_BIT;
        const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
        const renderTargetProperties = properties.get(renderTarget);
        const isMultipleRenderTargets = textures.length > 1;
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          if (renderTarget.resolveDepthBuffer) {
            if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
            if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
          }
          if (isMultipleRenderTargets) {
            _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
            const webglTexture = properties.get(textures[i]).__webglTexture;
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
          }
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
          if (supportsInvalidateFramebuffer === true) {
            invalidationArrayRead.length = 0;
            invalidationArrayDraw.length = 0;
            invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i);
            if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
              invalidationArrayRead.push(depthStyle);
              invalidationArrayDraw.push(depthStyle);
              _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
            }
            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
            const webglTexture = properties.get(textures[i]).__webglTexture;
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
          }
        }
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
          const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(capabilities.maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const colorSpace = texture.colorSpace;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true) return image;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
        if (format !== RGBAFormat || type !== UnsignedByteType) {
          console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
      }
    }
    return image;
  }
  function getDimensions(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement) {
      _imageDimensions.width = image.naturalWidth || image.width;
      _imageDimensions.height = image.naturalHeight || image.height;
    } else if (typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
      _imageDimensions.width = image.displayWidth;
      _imageDimensions.height = image.displayHeight;
    } else {
      _imageDimensions.width = image.width;
      _imageDimensions.height = image.height;
    }
    return _imageDimensions;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions) {
  function convert(p, colorSpace = NoColorSpace) {
    let extension;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
    if (p === ByteType) return gl.BYTE;
    if (p === ShortType) return gl.SHORT;
    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p === IntType) return gl.INT;
    if (p === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p === FloatType) return gl.FLOAT;
    if (p === HalfFloatType) return gl.HALF_FLOAT;
    if (p === AlphaFormat) return gl.ALPHA;
    if (p === RGBFormat) return gl.RGB;
    if (p === RGBAFormat) return gl.RGBA;
    if (p === LuminanceFormat) return gl.LUMINANCE;
    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
    if (p === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p === RedFormat) return gl.RED;
    if (p === RedIntegerFormat) return gl.RED_INTEGER;
    if (p === RGFormat) return gl.RG;
    if (p === RGIntegerFormat) return gl.RG_INTEGER;
    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }
    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;
    return gl[p] !== void 0 ? gl[p] : null;
  }
  return { convert };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.cameras = array;
  }
}
class Group extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
}
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  // private method
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === void 0) {
      const joint = new Group();
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
}
const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class WebXRDepthSensing {
  constructor() {
    this.texture = null;
    this.mesh = null;
    this.depthNear = 0;
    this.depthFar = 0;
  }
  init(renderer, depthData, renderState) {
    if (this.texture === null) {
      const texture = new Texture();
      const texProps = renderer.properties.get(texture);
      texProps.__webglTexture = depthData.texture;
      if (depthData.depthNear != renderState.depthNear || depthData.depthFar != renderState.depthFar) {
        this.depthNear = depthData.depthNear;
        this.depthFar = depthData.depthFar;
      }
      this.texture = texture;
    }
  }
  getMesh(cameraXR) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const viewport = cameraXR.cameras[0].viewport;
        const material = new ShaderMaterial({
          vertexShader: _occlusion_vertex,
          fragmentShader: _occlusion_fragment,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: viewport.z },
            depthHeight: { value: viewport.w }
          }
        });
        this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
      }
    }
    return this.mesh;
  }
  reset() {
    this.texture = null;
    this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class WebXRManager extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let foveation = 1;
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const depthSensing = new WebXRDepthSensing();
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    const currentSize = new Vector2();
    let currentPixelRatio = null;
    const cameraL = new PerspectiveCamera();
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraXR = new ArrayCamera();
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== void 0) {
        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        if (inputSource === null) continue;
        controllerInputSources[i] = null;
        controllers[i].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      depthSensing.reset();
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      renderer.setPixelRatio(currentPixelRatio);
      renderer.setSize(currentSize.width, currentSize.height, false);
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function(space) {
      customReferenceSpace = space;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        currentPixelRatio = renderer.getPixelRatio();
        renderer.getSize(currentSize);
        if (session.renderState.layers === void 0) {
          const layerInit = {
            antialias: attributes.antialias,
            alpha: true,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          renderer.setPixelRatio(1);
          renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              colorSpace: renderer.outputColorSpace,
              stencilBuffer: attributes.stencil
            }
          );
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: gl.RGBA8,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          renderer.setPixelRatio(1);
          renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              colorSpace: renderer.outputColorSpace,
              samples: attributes.antialias ? 4 : 0,
              resolveDepthBuffer: glProjLayer.ignoreDepthValues === false
            }
          );
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(foveation);
        customReferenceSpace = null;
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    this.getEnvironmentBlendMode = function() {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    this.getDepthTexture = function() {
      return depthSensing.getDepthTexture();
    };
    function onInputSourcesChange(event) {
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const index = controllerInputSources.indexOf(inputSource);
        if (index >= 0) {
          controllerInputSources[index] = null;
          controllers[index].disconnect(inputSource);
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i2 = 0; i2 < controllers.length; i2++) {
            if (i2 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i2;
              break;
            } else if (controllerInputSources[i2] === null) {
              controllerInputSources[i2] = inputSource;
              controllerIndex = i2;
              break;
            }
          }
          if (controllerIndex === -1) break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(inputSource);
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      if (projL[10] === -1) {
        camera.projectionMatrix.copy(cameraL2.projectionMatrix);
        camera.projectionMatrixInverse.copy(cameraL2.projectionMatrixInverse);
      } else {
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
      }
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null) return;
      let depthNear = camera.near;
      let depthFar = camera.far;
      if (depthSensing.texture !== null) {
        if (depthSensing.depthNear > 0) depthNear = depthSensing.depthNear;
        if (depthSensing.depthFar > 0) depthFar = depthSensing.depthFar;
      }
      cameraXR.near = cameraR.near = cameraL.near = depthNear;
      cameraXR.far = cameraR.far = cameraL.far = depthFar;
      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
      }
      cameraL.layers.mask = camera.layers.mask | 2;
      cameraR.layers.mask = camera.layers.mask | 4;
      cameraXR.layers.mask = cameraL.layers.mask | cameraR.layers.mask;
      const parent = camera.parent;
      const cameras2 = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      updateUserCamera(camera, cameraXR, parent);
    };
    function updateUserCamera(camera, cameraXR2, parent) {
      if (parent === null) {
        camera.matrix.copy(cameraXR2.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR2.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    this.getCamera = function() {
      return cameraXR;
    };
    this.getFoveation = function() {
      if (glProjLayer === null && glBaseLayer === null) {
        return void 0;
      }
      return foveation;
    };
    this.setFoveation = function(value) {
      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    this.hasDepthSensing = function() {
      return depthSensing.texture !== null;
    };
    this.getDepthSensingMesh = function() {
      return depthSensing.getMesh(cameraXR);
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraXRNeedsUpdate = false;
        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i === 0) {
              renderer.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
              );
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i];
          if (camera === void 0) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i);
            camera.viewport = new Vector4();
            cameras[i] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }
        const enabledFeatures = session.enabledFeatures;
        if (enabledFeatures && enabledFeatures.includes("depth-sensing")) {
          const depthData = glBinding.getDepthInformation(views[0]);
          if (depthData && depthData.isValid && depthData.texture) {
            depthSensing.init(renderer, depthData, session.renderState);
          }
        }
      }
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        const controller = controllers[i];
        if (inputSource !== null && controller !== void 0) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({ type: "planesdetected", data: frame });
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
}
const _e1 = /* @__PURE__ */ new Euler();
const _m1 = /* @__PURE__ */ new Matrix4();
function WebGLMaterials(renderer, properties) {
  function refreshTransformUniform(map2, uniform) {
    if (map2.matrixAutoUpdate === true) {
      map2.updateMatrix();
    }
    uniform.value.copy(map2.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const materialProperties = properties.get(material);
    const envMap = materialProperties.envMap;
    const envMapRotation = materialProperties.envMapRotation;
    if (envMap) {
      uniforms.envMap.value = envMap;
      _e1.copy(envMapRotation);
      _e1.x *= -1;
      _e1.y *= -1;
      _e1.z *= -1;
      if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
        _e1.y *= -1;
        _e1.z *= -1;
      }
      uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    if (material.envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.dispersion > 0) {
      uniforms.dispersion.value = material.dispersion;
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
  function bind2(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i = 0; i < maxBindingPoints; i++) {
      if (allocatedBindingPoints.indexOf(i) === -1) {
        allocatedBindingPoints.push(i);
        return i;
      }
    }
    console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache = uniformsGroup.__cache;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    for (let i = 0, il = uniforms.length; i < il; i++) {
      const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
      for (let j = 0, jl = uniformArray.length; j < jl; j++) {
        const uniform = uniformArray[j];
        if (hasUniformChanged(uniform, i, j, cache) === true) {
          const offset = uniform.__offset;
          const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
          let arrayOffset = 0;
          for (let k = 0; k < values.length; k++) {
            const value = values[k];
            const info2 = getUniformSize(value);
            if (typeof value === "number" || typeof value === "boolean") {
              uniform.__data[0] = value;
              gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
            } else if (value.isMatrix3) {
              uniform.__data[0] = value.elements[0];
              uniform.__data[1] = value.elements[1];
              uniform.__data[2] = value.elements[2];
              uniform.__data[3] = 0;
              uniform.__data[4] = value.elements[3];
              uniform.__data[5] = value.elements[4];
              uniform.__data[6] = value.elements[5];
              uniform.__data[7] = 0;
              uniform.__data[8] = value.elements[6];
              uniform.__data[9] = value.elements[7];
              uniform.__data[10] = value.elements[8];
              uniform.__data[11] = 0;
            } else {
              value.toArray(uniform.__data, arrayOffset);
              arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
            }
          }
          gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
        }
      }
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index, indexArray, cache) {
    const value = uniform.value;
    const indexString = index + "_" + indexArray;
    if (cache[indexString] === void 0) {
      if (typeof value === "number" || typeof value === "boolean") {
        cache[indexString] = value;
      } else {
        cache[indexString] = value.clone();
      }
      return true;
    } else {
      const cachedObject = cache[indexString];
      if (typeof value === "number" || typeof value === "boolean") {
        if (cachedObject !== value) {
          cache[indexString] = value;
          return true;
        }
      } else {
        if (cachedObject.equals(value) === false) {
          cachedObject.copy(value);
          return true;
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    for (let i = 0, l2 = uniforms.length; i < l2; i++) {
      const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
      for (let j = 0, jl = uniformArray.length; j < jl; j++) {
        const uniform = uniformArray[j];
        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        for (let k = 0, kl = values.length; k < kl; k++) {
          const value = values[k];
          const info2 = getUniformSize(value);
          const chunkOffset2 = offset % chunkSize;
          const chunkPadding = chunkOffset2 % info2.boundary;
          const chunkStart = chunkOffset2 + chunkPadding;
          offset += chunkPadding;
          if (chunkStart !== 0 && chunkSize - chunkStart < info2.storage) {
            offset += chunkSize - chunkStart;
          }
          uniform.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);
          uniform.__offset = offset;
          offset += info2.storage;
        }
      }
    }
    const chunkOffset = offset % chunkSize;
    if (chunkOffset > 0) offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    if (typeof value === "number" || typeof value === "boolean") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (const id in buffers) {
      gl.deleteBuffer(buffers[id]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind: bind2,
    update,
    dispose
  };
}
class WebGLRenderer {
  constructor(parameters = {}) {
    const {
      canvas = createCanvasElement(),
      context = null,
      depth = true,
      stencil = false,
      alpha = false,
      antialias = false,
      premultipliedAlpha = true,
      preserveDrawingBuffer = false,
      powerPreference = "default",
      failIfMajorPerformanceCaveat = false,
      reverseDepthBuffer = false
    } = parameters;
    this.isWebGLRenderer = true;
    let _alpha;
    if (context !== null) {
      if (typeof WebGLRenderingContext !== "undefined" && context instanceof WebGLRenderingContext) {
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      }
      _alpha = context.getContextAttributes().alpha;
    } else {
      _alpha = alpha;
    }
    const uintClearColor = new Uint32Array(4);
    const intClearColor = new Int32Array(4);
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = canvas;
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: true,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this._outputColorSpace = SRGBColorSpace;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    const _currentClearColor = new Color(0);
    let _currentClearAlpha = 0;
    let _width = canvas.width;
    let _height = canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum2 = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    const _currentProjectionMatrix = new Matrix4();
    const _projScreenMatrix2 = new Matrix4();
    const _vector32 = new Vector3();
    const _vector4 = new Vector4();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    let _renderBackground = false;
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = context;
    function getContext(contextName, contextAttributes) {
      return canvas.getContext(contextName, contextAttributes);
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        powerPreference,
        failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in canvas) canvas.setAttribute("data-engine", `three.js r${REVISION}`);
      canvas.addEventListener("webglcontextlost", onContextLost, false);
      canvas.addEventListener("webglcontextrestored", onContextRestore, false);
      canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextName = "webgl2";
        _gl = getContext(contextName, contextAttributes);
        if (_gl === null) {
          if (getContext(contextName)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      extensions.init();
      utils = new WebGLUtils(_gl, extensions);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
      state = new WebGLState(_gl, extensions);
      if (capabilities.reverseDepthBuffer && reverseDepthBuffer) {
        state.buffers.depth.setReversed(true);
      }
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl);
      bindingStates = new WebGLBindingStates(_gl, attributes);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0) return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle = true) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color = true, depth2 = true, stencil2 = true) {
      let bits = 0;
      if (color) {
        let isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          const targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
        }
        if (isIntegerFormat) {
          const targetType = _currentRenderTarget.texture.type;
          const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
          const clearColor = background.getClearColor();
          const a = background.getClearAlpha();
          const r = clearColor.r;
          const g = clearColor.g;
          const b = clearColor.b;
          if (isUnsignedType) {
            uintClearColor[0] = r;
            uintClearColor[1] = g;
            uintClearColor[2] = b;
            uintClearColor[3] = a;
            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
          } else {
            intClearColor[0] = r;
            intClearColor[1] = g;
            intClearColor[2] = b;
            intClearColor[3] = a;
            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
          }
        } else {
          bits |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth2) {
        bits |= _gl.DEPTH_BUFFER_BIT;
      }
      if (stencil2) {
        bits |= _gl.STENCIL_BUFFER_BIT;
        this.state.buffers.stencil.setMask(4294967295);
      }
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      canvas.removeEventListener("webglcontextlost", onContextLost, false);
      canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
      canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null) scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        if (index === void 0) return;
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index.count);
      } else if (position !== void 0 && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity) return;
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0) lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer.setMode(_gl.LINE_LOOP);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer.setMode(_gl.TRIANGLES);
      }
      if (object.isBatchedMesh) {
        if (object._multiDrawInstances !== null) {
          renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
        } else {
          if (!extensions.get("WEBGL_multi_draw")) {
            const starts = object._multiDrawStarts;
            const counts = object._multiDrawCounts;
            const drawCount2 = object._multiDrawCount;
            const bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;
            const uniforms = properties.get(material).currentProgram.getUniforms();
            for (let i = 0; i < drawCount2; i++) {
              uniforms.setValue(_gl, "_gl_DrawID", i);
              renderer.render(starts[i] / bytesPerElement, counts[i]);
            }
          } else {
            renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
          }
        }
      } else if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    function prepareMaterial(material, scene, object) {
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = FrontSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = DoubleSide;
      } else {
        getProgram(material, scene, object);
      }
    }
    this.compile = function(scene, camera, targetScene = null) {
      if (targetScene === null) targetScene = scene;
      currentRenderState = renderStates.get(targetScene);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      targetScene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      if (scene !== targetScene) {
        scene.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
      }
      currentRenderState.setupLights();
      const materials2 = /* @__PURE__ */ new Set();
      scene.traverse(function(object) {
        if (!(object.isMesh || object.isPoints || object.isLine || object.isSprite)) {
          return;
        }
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              prepareMaterial(material2, targetScene, object);
              materials2.add(material2);
            }
          } else {
            prepareMaterial(material, targetScene, object);
            materials2.add(material);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
      return materials2;
    };
    this.compileAsync = function(scene, camera, targetScene = null) {
      const materials2 = this.compile(scene, camera, targetScene);
      return new Promise((resolve) => {
        function checkMaterialsReady() {
          materials2.forEach(function(material) {
            const materialProperties = properties.get(material);
            const program = materialProperties.currentProgram;
            if (program.isReady()) {
              materials2.delete(material);
            }
          });
          if (materials2.size === 0) {
            resolve(scene);
            return;
          }
          setTimeout(checkMaterialsReady, 10);
        }
        if (extensions.get("KHR_parallel_shader_compile") !== null) {
          checkMaterialsReady();
        } else {
          setTimeout(checkMaterialsReady, 10);
        }
      });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined") animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true) return;
      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum2.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      if (xr.enabled === true && xr.isPresenting === true) {
        const depthSensingMesh = _this.xr.getDepthSensingMesh();
        if (depthSensingMesh !== null) {
          projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
        }
      }
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      _renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
      if (_renderBackground) {
        background.addToRenderList(currentRenderList, scene);
      }
      this.info.render.frame++;
      if (_clippingEnabled === true) clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true) clipping.endShadows();
      if (this.info.autoReset === true) this.info.reset();
      const opaqueObjects = currentRenderList.opaque;
      const transmissiveObjects = currentRenderList.transmissive;
      currentRenderState.setupLights();
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        if (transmissiveObjects.length > 0) {
          for (let i = 0, l2 = cameras.length; i < l2; i++) {
            const camera2 = cameras[i];
            renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
          }
        }
        if (_renderBackground) background.render(scene);
        for (let i = 0, l2 = cameras.length; i < l2; i++) {
          const camera2 = cameras[i];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
        if (_renderBackground) background.render(scene);
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
        if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false) return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true) object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum2.intersectsSprite(object)) {
            if (sortObjects) {
              _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum2.intersectsObject(object)) {
            const geometry = objects.update(object);
            const material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== void 0) {
                if (object.boundingSphere === null) object.computeBoundingSphere();
                _vector4.copy(object.boundingSphere.center);
              } else {
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                _vector4.copy(geometry.boundingSphere.center);
              }
              _vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l2 = groups.length; i < l2; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l2 = children.length; i < l2; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      if (viewport) state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      if (overrideMaterial !== null) {
        return;
      }
      if (currentRenderState.state.transmissionRenderTarget[camera.id] === void 0) {
        currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: 4,
          stencilBuffer: stencil,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false,
          colorSpace: ColorManagement.workingColorSpace
        });
      }
      const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
      const activeViewport = camera.viewport || _currentViewport;
      transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1) _this.setClearColor(16777215, 0.5);
      _this.clear();
      if (_renderBackground) background.render(scene);
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      const currentCameraViewport = camera.viewport;
      if (camera.viewport !== void 0) camera.viewport = void 0;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      renderObjects(opaqueObjects, scene, camera);
      textures.updateMultisampleRenderTarget(transmissionRenderTarget);
      textures.updateRenderTargetMipmap(transmissionRenderTarget);
      if (extensions.has("WEBGL_multisampled_render_to_texture") === false) {
        let renderTargetNeedsUpdate = false;
        for (let i = 0, l2 = transmissiveObjects.length; i < l2; i++) {
          const renderItem = transmissiveObjects[i];
          const object = renderItem.object;
          const geometry = renderItem.geometry;
          const material = renderItem.material;
          const group = renderItem.group;
          if (material.side === DoubleSide && object.layers.test(camera.layers)) {
            const currentSide = material.side;
            material.side = BackSide;
            material.needsUpdate = true;
            renderObject(object, scene, camera, geometry, material, group);
            material.side = currentSide;
            material.needsUpdate = true;
            renderTargetNeedsUpdate = true;
          }
        }
        if (renderTargetNeedsUpdate === true) {
          textures.updateMultisampleRenderTarget(transmissionRenderTarget);
          textures.updateRenderTargetMipmap(transmissionRenderTarget);
        }
      }
      _this.setRenderTarget(currentRenderTarget);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      if (currentCameraViewport !== void 0) camera.viewport = currentCameraViewport;
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i = 0, l2 = renderList.length; i < l2; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = null;
      return program;
    }
    function getUniformList(materialProperties) {
      if (materialProperties.uniformsList === null) {
        const progUniforms = materialProperties.currentProgram.getUniforms();
        materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
      }
      return materialProperties.uniformsList;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters2.outputColorSpace;
      materialProperties.batching = parameters2.batching;
      materialProperties.batchingColor = parameters2.batchingColor;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.instancingColor = parameters2.instancingColor;
      materialProperties.instancingMorph = parameters2.instancingMorph;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = _this.toneMapping;
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batching === false) {
          needsProgramChange = true;
        } else if (!object.isBatchedMesh && materialProperties.batching === true) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        const reverseDepthBuffer2 = state.buffers.depth.getReversed();
        if (reverseDepthBuffer2) {
          _currentProjectionMatrix.copy(camera.projectionMatrix);
          toNormalizedProjectionMatrix(_currentProjectionMatrix);
          toReversedProjectionMatrix(_currentProjectionMatrix);
          p_uniforms.setValue(_gl, "projectionMatrix", _currentProjectionMatrix);
        } else {
          p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        }
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));
        }
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2)
          );
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
        }
      }
      if (object.isBatchedMesh) {
        p_uniforms.setOptional(_gl, object, "batchingTexture");
        p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures);
        p_uniforms.setOptional(_gl, object, "batchingIdTexture");
        p_uniforms.setValue(_gl, "batchingIdTexture", object._indirectTexture, textures);
        p_uniforms.setOptional(_gl, object, "batchingColorTexture");
        if (object._colorsTexture !== null) {
          p_uniforms.setValue(_gl, "batchingColorTexture", object._colorsTexture, textures);
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) {
        morphtargets.update(object, geometry, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
        m_uniforms.envMapIntensity.value = scene.environmentIntensity;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups = material.uniformsGroups;
        for (let i = 0, l2 = groups.length; i < l2; i++) {
          const group = groups[i];
          uniformsGroups.update(group, program);
          uniformsGroups.bind(group, program);
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
          console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
          renderTargetProperties.__useRenderToTexture = false;
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        } else if (renderTarget.depthBuffer) {
          const depthTexture = renderTarget.depthTexture;
          if (renderTargetProperties.__boundDepthTexture !== depthTexture) {
            if (depthTexture !== null && properties.has(depthTexture) && (renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height)) {
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            }
            textures.setupDepthRenderbuffer(renderTarget);
          }
        }
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer[activeCubeFace];
          }
          isCube = true;
        } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          if (Array.isArray(__webglFramebuffer)) {
            framebuffer = __webglFramebuffer[activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer;
          }
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (framebufferBound && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (!capabilities.textureFormatReadable(textureFormat)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!capabilities.textureTypeReadable(textureType)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
        }
      }
    };
    this.readRenderTargetPixelsAsync = async function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (!capabilities.textureFormatReadable(textureFormat)) {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        }
        if (!capabilities.textureTypeReadable(textureType)) {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        }
        if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          const glBuffer = _gl.createBuffer();
          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
          _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
          _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
          const currFramebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, currFramebuffer);
          const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
          _gl.flush();
          await probeAsync(_gl, sync, 4);
          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
          _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);
          _gl.deleteBuffer(glBuffer);
          _gl.deleteSync(sync);
          return buffer;
        } else {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
        }
      }
    };
    this.copyFramebufferToTexture = function(texture, position = null, level = 0) {
      if (texture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyFramebufferToTexture function signature has changed.");
        position = arguments[0] || null;
        texture = arguments[1];
      }
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      const x = position !== null ? position.x : 0;
      const y = position !== null ? position.y : 0;
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y, width, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
      if (srcTexture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed.");
        dstPosition = arguments[0] || null;
        srcTexture = arguments[1];
        dstTexture = arguments[2];
        level = arguments[3] || 0;
        srcRegion = null;
      }
      let width, height, depth2, minX, minY, minZ;
      let dstX, dstY, dstZ;
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
      if (srcRegion !== null) {
        width = srcRegion.max.x - srcRegion.min.x;
        height = srcRegion.max.y - srcRegion.min.y;
        depth2 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
        minX = srcRegion.min.x;
        minY = srcRegion.min.y;
        minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
      } else {
        width = image.width;
        height = image.height;
        depth2 = image.depth || 1;
        minX = 0;
        minY = 0;
        minZ = 0;
      }
      if (dstPosition !== null) {
        dstX = dstPosition.x;
        dstY = dstPosition.y;
        dstZ = dstPosition.z;
      } else {
        dstX = 0;
        dstY = 0;
        dstZ = 0;
      }
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        textures.setTexture2D(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
      const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;
      const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;
      if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {
        const srcTextureProperties = properties.get(srcTexture);
        const dstTextureProperties = properties.get(dstTexture);
        const srcRenderTargetProperties = properties.get(srcTextureProperties.__renderTarget);
        const dstRenderTargetProperties = properties.get(dstTextureProperties.__renderTarget);
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer);
        for (let i = 0; i < depth2; i++) {
          if (isSrc3D) {
            _gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(srcTexture).__webglTexture, level, minZ + i);
          }
          if (srcTexture.isDepthTexture) {
            if (isDst3D) {
              _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(dstTexture).__webglTexture, level, dstZ + i);
            }
            _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST);
          } else if (isDst3D) {
            _gl.copyTexSubImage3D(glTarget, level, dstX, dstY, dstZ + i, minX, minY, width, height);
          } else {
            _gl.copyTexSubImage2D(glTarget, level, dstX, dstY, dstZ + i, minX, minY, width, height);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      } else {
        if (isDst3D) {
          if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
            _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image.data);
          } else if (dstTexture.isCompressedArrayTexture) {
            _gl.compressedTexSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, image.data);
          } else {
            _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image);
          }
        } else {
          if (srcTexture.isDataTexture) {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);
          } else if (srcTexture.isCompressedTexture) {
            _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);
          } else {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image);
          }
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps) {
        _gl.generateMipmap(glTarget);
      }
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
      if (srcTexture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyTextureToTexture3D function signature has changed.");
        srcRegion = arguments[0] || null;
        dstPosition = arguments[1] || null;
        srcTexture = arguments[2];
        dstTexture = arguments[3];
        level = arguments[4] || 0;
      }
      warnOnce('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.');
      return this.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);
    };
    this.initRenderTarget = function(target) {
      if (properties.get(target).__webglFramebuffer === void 0) {
        textures.setupRenderTarget(target);
      }
    };
    this.initTexture = function(texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(colorSpace) {
    this._outputColorSpace = colorSpace;
    const gl = this.getContext();
    gl.drawingBufferColorspace = ColorManagement._getDrawingBufferColorSpace(colorSpace);
    gl.unpackColorSpace = ColorManagement._getUnpackColorSpace();
  }
}
class FogExp2 {
  constructor(color, density = 25e-5) {
    this.isFogExp2 = true;
    this.name = "";
    this.color = new Color(color);
    this.density = density;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class Fog {
  constructor(color, near = 1, far = 1e3) {
    this.isFog = true;
    this.name = "";
    this.color = new Color(color);
    this.near = near;
    this.far = far;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class Scene extends Object3D {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.backgroundRotation = new Euler();
    this.environmentIntensity = 1;
    this.environmentRotation = new Euler();
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    this.backgroundRotation.copy(source.backgroundRotation);
    this.environmentIntensity = source.environmentIntensity;
    this.environmentRotation.copy(source.environmentRotation);
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
    data.object.backgroundRotation = this.backgroundRotation.toArray();
    if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
    data.object.environmentRotation = this.environmentRotation.toArray();
    return data;
  }
}
class InterleavedBuffer {
  constructor(array, stride) {
    this.isInterleavedBuffer = true;
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i = 0, l2 = this.stride; i < l2; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const _vector$6 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true;
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m) {
    for (let i = 0, l2 = this.data.count; i < l2; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.applyMatrix4(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l2 = this.count; i < l2; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.applyNormalMatrix(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l2 = this.count; i < l2; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.transformDirection(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.data.stride + this.offset + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized) value = normalize(value, this.array);
    this.data.array[index * this.data.stride + this.offset + component] = value;
    return this;
  }
  setX(index, x) {
    if (this.normalized) x = normalize(x, this.array);
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  }
  setY(index, y) {
    if (this.normalized) y = normalize(y, this.array);
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize(z, this.array);
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  }
  setW(index, w) {
    if (this.normalized) w = normalize(w, this.array);
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  }
  getX(index) {
    let x = this.data.array[index * this.data.stride + this.offset];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  getY(index) {
    let y = this.data.array[index * this.data.stride + this.offset + 1];
    if (this.normalized) y = denormalize(y, this.array);
    return y;
  }
  getZ(index) {
    let z = this.data.array[index * this.data.stride + this.offset + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  getW(index) {
    let w = this.data.array[index * this.data.stride + this.offset + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  setXY(index, x, y) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize(x, this.array);
      y = normalize(y, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize(x, this.array);
      y = normalize(y, this.array);
      z = normalize(z, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize(x, this.array);
      y = normalize(y, this.array);
      z = normalize(z, this.array);
      w = normalize(w, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
}
class SpriteMaterial extends Material {
  static get type() {
    return "SpriteMaterial";
  }
  constructor(parameters) {
    super();
    this.isSpriteMaterial = true;
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
}
let _geometry;
const _intersectPoint = /* @__PURE__ */ new Vector3();
const _worldScale$1 = /* @__PURE__ */ new Vector3();
const _mvPosition = /* @__PURE__ */ new Vector3();
const _alignedPosition = /* @__PURE__ */ new Vector2();
const _rotatedPosition = /* @__PURE__ */ new Vector2();
const _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
const _vA$2 = /* @__PURE__ */ new Vector3();
const _vB$2 = /* @__PURE__ */ new Vector3();
const _vC$2 = /* @__PURE__ */ new Vector3();
const _uvA$1 = /* @__PURE__ */ new Vector2();
const _uvB$1 = /* @__PURE__ */ new Vector2();
const _uvC$1 = /* @__PURE__ */ new Vector2();
class Sprite extends Object3D {
  constructor(material = new SpriteMaterial()) {
    super();
    this.isSprite = true;
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array2 = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array2, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material;
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale$1.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale$1.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA$2.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale$1, sin, cos);
    transformVertex(_vB$2.set(0.5, -0.5, 0), _mvPosition, center, _worldScale$1, sin, cos);
    transformVertex(_vC$2.set(0.5, 0.5, 0), _mvPosition, center, _worldScale$1, sin, cos);
    _uvA$1.set(0, 0);
    _uvB$1.set(1, 0);
    _uvC$1.set(1, 1);
    let intersect2 = raycaster.ray.intersectTriangle(_vA$2, _vB$2, _vC$2, false, _intersectPoint);
    if (intersect2 === null) {
      transformVertex(_vB$2.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale$1, sin, cos);
      _uvB$1.set(0, 1);
      intersect2 = raycaster.ray.intersectTriangle(_vA$2, _vC$2, _vB$2, false, _intersectPoint);
      if (intersect2 === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getInterpolation(_intersectPoint, _vA$2, _vB$2, _vC$2, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.center !== void 0) this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
}
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = /* @__PURE__ */ new Vector3();
const _v2$1 = /* @__PURE__ */ new Vector3();
class LOD extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    this.autoUpdate = true;
  }
  copy(source) {
    super.copy(source, false);
    const levels = source.levels;
    for (let i = 0, l2 = levels.length; i < l2; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance, level.hysteresis);
    }
    this.autoUpdate = source.autoUpdate;
    return this;
  }
  addLevel(object, distance = 0, hysteresis = 0) {
    distance = Math.abs(distance);
    const levels = this.levels;
    let l2;
    for (l2 = 0; l2 < levels.length; l2++) {
      if (distance < levels[l2].distance) {
        break;
      }
    }
    levels.splice(l2, 0, { distance, hysteresis, object });
    this.add(object);
    return this;
  }
  removeLevel(distance) {
    const levels = this.levels;
    for (let i = 0; i < levels.length; i++) {
      if (levels[i].distance === distance) {
        const removedElements = levels.splice(i, 1);
        this.remove(removedElements[0].object);
        return true;
      }
    }
    return false;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(distance) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i, l2;
      for (i = 1, l2 = levels.length; i < l2; i++) {
        let levelDistance = levels[i].distance;
        if (levels[i].object.visible) {
          levelDistance -= levelDistance * levels[i].hysteresis;
        }
        if (distance < levelDistance) {
          break;
        }
      }
      return levels[i - 1].object;
    }
    return null;
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(distance).raycast(raycaster, intersects2);
    }
  }
  update(camera) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$2.setFromMatrixPosition(camera.matrixWorld);
      _v2$1.setFromMatrixPosition(this.matrixWorld);
      const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
      levels[0].object.visible = true;
      let i, l2;
      for (i = 1, l2 = levels.length; i < l2; i++) {
        let levelDistance = levels[i].distance;
        if (levels[i].object.visible) {
          levelDistance -= levelDistance * levels[i].hysteresis;
        }
        if (distance >= levelDistance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i - 1;
      for (; i < l2; i++) {
        levels[i].object.visible = false;
      }
    }
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.autoUpdate === false) data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;
    for (let i = 0, l2 = levels.length; i < l2; i++) {
      const level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance,
        hysteresis: level.hysteresis
      });
    }
    return data;
  }
}
const _basePosition = /* @__PURE__ */ new Vector3();
const _skinIndex = /* @__PURE__ */ new Vector4();
const _skinWeight = /* @__PURE__ */ new Vector4();
const _vector3 = /* @__PURE__ */ new Vector3();
const _matrix4 = /* @__PURE__ */ new Matrix4();
const _vertex = /* @__PURE__ */ new Vector3();
const _sphere$4 = /* @__PURE__ */ new Sphere();
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
const _ray$2 = /* @__PURE__ */ new Ray$1();
class SkinnedMesh extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.isSkinnedMesh = true;
    this.type = "SkinnedMesh";
    this.bindMode = AttachedBindMode;
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
    this.boundingBox = null;
    this.boundingSphere = null;
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i = 0; i < positionAttribute.count; i++) {
      this.getVertexPosition(i, _vertex);
      this.boundingBox.expandByPoint(_vertex);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i = 0; i < positionAttribute.count; i++) {
      this.getVertexPosition(i, _vertex);
      this.boundingSphere.expandByPoint(_vertex);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  raycast(raycaster, intersects2) {
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$4.copy(this.boundingSphere);
    _sphere$4.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (this.boundingBox !== null) {
      if (_ray$2.intersectsBox(this.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$2);
  }
  getVertexPosition(index, target) {
    super.getVertexPosition(index, target);
    this.applyBoneTransform(index, target);
    return target;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i = 0, l2 = skinWeight.count; i < l2; i++) {
      vector.fromBufferAttribute(skinWeight, i);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === AttachedBindMode) {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === DetachedBindMode) {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  applyBoneTransform(index, vector) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
    vector.set(0, 0, 0);
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);
        _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
      }
    }
    return vector.applyMatrix4(this.bindMatrixInverse);
  }
}
class Bone extends Object3D {
  constructor() {
    super();
    this.isBone = true;
    this.type = "Bone";
  }
}
class DataTexture extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isDataTexture = true;
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
const _offsetMatrix = /* @__PURE__ */ new Matrix4();
const _identityMatrix = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4();
      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    }
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i = 0, il = bones.length; i < il; i++) {
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
      _offsetMatrix.toArray(boneMatrices, i * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size = Math.sqrt(this.bones.length * 4);
    size = Math.ceil(size / 4) * 4;
    size = Math.max(size, 4);
    const boneMatrices = new Float32Array(size * size * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
    boneTexture.needsUpdate = true;
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    return this;
  }
  getBoneByName(name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i = 0, l2 = json.bones.length; i < l2; i++) {
      const uuid = json.bones[i];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i = 0, l2 = bones.length; i < l2; i++) {
      const bone = bones[i];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    super(array, itemSize, normalized);
    this.isInstancedBufferAttribute = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
const _instanceIntersects = [];
const _box3 = /* @__PURE__ */ new Box3();
const _identity = /* @__PURE__ */ new Matrix4();
const _mesh$1 = /* @__PURE__ */ new Mesh();
const _sphere$3 = /* @__PURE__ */ new Sphere();
class InstancedMesh extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material);
    this.isInstancedMesh = true;
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.morphTexture = null;
    this.count = count;
    this.boundingBox = null;
    this.boundingSphere = null;
    for (let i = 0; i < count; i++) {
      this.setMatrixAt(i, _identity);
    }
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    this.boundingBox.makeEmpty();
    for (let i = 0; i < count; i++) {
      this.getMatrixAt(i, _instanceLocalMatrix);
      _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
      this.boundingBox.union(_box3);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    this.boundingSphere.makeEmpty();
    for (let i = 0; i < count; i++) {
      this.getMatrixAt(i, _instanceLocalMatrix);
      _sphere$3.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
      this.boundingSphere.union(_sphere$3);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  getColorAt(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  getMorphAt(index, object) {
    const objectInfluences = object.morphTargetInfluences;
    const array = this.morphTexture.source.data.data;
    const len = objectInfluences.length + 1;
    const dataIndex = index * len + 1;
    for (let i = 0; i < objectInfluences.length; i++) {
      objectInfluences[i] = array[dataIndex + i];
    }
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh$1.geometry = this.geometry;
    _mesh$1.material = this.material;
    if (_mesh$1.material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$3.copy(this.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh$1.matrixWorld = _instanceWorldMatrix;
      _mesh$1.raycast(raycaster, _instanceIntersects);
      for (let i = 0, l2 = _instanceIntersects.length; i < l2; i++) {
        const intersect2 = _instanceIntersects[i];
        intersect2.instanceId = instanceId;
        intersect2.object = this;
        intersects2.push(intersect2);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  setMorphAt(index, object) {
    const objectInfluences = object.morphTargetInfluences;
    const len = objectInfluences.length + 1;
    if (this.morphTexture === null) {
      this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);
    }
    const array = this.morphTexture.source.data.data;
    let morphInfluencesSum = 0;
    for (let i = 0; i < objectInfluences.length; i++) {
      morphInfluencesSum += objectInfluences[i];
    }
    const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    const dataIndex = len * index;
    array[dataIndex] = morphBaseInfluence;
    array.set(objectInfluences, dataIndex + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
    if (this.morphTexture !== null) {
      this.morphTexture.dispose();
      this.morphTexture = null;
    }
    return this;
  }
}
function ascIdSort(a, b) {
  return a - b;
}
function sortOpaque(a, b) {
  return a.z - b.z;
}
function sortTransparent(a, b) {
  return b.z - a.z;
}
class MultiDrawRenderList {
  constructor() {
    this.index = 0;
    this.pool = [];
    this.list = [];
  }
  push(start, count, z, index) {
    const pool = this.pool;
    const list = this.list;
    if (this.index >= pool.length) {
      pool.push({
        start: -1,
        count: -1,
        z: -1,
        index: -1
      });
    }
    const item = pool[this.index];
    list.push(item);
    this.index++;
    item.start = start;
    item.count = count;
    item.z = z;
    item.index = index;
  }
  reset() {
    this.list.length = 0;
    this.index = 0;
  }
}
const _matrix$1 = /* @__PURE__ */ new Matrix4();
const _whiteColor = /* @__PURE__ */ new Color(1, 1, 1);
const _frustum = /* @__PURE__ */ new Frustum();
const _box$1 = /* @__PURE__ */ new Box3();
const _sphere$2 = /* @__PURE__ */ new Sphere();
const _vector$5 = /* @__PURE__ */ new Vector3();
const _forward = /* @__PURE__ */ new Vector3();
const _temp = /* @__PURE__ */ new Vector3();
const _renderList = /* @__PURE__ */ new MultiDrawRenderList();
const _mesh$2 = /* @__PURE__ */ new Mesh();
const _batchIntersects$1 = [];
function copyAttributeData(src, target, targetOffset = 0) {
  const itemSize = target.itemSize;
  if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {
    const vertexCount = src.count;
    for (let i = 0; i < vertexCount; i++) {
      for (let c = 0; c < itemSize; c++) {
        target.setComponent(i + targetOffset, c, src.getComponent(i, c));
      }
    }
  } else {
    target.array.set(src.array, targetOffset * itemSize);
  }
  target.needsUpdate = true;
}
function copyArrayContents(src, target) {
  if (src.constructor !== target.constructor) {
    const len = Math.min(src.length, target.length);
    for (let i = 0; i < len; i++) {
      target[i] = src[i];
    }
  } else {
    const len = Math.min(src.length, target.length);
    target.set(new src.constructor(src.buffer, 0, len));
  }
}
class BatchedMesh extends Mesh {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  constructor(maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {
    super(new BufferGeometry(), material);
    this.isBatchedMesh = true;
    this.perObjectFrustumCulled = true;
    this.sortObjects = true;
    this.boundingBox = null;
    this.boundingSphere = null;
    this.customSort = null;
    this._instanceInfo = [];
    this._geometryInfo = [];
    this._availableInstanceIds = [];
    this._availableGeometryIds = [];
    this._nextIndexStart = 0;
    this._nextVertexStart = 0;
    this._geometryCount = 0;
    this._visibilityChanged = true;
    this._geometryInitialized = false;
    this._maxInstanceCount = maxInstanceCount;
    this._maxVertexCount = maxVertexCount;
    this._maxIndexCount = maxIndexCount;
    this._multiDrawCounts = new Int32Array(maxInstanceCount);
    this._multiDrawStarts = new Int32Array(maxInstanceCount);
    this._multiDrawCount = 0;
    this._multiDrawInstances = null;
    this._matricesTexture = null;
    this._indirectTexture = null;
    this._colorsTexture = null;
    this._initMatricesTexture();
    this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let size = Math.sqrt(this._maxInstanceCount * 4);
    size = Math.ceil(size / 4) * 4;
    size = Math.max(size, 4);
    const matricesArray = new Float32Array(size * size * 4);
    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);
    this._matricesTexture = matricesTexture;
  }
  _initIndirectTexture() {
    let size = Math.sqrt(this._maxInstanceCount);
    size = Math.ceil(size);
    const indirectArray = new Uint32Array(size * size);
    const indirectTexture = new DataTexture(indirectArray, size, size, RedIntegerFormat, UnsignedIntType);
    this._indirectTexture = indirectTexture;
  }
  _initColorsTexture() {
    let size = Math.sqrt(this._maxInstanceCount);
    size = Math.ceil(size);
    const colorsArray = new Float32Array(size * size * 4).fill(1);
    const colorsTexture = new DataTexture(colorsArray, size, size, RGBAFormat, FloatType);
    colorsTexture.colorSpace = ColorManagement.workingColorSpace;
    this._colorsTexture = colorsTexture;
  }
  _initializeGeometry(reference) {
    const geometry = this.geometry;
    const maxVertexCount = this._maxVertexCount;
    const maxIndexCount = this._maxIndexCount;
    if (this._geometryInitialized === false) {
      for (const attributeName in reference.attributes) {
        const srcAttribute = reference.getAttribute(attributeName);
        const { array, itemSize, normalized } = srcAttribute;
        const dstArray = new array.constructor(maxVertexCount * itemSize);
        const dstAttribute = new BufferAttribute(dstArray, itemSize, normalized);
        geometry.setAttribute(attributeName, dstAttribute);
      }
      if (reference.getIndex() !== null) {
        const indexArray = maxVertexCount > 65535 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);
        geometry.setIndex(new BufferAttribute(indexArray, 1));
      }
      this._geometryInitialized = true;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry attributes
  _validateGeometry(geometry) {
    const batchGeometry = this.geometry;
    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    }
    for (const attributeName in batchGeometry.attributes) {
      if (!geometry.hasAttribute(attributeName)) {
        throw new Error(`BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`);
      }
      const srcAttribute = geometry.getAttribute(attributeName);
      const dstAttribute = batchGeometry.getAttribute(attributeName);
      if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
      }
    }
  }
  setCustomSort(func) {
    this.customSort = func;
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const boundingBox2 = this.boundingBox;
    const instanceInfo = this._instanceInfo;
    boundingBox2.makeEmpty();
    for (let i = 0, l2 = instanceInfo.length; i < l2; i++) {
      if (instanceInfo[i].active === false) continue;
      const geometryId = instanceInfo[i].geometryIndex;
      this.getMatrixAt(i, _matrix$1);
      this.getBoundingBoxAt(geometryId, _box$1).applyMatrix4(_matrix$1);
      boundingBox2.union(_box$1);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const boundingSphere = this.boundingSphere;
    const instanceInfo = this._instanceInfo;
    boundingSphere.makeEmpty();
    for (let i = 0, l2 = instanceInfo.length; i < l2; i++) {
      if (instanceInfo[i].active === false) continue;
      const geometryId = instanceInfo[i].geometryIndex;
      this.getMatrixAt(i, _matrix$1);
      this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
      boundingSphere.union(_sphere$2);
    }
  }
  addInstance(geometryId) {
    const atCapacity = this._instanceInfo.length >= this.maxInstanceCount;
    if (atCapacity && this._availableInstanceIds.length === 0) {
      throw new Error("BatchedMesh: Maximum item count reached.");
    }
    const instanceInfo = {
      visible: true,
      active: true,
      geometryIndex: geometryId
    };
    let drawId = null;
    if (this._availableInstanceIds.length > 0) {
      this._availableInstanceIds.sort(ascIdSort);
      drawId = this._availableInstanceIds.shift();
      this._instanceInfo[drawId] = instanceInfo;
    } else {
      drawId = this._instanceInfo.length;
      this._instanceInfo.push(instanceInfo);
    }
    const matricesTexture = this._matricesTexture;
    _matrix$1.identity().toArray(matricesTexture.image.data, drawId * 16);
    matricesTexture.needsUpdate = true;
    const colorsTexture = this._colorsTexture;
    if (colorsTexture) {
      _whiteColor.toArray(colorsTexture.image.data, drawId * 4);
      colorsTexture.needsUpdate = true;
    }
    this._visibilityChanged = true;
    return drawId;
  }
  addGeometry(geometry, reservedVertexCount = -1, reservedIndexCount = -1) {
    this._initializeGeometry(geometry);
    this._validateGeometry(geometry);
    const geometryInfo = {
      // geometry information
      vertexStart: -1,
      vertexCount: -1,
      reservedVertexCount: -1,
      indexStart: -1,
      indexCount: -1,
      reservedIndexCount: -1,
      // draw range information
      start: -1,
      count: -1,
      // state
      boundingBox: null,
      boundingSphere: null,
      active: true
    };
    const geometryInfoList = this._geometryInfo;
    geometryInfo.vertexStart = this._nextVertexStart;
    geometryInfo.reservedVertexCount = reservedVertexCount === -1 ? geometry.getAttribute("position").count : reservedVertexCount;
    const index = geometry.getIndex();
    const hasIndex = index !== null;
    if (hasIndex) {
      geometryInfo.indexStart = this._nextIndexStart;
      geometryInfo.reservedIndexCount = reservedIndexCount === -1 ? index.count : reservedIndexCount;
    }
    if (geometryInfo.indexStart !== -1 && geometryInfo.indexStart + geometryInfo.reservedIndexCount > this._maxIndexCount || geometryInfo.vertexStart + geometryInfo.reservedVertexCount > this._maxVertexCount) {
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    }
    let geometryId;
    if (this._availableGeometryIds.length > 0) {
      this._availableGeometryIds.sort(ascIdSort);
      geometryId = this._availableGeometryIds.shift();
      geometryInfoList[geometryId] = geometryInfo;
    } else {
      geometryId = this._geometryCount;
      this._geometryCount++;
      geometryInfoList.push(geometryInfo);
    }
    this.setGeometryAt(geometryId, geometry);
    this._nextIndexStart = geometryInfo.indexStart + geometryInfo.reservedIndexCount;
    this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;
    return geometryId;
  }
  setGeometryAt(geometryId, geometry) {
    if (geometryId >= this._geometryCount) {
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    }
    this._validateGeometry(geometry);
    const batchGeometry = this.geometry;
    const hasIndex = batchGeometry.getIndex() !== null;
    const dstIndex = batchGeometry.getIndex();
    const srcIndex = geometry.getIndex();
    const geometryInfo = this._geometryInfo[geometryId];
    if (hasIndex && srcIndex.count > geometryInfo.reservedIndexCount || geometry.attributes.position.count > geometryInfo.reservedVertexCount) {
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    }
    const vertexStart = geometryInfo.vertexStart;
    const reservedVertexCount = geometryInfo.reservedVertexCount;
    geometryInfo.vertexCount = geometry.getAttribute("position").count;
    for (const attributeName in batchGeometry.attributes) {
      const srcAttribute = geometry.getAttribute(attributeName);
      const dstAttribute = batchGeometry.getAttribute(attributeName);
      copyAttributeData(srcAttribute, dstAttribute, vertexStart);
      const itemSize = srcAttribute.itemSize;
      for (let i = srcAttribute.count, l2 = reservedVertexCount; i < l2; i++) {
        const index = vertexStart + i;
        for (let c = 0; c < itemSize; c++) {
          dstAttribute.setComponent(index, c, 0);
        }
      }
      dstAttribute.needsUpdate = true;
      dstAttribute.addUpdateRange(vertexStart * itemSize, reservedVertexCount * itemSize);
    }
    if (hasIndex) {
      const indexStart = geometryInfo.indexStart;
      const reservedIndexCount = geometryInfo.reservedIndexCount;
      geometryInfo.indexCount = geometry.getIndex().count;
      for (let i = 0; i < srcIndex.count; i++) {
        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));
      }
      for (let i = srcIndex.count, l2 = reservedIndexCount; i < l2; i++) {
        dstIndex.setX(indexStart + i, vertexStart);
      }
      dstIndex.needsUpdate = true;
      dstIndex.addUpdateRange(indexStart, geometryInfo.reservedIndexCount);
    }
    geometryInfo.start = hasIndex ? geometryInfo.indexStart : geometryInfo.vertexStart;
    geometryInfo.count = hasIndex ? geometryInfo.indexCount : geometryInfo.vertexCount;
    geometryInfo.boundingBox = null;
    if (geometry.boundingBox !== null) {
      geometryInfo.boundingBox = geometry.boundingBox.clone();
    }
    geometryInfo.boundingSphere = null;
    if (geometry.boundingSphere !== null) {
      geometryInfo.boundingSphere = geometry.boundingSphere.clone();
    }
    this._visibilityChanged = true;
    return geometryId;
  }
  deleteGeometry(geometryId) {
    const geometryInfoList = this._geometryInfo;
    if (geometryId >= geometryInfoList.length || geometryInfoList[geometryId].active === false) {
      return this;
    }
    const instanceInfo = this._instanceInfo;
    for (let i = 0, l2 = instanceInfo.length; i < l2; i++) {
      if (instanceInfo[i].geometryIndex === geometryId) {
        this.deleteInstance(i);
      }
    }
    geometryInfoList[geometryId].active = false;
    this._availableGeometryIds.push(geometryId);
    this._visibilityChanged = true;
    return this;
  }
  deleteInstance(instanceId) {
    const instanceInfo = this._instanceInfo;
    if (instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
      return this;
    }
    instanceInfo[instanceId].active = false;
    this._availableInstanceIds.push(instanceId);
    this._visibilityChanged = true;
    return this;
  }
  optimize() {
    let nextVertexStart = 0;
    let nextIndexStart = 0;
    const geometryInfoList = this._geometryInfo;
    const indices = geometryInfoList.map((e, i) => i).sort((a, b) => {
      return geometryInfoList[a].vertexStart - geometryInfoList[b].vertexStart;
    });
    const geometry = this.geometry;
    for (let i = 0, l2 = geometryInfoList.length; i < l2; i++) {
      const index = indices[i];
      const geometryInfo = geometryInfoList[index];
      if (geometryInfo.active === false) {
        continue;
      }
      if (geometry.index !== null) {
        if (geometryInfo.indexStart !== nextIndexStart) {
          const { indexStart, vertexStart, reservedIndexCount } = geometryInfo;
          const index2 = geometry.index;
          const array = index2.array;
          const elementDelta = nextVertexStart - vertexStart;
          for (let j = indexStart; j < indexStart + reservedIndexCount; j++) {
            array[j] = array[j] + elementDelta;
          }
          index2.array.copyWithin(nextIndexStart, indexStart, indexStart + reservedIndexCount);
          index2.addUpdateRange(nextIndexStart, reservedIndexCount);
          geometryInfo.indexStart = nextIndexStart;
        }
        nextIndexStart += geometryInfo.reservedIndexCount;
      }
      if (geometryInfo.vertexStart !== nextVertexStart) {
        const { vertexStart, reservedVertexCount } = geometryInfo;
        const attributes = geometry.attributes;
        for (const key in attributes) {
          const attribute = attributes[key];
          const { array, itemSize } = attribute;
          array.copyWithin(nextVertexStart * itemSize, vertexStart * itemSize, (vertexStart + reservedVertexCount) * itemSize);
          attribute.addUpdateRange(nextVertexStart * itemSize, reservedVertexCount * itemSize);
        }
        geometryInfo.vertexStart = nextVertexStart;
      }
      nextVertexStart += geometryInfo.reservedVertexCount;
      geometryInfo.start = geometry.index ? geometryInfo.indexStart : geometryInfo.vertexStart;
      this._nextIndexStart = geometry.index ? geometryInfo.indexStart + geometryInfo.reservedIndexCount : 0;
      this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;
    }
    return this;
  }
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(geometryId, target) {
    if (geometryId >= this._geometryCount) {
      return null;
    }
    const geometry = this.geometry;
    const geometryInfo = this._geometryInfo[geometryId];
    if (geometryInfo.boundingBox === null) {
      const box = new Box3();
      const index = geometry.index;
      const position = geometry.attributes.position;
      for (let i = geometryInfo.start, l2 = geometryInfo.start + geometryInfo.count; i < l2; i++) {
        let iv = i;
        if (index) {
          iv = index.getX(iv);
        }
        box.expandByPoint(_vector$5.fromBufferAttribute(position, iv));
      }
      geometryInfo.boundingBox = box;
    }
    target.copy(geometryInfo.boundingBox);
    return target;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(geometryId, target) {
    if (geometryId >= this._geometryCount) {
      return null;
    }
    const geometry = this.geometry;
    const geometryInfo = this._geometryInfo[geometryId];
    if (geometryInfo.boundingSphere === null) {
      const sphere = new Sphere();
      this.getBoundingBoxAt(geometryId, _box$1);
      _box$1.getCenter(sphere.center);
      const index = geometry.index;
      const position = geometry.attributes.position;
      let maxRadiusSq = 0;
      for (let i = geometryInfo.start, l2 = geometryInfo.start + geometryInfo.count; i < l2; i++) {
        let iv = i;
        if (index) {
          iv = index.getX(iv);
        }
        _vector$5.fromBufferAttribute(position, iv);
        maxRadiusSq = Math.max(maxRadiusSq, sphere.center.distanceToSquared(_vector$5));
      }
      sphere.radius = Math.sqrt(maxRadiusSq);
      geometryInfo.boundingSphere = sphere;
    }
    target.copy(geometryInfo.boundingSphere);
    return target;
  }
  setMatrixAt(instanceId, matrix) {
    const instanceInfo = this._instanceInfo;
    const matricesTexture = this._matricesTexture;
    const matricesArray = this._matricesTexture.image.data;
    if (instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
      return this;
    }
    matrix.toArray(matricesArray, instanceId * 16);
    matricesTexture.needsUpdate = true;
    return this;
  }
  getMatrixAt(instanceId, matrix) {
    const instanceInfo = this._instanceInfo;
    const matricesArray = this._matricesTexture.image.data;
    if (instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
      return null;
    }
    return matrix.fromArray(matricesArray, instanceId * 16);
  }
  setColorAt(instanceId, color) {
    if (this._colorsTexture === null) {
      this._initColorsTexture();
    }
    const colorsTexture = this._colorsTexture;
    const colorsArray = this._colorsTexture.image.data;
    const instanceInfo = this._instanceInfo;
    if (instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
      return this;
    }
    color.toArray(colorsArray, instanceId * 4);
    colorsTexture.needsUpdate = true;
    return this;
  }
  getColorAt(instanceId, color) {
    const colorsArray = this._colorsTexture.image.data;
    const instanceInfo = this._instanceInfo;
    if (instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
      return null;
    }
    return color.fromArray(colorsArray, instanceId * 4);
  }
  setVisibleAt(instanceId, value) {
    const instanceInfo = this._instanceInfo;
    if (instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false || instanceInfo[instanceId].visible === value) {
      return this;
    }
    instanceInfo[instanceId].visible = value;
    this._visibilityChanged = true;
    return this;
  }
  getVisibleAt(instanceId) {
    const instanceInfo = this._instanceInfo;
    if (instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
      return false;
    }
    return instanceInfo[instanceId].visible;
  }
  setGeometryIdAt(instanceId, geometryId) {
    const instanceInfo = this._instanceInfo;
    const geometryInfoList = this._geometryInfo;
    if (instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
      return null;
    }
    if (geometryId >= geometryInfoList.length || geometryInfoList[geometryId].active === false) {
      return null;
    }
    instanceInfo[instanceId].geometryIndex = geometryId;
    return this;
  }
  getGeometryIdAt(instanceId) {
    const instanceInfo = this._instanceInfo;
    if (instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
      return -1;
    }
    return instanceInfo[instanceId].geometryIndex;
  }
  getGeometryRangeAt(geometryId, target = {}) {
    if (geometryId < 0 || geometryId >= this._geometryCount) {
      return null;
    }
    const geometryInfo = this._geometryInfo[geometryId];
    target.vertexStart = geometryInfo.vertexStart;
    target.vertexCount = geometryInfo.vertexCount;
    target.reservedVertexCount = geometryInfo.reservedVertexCount;
    target.indexStart = geometryInfo.indexStart;
    target.indexCount = geometryInfo.indexCount;
    target.reservedIndexCount = geometryInfo.reservedIndexCount;
    target.start = geometryInfo.start;
    target.count = geometryInfo.count;
    return target;
  }
  setInstanceCount(maxInstanceCount) {
    const availableInstanceIds = this._availableInstanceIds;
    const instanceInfo = this._instanceInfo;
    availableInstanceIds.sort(ascIdSort);
    while (availableInstanceIds[availableInstanceIds.length - 1] === instanceInfo.length) {
      instanceInfo.pop();
      availableInstanceIds.pop();
    }
    if (maxInstanceCount < instanceInfo.length) {
      throw new Error(`BatchedMesh: Instance ids outside the range ${maxInstanceCount} are being used. Cannot shrink instance count.`);
    }
    const multiDrawCounts = new Int32Array(maxInstanceCount);
    const multiDrawStarts = new Int32Array(maxInstanceCount);
    copyArrayContents(this._multiDrawCounts, multiDrawCounts);
    copyArrayContents(this._multiDrawStarts, multiDrawStarts);
    this._multiDrawCounts = multiDrawCounts;
    this._multiDrawStarts = multiDrawStarts;
    this._maxInstanceCount = maxInstanceCount;
    const indirectTexture = this._indirectTexture;
    const matricesTexture = this._matricesTexture;
    const colorsTexture = this._colorsTexture;
    indirectTexture.dispose();
    this._initIndirectTexture();
    copyArrayContents(indirectTexture.image.data, this._indirectTexture.image.data);
    matricesTexture.dispose();
    this._initMatricesTexture();
    copyArrayContents(matricesTexture.image.data, this._matricesTexture.image.data);
    if (colorsTexture) {
      colorsTexture.dispose();
      this._initColorsTexture();
      copyArrayContents(colorsTexture.image.data, this._colorsTexture.image.data);
    }
  }
  setGeometrySize(maxVertexCount, maxIndexCount) {
    const validRanges = [...this._geometryInfo].filter((info) => info.active);
    const requiredVertexLength = Math.max(...validRanges.map((range) => range.vertexStart + range.reservedVertexCount));
    if (requiredVertexLength > maxVertexCount) {
      throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);
    }
    if (this.geometry.index) {
      const requiredIndexLength = Math.max(...validRanges.map((range) => range.indexStart + range.reservedIndexCount));
      if (requiredIndexLength > maxIndexCount) {
        throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);
      }
    }
    const oldGeometry = this.geometry;
    oldGeometry.dispose();
    this._maxVertexCount = maxVertexCount;
    this._maxIndexCount = maxIndexCount;
    if (this._geometryInitialized) {
      this._geometryInitialized = false;
      this.geometry = new BufferGeometry();
      this._initializeGeometry(oldGeometry);
    }
    const geometry = this.geometry;
    if (oldGeometry.index) {
      copyArrayContents(oldGeometry.index.array, geometry.index.array);
    }
    for (const key in oldGeometry.attributes) {
      copyArrayContents(oldGeometry.attributes[key].array, geometry.attributes[key].array);
    }
  }
  raycast(raycaster, intersects2) {
    const instanceInfo = this._instanceInfo;
    const geometryInfoList = this._geometryInfo;
    const matrixWorld = this.matrixWorld;
    const batchGeometry = this.geometry;
    _mesh$2.material = this.material;
    _mesh$2.geometry.index = batchGeometry.index;
    _mesh$2.geometry.attributes = batchGeometry.attributes;
    if (_mesh$2.geometry.boundingBox === null) {
      _mesh$2.geometry.boundingBox = new Box3();
    }
    if (_mesh$2.geometry.boundingSphere === null) {
      _mesh$2.geometry.boundingSphere = new Sphere();
    }
    for (let i = 0, l2 = instanceInfo.length; i < l2; i++) {
      if (!instanceInfo[i].visible || !instanceInfo[i].active) {
        continue;
      }
      const geometryId = instanceInfo[i].geometryIndex;
      const geometryInfo = geometryInfoList[geometryId];
      _mesh$2.geometry.setDrawRange(geometryInfo.start, geometryInfo.count);
      this.getMatrixAt(i, _mesh$2.matrixWorld).premultiply(matrixWorld);
      this.getBoundingBoxAt(geometryId, _mesh$2.geometry.boundingBox);
      this.getBoundingSphereAt(geometryId, _mesh$2.geometry.boundingSphere);
      _mesh$2.raycast(raycaster, _batchIntersects$1);
      for (let j = 0, l3 = _batchIntersects$1.length; j < l3; j++) {
        const intersect2 = _batchIntersects$1[j];
        intersect2.object = this;
        intersect2.batchId = i;
        intersects2.push(intersect2);
      }
      _batchIntersects$1.length = 0;
    }
    _mesh$2.material = null;
    _mesh$2.geometry.index = null;
    _mesh$2.geometry.attributes = {};
    _mesh$2.geometry.setDrawRange(0, Infinity);
  }
  copy(source) {
    super.copy(source);
    this.geometry = source.geometry.clone();
    this.perObjectFrustumCulled = source.perObjectFrustumCulled;
    this.sortObjects = source.sortObjects;
    this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
    this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;
    this._geometryInfo = source._geometryInfo.map((info) => ({
      ...info,
      boundingBox: info.boundingBox !== null ? info.boundingBox.clone() : null,
      boundingSphere: info.boundingSphere !== null ? info.boundingSphere.clone() : null
    }));
    this._instanceInfo = source._instanceInfo.map((info) => ({ ...info }));
    this._maxInstanceCount = source._maxInstanceCount;
    this._maxVertexCount = source._maxVertexCount;
    this._maxIndexCount = source._maxIndexCount;
    this._geometryInitialized = source._geometryInitialized;
    this._geometryCount = source._geometryCount;
    this._multiDrawCounts = source._multiDrawCounts.slice();
    this._multiDrawStarts = source._multiDrawStarts.slice();
    this._matricesTexture = source._matricesTexture.clone();
    this._matricesTexture.image.data = this._matricesTexture.image.data.slice();
    if (this._colorsTexture !== null) {
      this._colorsTexture = source._colorsTexture.clone();
      this._colorsTexture.image.data = this._colorsTexture.image.data.slice();
    }
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this._matricesTexture.dispose();
    this._matricesTexture = null;
    this._indirectTexture.dispose();
    this._indirectTexture = null;
    if (this._colorsTexture !== null) {
      this._colorsTexture.dispose();
      this._colorsTexture = null;
    }
    return this;
  }
  onBeforeRender(renderer, scene, camera, geometry, material) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) {
      return;
    }
    const index = geometry.getIndex();
    const bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;
    const instanceInfo = this._instanceInfo;
    const multiDrawStarts = this._multiDrawStarts;
    const multiDrawCounts = this._multiDrawCounts;
    const geometryInfoList = this._geometryInfo;
    const perObjectFrustumCulled = this.perObjectFrustumCulled;
    const indirectTexture = this._indirectTexture;
    const indirectArray = indirectTexture.image.data;
    if (perObjectFrustumCulled) {
      _matrix$1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse).multiply(this.matrixWorld);
      _frustum.setFromProjectionMatrix(
        _matrix$1,
        renderer.coordinateSystem
      );
    }
    let multiDrawCount = 0;
    if (this.sortObjects) {
      _matrix$1.copy(this.matrixWorld).invert();
      _vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_matrix$1);
      _forward.set(0, 0, -1).transformDirection(camera.matrixWorld).transformDirection(_matrix$1);
      for (let i = 0, l2 = instanceInfo.length; i < l2; i++) {
        if (instanceInfo[i].visible && instanceInfo[i].active) {
          const geometryId = instanceInfo[i].geometryIndex;
          this.getMatrixAt(i, _matrix$1);
          this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
          let culled = false;
          if (perObjectFrustumCulled) {
            culled = !_frustum.intersectsSphere(_sphere$2);
          }
          if (!culled) {
            const geometryInfo = geometryInfoList[geometryId];
            const z = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward);
            _renderList.push(geometryInfo.start, geometryInfo.count, z, i);
          }
        }
      }
      const list = _renderList.list;
      const customSort = this.customSort;
      if (customSort === null) {
        list.sort(material.transparent ? sortTransparent : sortOpaque);
      } else {
        customSort.call(this, list, camera);
      }
      for (let i = 0, l2 = list.length; i < l2; i++) {
        const item = list[i];
        multiDrawStarts[multiDrawCount] = item.start * bytesPerElement;
        multiDrawCounts[multiDrawCount] = item.count;
        indirectArray[multiDrawCount] = item.index;
        multiDrawCount++;
      }
      _renderList.reset();
    } else {
      for (let i = 0, l2 = instanceInfo.length; i < l2; i++) {
        if (instanceInfo[i].visible && instanceInfo[i].active) {
          const geometryId = instanceInfo[i].geometryIndex;
          let culled = false;
          if (perObjectFrustumCulled) {
            this.getMatrixAt(i, _matrix$1);
            this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
            culled = !_frustum.intersectsSphere(_sphere$2);
          }
          if (!culled) {
            const geometryInfo = geometryInfoList[geometryId];
            multiDrawStarts[multiDrawCount] = geometryInfo.start * bytesPerElement;
            multiDrawCounts[multiDrawCount] = geometryInfo.count;
            indirectArray[multiDrawCount] = i;
            multiDrawCount++;
          }
        }
      }
    }
    indirectTexture.needsUpdate = true;
    this._multiDrawCount = multiDrawCount;
    this._visibilityChanged = false;
  }
  onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial) {
    this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial);
  }
}
class LineBasicMaterial extends Material {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.color = new Color(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
}
const _vStart = /* @__PURE__ */ new Vector3();
const _vEnd = /* @__PURE__ */ new Vector3();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
const _ray$1 = /* @__PURE__ */ new Ray$1();
const _sphere$1 = /* @__PURE__ */ new Sphere();
const _intersectPointOnRay = /* @__PURE__ */ new Vector3();
const _intersectPointOnSegment = /* @__PURE__ */ new Vector3();
class Line extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i = 1, l2 = positionAttribute.count; i < l2; i++) {
        _vStart.fromBufferAttribute(positionAttribute, i - 1);
        _vEnd.fromBufferAttribute(positionAttribute, i);
        lineDistances[i] = lineDistances[i - 1];
        lineDistances[i] += _vStart.distanceTo(_vEnd);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const step = this.isLineSegments ? 2 : 1;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i = start, l2 = end - 1; i < l2; i += step) {
        const a = index.getX(i);
        const b = index.getX(i + 1);
        const intersect2 = checkIntersection$2(this, raycaster, _ray$1, localThresholdSq, a, b);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
      if (this.isLineLoop) {
        const a = index.getX(end - 1);
        const b = index.getX(start);
        const intersect2 = checkIntersection$2(this, raycaster, _ray$1, localThresholdSq, a, b);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i = start, l2 = end - 1; i < l2; i += step) {
        const intersect2 = checkIntersection$2(this, raycaster, _ray$1, localThresholdSq, i, i + 1);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
      if (this.isLineLoop) {
        const intersect2 = checkIntersection$2(this, raycaster, _ray$1, localThresholdSq, end - 1, start);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
}
function checkIntersection$2(object, raycaster, ray2, thresholdSq, a, b) {
  const positionAttribute = object.geometry.attributes.position;
  _vStart.fromBufferAttribute(positionAttribute, a);
  _vEnd.fromBufferAttribute(positionAttribute, b);
  const distSq = ray2.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
  if (distSq > thresholdSq) return;
  _intersectPointOnRay.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
  if (distance < raycaster.near || distance > raycaster.far) return;
  return {
    distance,
    // What do we want? intersection point on the ray or on the segment??
    // point: raycaster.ray.at( distance ),
    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
    index: a,
    face: null,
    faceIndex: null,
    barycoord: null,
    object
  };
}
const _start = /* @__PURE__ */ new Vector3();
const _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineSegments = true;
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [];
      for (let i = 0, l2 = positionAttribute.count; i < l2; i += 2) {
        _start.fromBufferAttribute(positionAttribute, i);
        _end.fromBufferAttribute(positionAttribute, i + 1);
        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
        lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
}
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineLoop = true;
    this.type = "LineLoop";
  }
}
class PointsMaterial extends Material {
  static get type() {
    return "PointsMaterial";
  }
  constructor(parameters) {
    super();
    this.isPointsMaterial = true;
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
}
const _inverseMatrix = /* @__PURE__ */ new Matrix4();
const _ray = /* @__PURE__ */ new Ray$1();
const _sphere = /* @__PURE__ */ new Sphere();
const _position$2 = /* @__PURE__ */ new Vector3();
class Points extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.isPoints = true;
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false) return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i = start, il = end; i < il; i++) {
        const a = index.getX(i);
        _position$2.fromBufferAttribute(positionAttribute, a);
        testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i = start, l2 = end; i < l2; i++) {
        _position$2.fromBufferAttribute(positionAttribute, i);
        testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
}
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      faceIndex: null,
      barycoord: null,
      object
    });
  }
}
class CanvasTexture extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isCanvasTexture = true;
    this.needsUpdate = true;
  }
}
class Curve {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  }
  // Get sequence of points using getPoint( t )
  getPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  }
  // Get total curve arc length
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i + segmentFraction) / (il - 1);
    return t;
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t, optionalTarget) {
    const delta = 1e-4;
    let t1 = t - delta;
    let t2 = t + delta;
    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
}
class EllipseCurve extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.isEllipseCurve = true;
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0) deltaAngle += twoPi;
    while (deltaAngle > twoPi) deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
}
class ArcCurve extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.isArcCurve = true;
    this.type = "ArcCurve";
  }
}
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}
const tmp = /* @__PURE__ */ new Vector3();
const px = /* @__PURE__ */ new CubicPoly();
const py = /* @__PURE__ */ new CubicPoly();
const pz = /* @__PURE__ */ new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.isCatmullRomCurve3 = true;
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l2 = points.length;
    const p = (l2 - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
    } else if (weight === 0 && intPoint === l2 - 1) {
      intPoint = l2 - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l2];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l2];
    const p2 = points[(intPoint + 1) % l2];
    if (this.closed || intPoint + 2 < l2) {
      p3 = points[(intPoint + 2) % l2];
    } else {
      tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
      if (dt1 < 1e-4) dt1 = 1;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(
      px.calc(weight),
      py.calc(weight),
      pz.calc(weight)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l2 = source.points.length; i < l2; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l2 = this.points.length; i < l2; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l2 = json.points.length; i < l2; i++) {
      const point = json.points[i];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
}
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
class CubicBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.isCubicBezierCurve = true;
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
class CubicBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.isCubicBezierCurve3 = true;
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
      CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
class LineCurve extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.isLineCurve = true;
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget = new Vector2()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class LineCurve3 extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.isLineCurve3 = true;
    this.type = "LineCurve3";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget = new Vector3()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.isQuadraticBezierCurve = true;
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.isQuadraticBezierCurve3 = true;
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y),
      QuadraticBezier(t, v0.z, v1.z, v2.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class SplineCurve extends Curve {
  constructor(points = []) {
    super();
    this.isSplineCurve = true;
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(
      CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
      CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l2 = source.points.length; i < l2; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l2 = this.points.length; i < l2; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l2 = json.points.length; i < l2; i++) {
      const point = json.points[i];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
}
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
class CurvePath extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      const lineType = startPoint.isVector2 === true ? "LineCurve" : "LineCurve3";
      this.curves.push(new Curves[lineType](endPoint, startPoint));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t, optionalTarget) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u, optionalTarget);
      }
      i++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i = 0, l2 = this.curves.length; i < l2; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i = 0, l2 = source.curves.length; i < l2; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i = 0, l2 = this.curves.length; i < l2; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i = 0, l2 = json.curves.length; i < l2; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i = 1, l2 = points.length; i < l2; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
    return this;
  }
  moveTo(x, y) {
    this.currentPoint.set(x, y);
    return this;
  }
  lineTo(x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCPx, aCPy),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCP1x, aCP1y),
      new Vector2(aCP2x, aCP2y),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(
      aX + x0,
      aY + y0,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise
    );
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = clamp(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const initNormals = [];
    const normals = [];
    const inverseSegments = 1 / segments;
    const vertex2 = new Vector3();
    const uv = new Vector2();
    const normal = new Vector3();
    const curNormal = new Vector3();
    const prevNormal = new Vector3();
    let dx = 0;
    let dy = 0;
    for (let j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;
        case points.length - 1:
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;
        default:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    }
    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j = 0; j <= points.length - 1; j++) {
        vertex2.x = points[j].x * sin;
        vertex2.y = points[j].y;
        vertex2.z = points[j].x * cos;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
        const x = initNormals[3 * j + 0] * sin;
        const y = initNormals[3 * j + 1];
        const z = initNormals[3 * j + 0] * cos;
        normals.push(x, y, z);
      }
    }
    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length;
        const a = base;
        const b = base + points.length;
        const c = base + points.length + 1;
        const d = base + 1;
        indices.push(a, b, d);
        indices.push(c, d, b);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }
}
class CapsuleGeometry extends LatheGeometry {
  constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
    const path = new Path();
    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
    super(path.getPoints(capSegments), radialSegments);
    this.type = "CapsuleGeometry";
    this.parameters = {
      radius,
      length,
      capSegments,
      radialSegments
    };
  }
  static fromJSON(data) {
    return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
  }
}
class CircleGeometry extends BufferGeometry {
  constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s2 = 0, i = 3; s2 <= segments; s2++, i += 3) {
      const segment = thetaStart + s2 / segments * thetaLength;
      vertex2.x = radius * Math.cos(segment);
      vertex2.y = radius * Math.sin(segment);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments;
        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex2.x = radius * sinTheta;
          vertex2.y = -v * height + halfHeight;
          vertex2.z = radius * cosTheta;
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1];
          if (radiusTop > 0 || y !== 0) {
            indices.push(a, b, d);
            groupCount += 3;
          }
          if (radiusBottom > 0 || y !== heightSegments - 1) {
            indices.push(b, c, d);
            groupCount += 3;
          }
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex2.x = radius * sinTheta;
        vertex2.y = halfHeight * sign2;
        vertex2.z = radius * cosTheta;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;
        if (top === true) {
          indices.push(i, i + 1, c);
        } else {
          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  static fromJSON(data) {
    return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      for (let i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);
        subdivideFace(a, b, c, detail2);
      }
    }
    function subdivideFace(a, b, c, detail2) {
      const cols = detail2 + 1;
      const v = [];
      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex2 = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        vertex2.normalize().multiplyScalar(radius2);
        vertexBuffer[i + 0] = vertex2.x;
        vertexBuffer[i + 1] = vertex2.y;
        vertexBuffer[i + 2] = vertex2.z;
      }
    }
    function generateUVs() {
      const vertex2 = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        const u = azimuth(vertex2) / 2 / Math.PI + 0.5;
        const v = inclination(vertex2) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i = 0; i < uvBuffer.length; i += 6) {
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex2) {
      vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
    }
    function getVertexByIndex(index, vertex2) {
      const stride = index * 3;
      vertex2.x = vertices[stride + 0];
      vertex2.y = vertices[stride + 1];
      vertex2.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      // (1/, , 0)
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      0,
      // (, 0, 1/)
      -t,
      0,
      -r,
      t,
      0,
      -r,
      -t,
      0,
      r,
      t,
      0,
      r
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new DodecahedronGeometry(data.radius, data.detail);
  }
}
const _v0 = /* @__PURE__ */ new Vector3();
const _v1$1 = /* @__PURE__ */ new Vector3();
const _normal = /* @__PURE__ */ new Vector3();
const _triangle = /* @__PURE__ */ new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      geometry,
      thresholdAngle
    };
    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute("position");
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ["a", "b", "c"];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];
      for (let i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i);
          indexArr[1] = indexAttr.getX(i + 1);
          indexArr[2] = indexAttr.getX(i + 2);
        } else {
          indexArr[0] = i;
          indexArr[1] = i + 1;
          indexArr[2] = i + 2;
        }
        const { a, b, c } = _triangle;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);
        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        }
        for (let j = 0; j < 3; j++) {
          const jNext = (j + 1) % 3;
          const vecHash0 = hashes[j];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      }
      for (const key in edgeData) {
        if (edgeData[key]) {
          const { index0, index1 } = edgeData[key];
          _v0.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
}
class Shape extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i = 0, l2 = this.holes.length; i < l2; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i = 0, l2 = source.holes.length; i < l2; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i = 0, l2 = this.holes.length; i < l2; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i = 0, l2 = json.holes.length; i < l2; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
}
const Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p = c.next;
  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode, qx = -Infinity, m;
  const hx = hole.x, hy = hole.y;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx) return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  const stop = m, mx = m.x, my = m.y;
  let tanMin = Infinity, tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;
        else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  let p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) && (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) && (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a, inside = false;
  const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
class ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n = contour.length;
    let a = 0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
}
function removeDupEndPts(points) {
  const l2 = points.length;
  if (l2 > 2 && points[l2 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i = 0, l2 = shapes.length; i < l2; i++) {
      const shape = shapes[i];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      const depth = options.depth !== void 0 ? options.depth : 1;
      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
        return pt.clone().addScaledVector(vec, size);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];
        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il) j = 0;
          if (k === il) k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, -z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      for (let s2 = 1; s2 <= steps; s2++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s2);
          } else {
            normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s2]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, depth + z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i = contour2.length;
        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0) k = contour2.length - 1;
          for (let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++) {
            const slen1 = vlen * s2;
            const slen2 = vlen * (s2 + 1);
            const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }
      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }
      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON$1(shapes, options, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new ExtrudeGeometry(geometryShapes, data.options);
  }
}
const WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l2 = shapes.length; i < l2; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  data.options = Object.assign({}, options);
  if (options.extrudePath !== void 0) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new IcosahedronGeometry(data.radius, data.detail);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new OctahedronGeometry(data.radius, data.detail);
  }
}
class RingGeometry extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex2 = new Vector3();
    const uv = new Vector2();
    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        const segment = thetaStart + i / thetaSegments * thetaLength;
        vertex2.x = radius * Math.cos(segment);
        vertex2.y = radius * Math.sin(segment);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, 0, 1);
        uv.x = (vertex2.x / outerRadius + 1) / 2;
        uv.y = (vertex2.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);
      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d = segment + 1;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i = 0, l2 = shapeHoles.length; i < l2; i++) {
        const shapeHole = shapeHoles[i];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i = 0, l2 = shapeHoles.length; i < l2; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i = 0, l2 = shapeVertices.length; i < l2; i++) {
        const vertex2 = shapeVertices[i];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i = 0, l2 = faces.length; i < l2; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l2 = shapes.length; i < l2; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new TetrahedronGeometry(data.radius, data.detail);
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3();
    const vertex2 = new Vector3();
    const normal = new Vector3();
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex2.z = tube * Math.sin(v);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex2, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p,
      q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B = new Vector3();
    const T = new Vector3();
    const N = new Vector3();
    for (let i = 0; i <= tubularSegments; ++i) {
      const u = i / tubularSegments * p * Math.PI * 2;
      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T);
      B.normalize();
      N.normalize();
      for (let j = 0; j <= radialSegments; ++j) {
        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v);
        vertex2.x = P1.x + (cx * N.x + cy * B.x);
        vertex2.y = P1.y + (cx * N.y + cy * B.y);
        vertex2.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.subVectors(vertex2, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u, p2, q2, radius2, position) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q2 / p2 * u;
      const cs = Math.cos(quOverP);
      position.x = radius2 * (2 + cs) * 0.5 * cu;
      position.y = radius2 * (2 + cs) * su * 0.5;
      position.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P = new Vector3();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i) {
      P = path.getPointAt(i / tubularSegments, P);
      const N = frames.normals[i];
      const B = frames.binormals[i];
      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v);
        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex2.x = P.x + radius * normal.x;
        vertex2.y = P.y + radius * normal.y;
        vertex2.z = P.z + radius * normal.z;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
      }
    }
    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }
    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }
  static fromJSON(data) {
    return new TubeGeometry(
      new Curves[data.path.type]().fromJSON(data.path),
      data.tubularSegments,
      data.radius,
      data.radialSegments,
      data.closed
    );
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(geometry = null) {
    super();
    this.type = "WireframeGeometry";
    this.parameters = {
      geometry
    };
    if (geometry !== null) {
      const vertices = [];
      const edges = /* @__PURE__ */ new Set();
      const start = new Vector3();
      const end = new Vector3();
      if (geometry.index !== null) {
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;
        if (groups.length === 0) {
          groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group = groups[o];
          const groupStart = group.start;
          const groupCount = group.count;
          for (let i = groupStart, l2 = groupStart + groupCount; i < l2; i += 3) {
            for (let j = 0; j < 3; j++) {
              const index1 = indices.getX(i + j);
              const index2 = indices.getX(i + (j + 1) % 3);
              start.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);
              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        const position = geometry.attributes.position;
        for (let i = 0, l2 = position.count / 3; i < l2; i++) {
          for (let j = 0; j < 3; j++) {
            const index1 = 3 * i + j;
            const index2 = 3 * i + (j + 1) % 3;
            start.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);
            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
}
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry,
  CapsuleGeometry,
  CircleGeometry,
  ConeGeometry,
  CylinderGeometry,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  IcosahedronGeometry,
  LatheGeometry,
  OctahedronGeometry,
  PlaneGeometry,
  PolyhedronGeometry,
  RingGeometry,
  ShapeGeometry,
  SphereGeometry,
  TetrahedronGeometry,
  TorusGeometry,
  TorusKnotGeometry,
  TubeGeometry,
  WireframeGeometry
});
class ShadowMaterial extends Material {
  static get type() {
    return "ShadowMaterial";
  }
  constructor(parameters) {
    super();
    this.isShadowMaterial = true;
    this.color = new Color(0);
    this.transparent = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.fog = source.fog;
    return this;
  }
}
class RawShaderMaterial extends ShaderMaterial {
  static get type() {
    return "RawShaderMaterial";
  }
  constructor(parameters) {
    super(parameters);
    this.isRawShaderMaterial = true;
  }
}
class MeshStandardMaterial extends Material {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshStandardMaterial = true;
    this.defines = { "STANDARD": "" };
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.envMapIntensity = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.envMapIntensity = source.envMapIntensity;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  static get type() {
    return "MeshPhysicalMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshPhysicalMaterial = true;
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.anisotropyRotation = 0;
    this.anisotropyMap = null;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.iridescenceMap = null;
    this.iridescenceIOR = 1.3;
    this.iridescenceThicknessRange = [100, 400];
    this.iridescenceThicknessMap = null;
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = Infinity;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._anisotropy = 0;
    this._clearcoat = 0;
    this._dispersion = 0;
    this._iridescence = 0;
    this._sheen = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(value) {
    if (this._anisotropy > 0 !== value > 0) {
      this.version++;
    }
    this._anisotropy = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(value) {
    if (this._iridescence > 0 !== value > 0) {
      this.version++;
    }
    this._iridescence = value;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(value) {
    if (this._dispersion > 0 !== value > 0) {
      this.version++;
    }
    this._dispersion = value;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.anisotropy = source.anisotropy;
    this.anisotropyRotation = source.anisotropyRotation;
    this.anisotropyMap = source.anisotropyMap;
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.dispersion = source.dispersion;
    this.ior = source.ior;
    this.iridescence = source.iridescence;
    this.iridescenceMap = source.iridescenceMap;
    this.iridescenceIOR = source.iridescenceIOR;
    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
    this.iridescenceThicknessMap = source.iridescenceThicknessMap;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
}
class MeshPhongMaterial extends Material {
  static get type() {
    return "MeshPhongMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshPhongMaterial = true;
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshToonMaterial extends Material {
  static get type() {
    return "MeshToonMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshToonMaterial = true;
    this.defines = { "TOON": "" };
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
class MeshNormalMaterial extends Material {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshNormalMaterial = true;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
}
class MeshLambertMaterial extends Material {
  static get type() {
    return "MeshLambertMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshLambertMaterial = true;
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshMatcapMaterial extends Material {
  static get type() {
    return "MeshMatcapMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshMatcapMaterial = true;
    this.defines = { "MATCAP": "" };
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "MATCAP": "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class LineDashedMaterial extends LineBasicMaterial {
  static get type() {
    return "LineDashedMaterial";
  }
  constructor(parameters) {
    super();
    this.isLineDashedMaterial = true;
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
}
function convertArray(array, type, forceClone) {
  if (!array || // let 'undefined' and 'null' pass
  !forceClone && array.constructor === type) return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
}
function isTypedArray(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
function getKeyframeOrder(times) {
  function compareTime(i, j) {
    return times[i] - times[j];
  }
  const n = times.length;
  const result = new Array(n);
  for (let i = 0; i !== n; ++i) result[i] = i;
  result.sort(compareTime);
  return result;
}
function sortedArray(values, stride, order) {
  const nValues = values.length;
  const result = new values.constructor(nValues);
  for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
    const srcOffset = order[i] * stride;
    for (let j = 0; j !== stride; ++j) {
      result[dstOffset++] = values[srcOffset + j];
    }
  }
  return result;
}
function flattenJSON(jsonKeys, times, values, valuePropertyName) {
  let i = 1, key = jsonKeys[0];
  while (key !== void 0 && key[valuePropertyName] === void 0) {
    key = jsonKeys[i++];
  }
  if (key === void 0) return;
  let value = key[valuePropertyName];
  if (value === void 0) return;
  if (Array.isArray(value)) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push.apply(values, value);
      }
      key = jsonKeys[i++];
    } while (key !== void 0);
  } else if (value.toArray !== void 0) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        value.toArray(values, values.length);
      }
      key = jsonKeys[i++];
    } while (key !== void 0);
  } else {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push(value);
      }
      key = jsonKeys[i++];
    } while (key !== void 0);
  }
}
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan: if (!(t < t1)) {
            for (let giveUpAt = i1 + 2; ; ) {
              if (t1 === void 0) {
                if (t < t0) break forward_scan;
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.copySampleValue_(i1 - 1);
              }
              if (i1 === giveUpAt) break;
              t0 = t1;
              t1 = pp[++i1];
              if (t < t1) {
                break seek;
              }
            }
            right = pp.length;
            break linear_scan;
          }
          if (!(t >= t0)) {
            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i1 === giveUpAt) break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.copySampleValue_(i1 - 1);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;
    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
}
class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": convertArray(track.times, Array),
        "values": convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = times.slice(from, to);
      this.values = this.values.slice(from * stride, to * stride);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1];
      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = times.slice(0, writeIndex);
      this.values = values.slice(0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = this.times.slice();
    const values = this.values.slice();
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(name, times, values) {
    super(name, times, values);
  }
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(name, times, values) {
    super(name, times, values);
  }
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(name = "", duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push(
        (i + numMorphTargets - 1) % numMorphTargets,
        i,
        (i + 1) % numMorphTargets
      );
      values.push(0, 1, 0);
      const order = getKeyframeOrder(times);
      times = sortedArray(times, 1, order);
      values = sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i].name + "]",
          times,
          values
        ).scale(1 / fps)
      );
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  // parse the animation.hierarchy format
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0) continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k;
        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * fps;
      } else {
        const boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }
    return valid;
  }
  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false) return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false) return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i = 0, l2 = handlers.length; i < l2; i += 2) {
        const regex = handlers[i];
        const loader = handlers[i + 1];
        if (regex.global) regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
}
const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
}
class FileLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad) onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
          return response;
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        const stream = new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i = 0, il = callbacks.length; i < il; i++) {
                    const callback = callbacks[i];
                    if (callback.onProgress) callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              }, (e) => {
                controller.error(e);
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
      }
    }).then((response) => {
      switch (responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, mimeType);
          });
        case "json":
          return response.json();
        default:
          if (mimeType === void 0) {
            return response.text();
          } else {
            const re = /charset="?([^;"\s]*)"?/i;
            const exec = re.exec(mimeType);
            const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
            const decoder = new TextDecoder(label);
            return response.arrayBuffer().then((ab) => decoder.decode(ab));
          }
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i = 0, il = callbacks.length; i < il; i++) {
        const callback = callbacks[i];
        if (callback.onLoad) callback.onLoad(data);
      }
    }).catch((err) => {
      const callbacks = loading[url];
      if (callbacks === void 0) {
        this.manager.itemError(url);
        throw err;
      }
      delete loading[url];
      for (let i = 0, il = callbacks.length; i < il; i++) {
        const callback = callbacks[i];
        if (callback.onError) callback.onError(err);
      }
      this.manager.itemError(url);
    }).finally(() => {
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
}
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
}
class Light extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0) data.object.distance = this.distance;
    if (this.angle !== void 0) data.object.angle = this.angle;
    if (this.decay !== void 0) data.object.decay = this.decay;
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
    if (this.target !== void 0) data.object.target = this.target.uuid;
    return data;
  }
}
class HemisphereLight extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.isHemisphereLight = true;
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.groundColor.copy(source.groundColor);
    return this;
  }
}
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.intensity = 1;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    );
    shadowMatrix.multiply(_projScreenMatrix$1);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.intensity = source.intensity;
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.intensity !== 1) object.intensity = this.intensity;
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.isSpotLightShadow = true;
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
class SpotLight extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
    super(color, intensity);
    this.isSpotLight = true;
    this.type = "SpotLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.map = null;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this.isPointLightShadow = true;
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 2) {
    super(color, intensity);
    this.isPointLight = true;
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
}
class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
class AmbientLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
}
class RectAreaLight extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.isRectAreaLight = true;
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
}
class SphericalHarmonics3 {
  constructor() {
    this.isSphericalHarmonics3 = true;
    this.coefficients = [];
    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }
    return this;
  }
  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(normal, target) {
    const x = normal.x, y = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x);
    target.addScaledVector(coeff[4], 1.092548 * (x * y));
    target.addScaledVector(coeff[5], 1.092548 * (y * z));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(normal, target) {
    const x = normal.x, y = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
    return target;
  }
  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }
    return this;
  }
  addScaledSH(sh, s2) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s2);
    }
    return this;
  }
  scale(s2) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s2);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }
    return array;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(normal, shBasis) {
    const x = normal.x, y = normal.y, z = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x;
    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }
}
class LightProbe extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.isLightProbe = true;
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
}
class MaterialLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const textures = this.textures;
    function getTexture(name) {
      if (textures[name] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name);
      }
      return textures[name];
    }
    const material = this.createMaterialFromType(json.type);
    if (json.uuid !== void 0) material.uuid = json.uuid;
    if (json.name !== void 0) material.name = json.name;
    if (json.color !== void 0 && material.color !== void 0) material.color.setHex(json.color);
    if (json.roughness !== void 0) material.roughness = json.roughness;
    if (json.metalness !== void 0) material.metalness = json.metalness;
    if (json.sheen !== void 0) material.sheen = json.sheen;
    if (json.sheenColor !== void 0) material.sheenColor = new Color().setHex(json.sheenColor);
    if (json.sheenRoughness !== void 0) material.sheenRoughness = json.sheenRoughness;
    if (json.emissive !== void 0 && material.emissive !== void 0) material.emissive.setHex(json.emissive);
    if (json.specular !== void 0 && material.specular !== void 0) material.specular.setHex(json.specular);
    if (json.specularIntensity !== void 0) material.specularIntensity = json.specularIntensity;
    if (json.specularColor !== void 0 && material.specularColor !== void 0) material.specularColor.setHex(json.specularColor);
    if (json.shininess !== void 0) material.shininess = json.shininess;
    if (json.clearcoat !== void 0) material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== void 0) material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.dispersion !== void 0) material.dispersion = json.dispersion;
    if (json.iridescence !== void 0) material.iridescence = json.iridescence;
    if (json.iridescenceIOR !== void 0) material.iridescenceIOR = json.iridescenceIOR;
    if (json.iridescenceThicknessRange !== void 0) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
    if (json.transmission !== void 0) material.transmission = json.transmission;
    if (json.thickness !== void 0) material.thickness = json.thickness;
    if (json.attenuationDistance !== void 0) material.attenuationDistance = json.attenuationDistance;
    if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0) material.attenuationColor.setHex(json.attenuationColor);
    if (json.anisotropy !== void 0) material.anisotropy = json.anisotropy;
    if (json.anisotropyRotation !== void 0) material.anisotropyRotation = json.anisotropyRotation;
    if (json.fog !== void 0) material.fog = json.fog;
    if (json.flatShading !== void 0) material.flatShading = json.flatShading;
    if (json.blending !== void 0) material.blending = json.blending;
    if (json.combine !== void 0) material.combine = json.combine;
    if (json.side !== void 0) material.side = json.side;
    if (json.shadowSide !== void 0) material.shadowSide = json.shadowSide;
    if (json.opacity !== void 0) material.opacity = json.opacity;
    if (json.transparent !== void 0) material.transparent = json.transparent;
    if (json.alphaTest !== void 0) material.alphaTest = json.alphaTest;
    if (json.alphaHash !== void 0) material.alphaHash = json.alphaHash;
    if (json.depthFunc !== void 0) material.depthFunc = json.depthFunc;
    if (json.depthTest !== void 0) material.depthTest = json.depthTest;
    if (json.depthWrite !== void 0) material.depthWrite = json.depthWrite;
    if (json.colorWrite !== void 0) material.colorWrite = json.colorWrite;
    if (json.blendSrc !== void 0) material.blendSrc = json.blendSrc;
    if (json.blendDst !== void 0) material.blendDst = json.blendDst;
    if (json.blendEquation !== void 0) material.blendEquation = json.blendEquation;
    if (json.blendSrcAlpha !== void 0) material.blendSrcAlpha = json.blendSrcAlpha;
    if (json.blendDstAlpha !== void 0) material.blendDstAlpha = json.blendDstAlpha;
    if (json.blendEquationAlpha !== void 0) material.blendEquationAlpha = json.blendEquationAlpha;
    if (json.blendColor !== void 0 && material.blendColor !== void 0) material.blendColor.setHex(json.blendColor);
    if (json.blendAlpha !== void 0) material.blendAlpha = json.blendAlpha;
    if (json.stencilWriteMask !== void 0) material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== void 0) material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== void 0) material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== void 0) material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== void 0) material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== void 0) material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== void 0) material.stencilZPass = json.stencilZPass;
    if (json.stencilWrite !== void 0) material.stencilWrite = json.stencilWrite;
    if (json.wireframe !== void 0) material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== void 0) material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== void 0) material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== void 0) material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== void 0) material.rotation = json.rotation;
    if (json.linewidth !== void 0) material.linewidth = json.linewidth;
    if (json.dashSize !== void 0) material.dashSize = json.dashSize;
    if (json.gapSize !== void 0) material.gapSize = json.gapSize;
    if (json.scale !== void 0) material.scale = json.scale;
    if (json.polygonOffset !== void 0) material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== void 0) material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== void 0) material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.dithering !== void 0) material.dithering = json.dithering;
    if (json.alphaToCoverage !== void 0) material.alphaToCoverage = json.alphaToCoverage;
    if (json.premultipliedAlpha !== void 0) material.premultipliedAlpha = json.premultipliedAlpha;
    if (json.forceSinglePass !== void 0) material.forceSinglePass = json.forceSinglePass;
    if (json.visible !== void 0) material.visible = json.visible;
    if (json.toneMapped !== void 0) material.toneMapped = json.toneMapped;
    if (json.userData !== void 0) material.userData = json.userData;
    if (json.vertexColors !== void 0) {
      if (typeof json.vertexColors === "number") {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    }
    if (json.uniforms !== void 0) {
      for (const name in json.uniforms) {
        const uniform = json.uniforms[name];
        material.uniforms[name] = {};
        switch (uniform.type) {
          case "t":
            material.uniforms[name].value = getTexture(uniform.value);
            break;
          case "c":
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;
          case "v2":
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;
          case "v3":
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;
          case "v4":
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;
          case "m3":
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
            break;
          case "m4":
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;
          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }
    if (json.defines !== void 0) material.defines = json.defines;
    if (json.vertexShader !== void 0) material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== void 0) material.fragmentShader = json.fragmentShader;
    if (json.glslVersion !== void 0) material.glslVersion = json.glslVersion;
    if (json.extensions !== void 0) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    }
    if (json.lights !== void 0) material.lights = json.lights;
    if (json.clipping !== void 0) material.clipping = json.clipping;
    if (json.size !== void 0) material.size = json.size;
    if (json.sizeAttenuation !== void 0) material.sizeAttenuation = json.sizeAttenuation;
    if (json.map !== void 0) material.map = getTexture(json.map);
    if (json.matcap !== void 0) material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== void 0) material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== void 0) material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== void 0) material.bumpScale = json.bumpScale;
    if (json.normalMap !== void 0) material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== void 0) material.normalMapType = json.normalMapType;
    if (json.normalScale !== void 0) {
      let normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json.displacementMap !== void 0) material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== void 0) material.displacementScale = json.displacementScale;
    if (json.displacementBias !== void 0) material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== void 0) material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== void 0) material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== void 0) material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== void 0) material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== void 0) material.specularMap = getTexture(json.specularMap);
    if (json.specularIntensityMap !== void 0) material.specularIntensityMap = getTexture(json.specularIntensityMap);
    if (json.specularColorMap !== void 0) material.specularColorMap = getTexture(json.specularColorMap);
    if (json.envMap !== void 0) material.envMap = getTexture(json.envMap);
    if (json.envMapRotation !== void 0) material.envMapRotation.fromArray(json.envMapRotation);
    if (json.envMapIntensity !== void 0) material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== void 0) material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== void 0) material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== void 0) material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== void 0) material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== void 0) material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== void 0) material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== void 0) material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== void 0) material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== void 0) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== void 0) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== void 0) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
    if (json.iridescenceMap !== void 0) material.iridescenceMap = getTexture(json.iridescenceMap);
    if (json.iridescenceThicknessMap !== void 0) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
    if (json.transmissionMap !== void 0) material.transmissionMap = getTexture(json.transmissionMap);
    if (json.thicknessMap !== void 0) material.thicknessMap = getTexture(json.thicknessMap);
    if (json.anisotropyMap !== void 0) material.anisotropyMap = getTexture(json.anisotropyMap);
    if (json.sheenColorMap !== void 0) material.sheenColorMap = getTexture(json.sheenColorMap);
    if (json.sheenRoughnessMap !== void 0) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
    return material;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
  createMaterialFromType(type) {
    return MaterialLoader.createMaterialFromType(type);
  }
  static createMaterialFromType(type) {
    const materialLib = {
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material
    };
    return new materialLib[type]();
  }
}
class LoaderUtils {
  static decodeText(array) {
    console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.");
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s2 = "";
    for (let i = 0, il = array.length; i < il; i++) {
      s2 += String.fromCharCode(array[i]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e) {
      return s2;
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1) return "./";
    return url.slice(0, index + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "") return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url)) return url;
    if (/^data:.*,.*$/i.test(url)) return url;
    if (/^blob:.*$/i.test(url)) return url;
    return path + url;
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super();
    this.isInstancedBufferGeometry = true;
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
}
class BufferGeometryLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};
    function getInterleavedBuffer(json2, uuid) {
      if (interleavedBufferMap[uuid] !== void 0) return interleavedBufferMap[uuid];
      const interleavedBuffers = json2.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
      const array = getTypedArray(interleavedBuffer.type, buffer);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }
    function getArrayBuffer(json2, uuid) {
      if (arrayBufferMap[uuid] !== void 0) return arrayBufferMap[uuid];
      const arrayBuffers = json2.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }
    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index = json.data.index;
    if (index !== void 0) {
      const typedArray = getTypedArray(index.type, index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }
    const attributes = json.data.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute;
      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }
      if (attribute.name !== void 0) bufferAttribute.name = attribute.name;
      if (attribute.usage !== void 0) bufferAttribute.setUsage(attribute.usage);
      geometry.setAttribute(key, bufferAttribute);
    }
    const morphAttributes = json.data.morphAttributes;
    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0) bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }
        geometry.morphAttributes[key] = array;
      }
    }
    const morphTargetsRelative = json.data.morphTargetsRelative;
    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }
    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups !== void 0) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    const boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== void 0) {
      const center = new Vector3();
      if (boundingSphere.center !== void 0) {
        center.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }
    if (json.name) geometry.name = json.name;
    if (json.userData) geometry.userData = json.userData;
    return geometry;
  }
}
class ObjectLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      let json = null;
      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== void 0) onError(error);
        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
        return;
      }
      const metadata = json.metadata;
      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
        if (onError !== void 0) onError(new Error("THREE.ObjectLoader: Can't load " + url));
        console.error("THREE.ObjectLoader: Can't load " + url);
        return;
      }
      scope.parse(json, onLoad);
    }, onProgress, onError);
  }
  async loadAsync(url, onProgress) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    const text = await loader.loadAsync(url, onProgress);
    const json = JSON.parse(text);
    const metadata = json.metadata;
    if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
      throw new Error("THREE.ObjectLoader: Can't load " + url);
    }
    return await scope.parseAsync(json);
  }
  parse(json, onLoad) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function() {
      if (onLoad !== void 0) onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, textures, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    this.bindLightTargets(object);
    if (onLoad !== void 0) {
      let hasImages = false;
      for (const uuid in images) {
        if (images[uuid].data instanceof HTMLImageElement) {
          hasImages = true;
          break;
        }
      }
      if (hasImages === false) onLoad(object);
    }
    return object;
  }
  async parseAsync(json) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = await this.parseImagesAsync(json.images);
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, textures, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    this.bindLightTargets(object);
    return object;
  }
  parseShapes(json) {
    const shapes = {};
    if (json !== void 0) {
      for (let i = 0, l2 = json.length; i < l2; i++) {
        const shape = new Shape().fromJSON(json[i]);
        shapes[shape.uuid] = shape;
      }
    }
    return shapes;
  }
  parseSkeletons(json, object) {
    const skeletons = {};
    const bones = {};
    object.traverse(function(child) {
      if (child.isBone) bones[child.uuid] = child;
    });
    if (json !== void 0) {
      for (let i = 0, l2 = json.length; i < l2; i++) {
        const skeleton = new Skeleton().fromJSON(json[i], bones);
        skeletons[skeleton.uuid] = skeleton;
      }
    }
    return skeletons;
  }
  parseGeometries(json, shapes) {
    const geometries = {};
    if (json !== void 0) {
      const bufferGeometryLoader = new BufferGeometryLoader();
      for (let i = 0, l2 = json.length; i < l2; i++) {
        let geometry;
        const data = json[i];
        switch (data.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            geometry = bufferGeometryLoader.parse(data);
            break;
          default:
            if (data.type in Geometries) {
              geometry = Geometries[data.type].fromJSON(data, shapes);
            } else {
              console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
            }
        }
        geometry.uuid = data.uuid;
        if (data.name !== void 0) geometry.name = data.name;
        if (data.userData !== void 0) geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }
    return geometries;
  }
  parseMaterials(json, textures) {
    const cache = {};
    const materials = {};
    if (json !== void 0) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);
      for (let i = 0, l2 = json.length; i < l2; i++) {
        const data = json[i];
        if (cache[data.uuid] === void 0) {
          cache[data.uuid] = loader.parse(data);
        }
        materials[data.uuid] = cache[data.uuid];
      }
    }
    return materials;
  }
  parseAnimations(json) {
    const animations = {};
    if (json !== void 0) {
      for (let i = 0; i < json.length; i++) {
        const data = json[i];
        const clip = AnimationClip.parse(data);
        animations[clip.uuid] = clip;
      }
    }
    return animations;
  }
  parseImages(json, onLoad) {
    const scope = this;
    const images = {};
    let loader;
    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function() {
        scope.manager.itemEnd(url);
      }, void 0, function() {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }
    function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return loadImage(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;
        if (Array.isArray(url)) {
          const imageArray = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage);
              } else {
                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
          images[image.uuid] = new Source(imageArray);
        } else {
          const deserializedImage = deserializeImage(image.url);
          images[image.uuid] = new Source(deserializedImage);
        }
      }
    }
    return images;
  }
  async parseImagesAsync(json) {
    const scope = this;
    const images = {};
    let loader;
    async function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return await loader.loadAsync(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;
        if (Array.isArray(url)) {
          const imageArray = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = await deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage);
              } else {
                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
          images[image.uuid] = new Source(imageArray);
        } else {
          const deserializedImage = await deserializeImage(image.url);
          images[image.uuid] = new Source(deserializedImage);
        }
      }
    }
    return images;
  }
  parseTextures(json, images) {
    function parseConstant(value, type) {
      if (typeof value === "number") return value;
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
      return type[value];
    }
    const textures = {};
    if (json !== void 0) {
      for (let i = 0, l2 = json.length; i < l2; i++) {
        const data = json[i];
        if (data.image === void 0) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images[data.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data.image);
        }
        const source = images[data.image];
        const image = source.data;
        let texture;
        if (Array.isArray(image)) {
          texture = new CubeTexture();
          if (image.length === 6) texture.needsUpdate = true;
        } else {
          if (image && image.data) {
            texture = new DataTexture();
          } else {
            texture = new Texture();
          }
          if (image) texture.needsUpdate = true;
        }
        texture.source = source;
        texture.uuid = data.uuid;
        if (data.name !== void 0) texture.name = data.name;
        if (data.mapping !== void 0) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.channel !== void 0) texture.channel = data.channel;
        if (data.offset !== void 0) texture.offset.fromArray(data.offset);
        if (data.repeat !== void 0) texture.repeat.fromArray(data.repeat);
        if (data.center !== void 0) texture.center.fromArray(data.center);
        if (data.rotation !== void 0) texture.rotation = data.rotation;
        if (data.wrap !== void 0) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }
        if (data.format !== void 0) texture.format = data.format;
        if (data.internalFormat !== void 0) texture.internalFormat = data.internalFormat;
        if (data.type !== void 0) texture.type = data.type;
        if (data.colorSpace !== void 0) texture.colorSpace = data.colorSpace;
        if (data.minFilter !== void 0) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== void 0) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== void 0) texture.anisotropy = data.anisotropy;
        if (data.flipY !== void 0) texture.flipY = data.flipY;
        if (data.generateMipmaps !== void 0) texture.generateMipmaps = data.generateMipmaps;
        if (data.premultiplyAlpha !== void 0) texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== void 0) texture.unpackAlignment = data.unpackAlignment;
        if (data.compareFunction !== void 0) texture.compareFunction = data.compareFunction;
        if (data.userData !== void 0) texture.userData = data.userData;
        textures[data.uuid] = texture;
      }
    }
    return textures;
  }
  parseObject(data, geometries, materials, textures, animations) {
    let object;
    function getGeometry(name) {
      if (geometries[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined geometry", name);
      }
      return geometries[name];
    }
    function getMaterial(name) {
      if (name === void 0) return void 0;
      if (Array.isArray(name)) {
        const array = [];
        for (let i = 0, l2 = name.length; i < l2; i++) {
          const uuid = name[i];
          if (materials[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", uuid);
          }
          array.push(materials[uuid]);
        }
        return array;
      }
      if (materials[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined material", name);
      }
      return materials[name];
    }
    function getTexture(uuid) {
      if (textures[uuid] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined texture", uuid);
      }
      return textures[uuid];
    }
    let geometry, material;
    switch (data.type) {
      case "Scene":
        object = new Scene();
        if (data.background !== void 0) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          } else {
            object.background = getTexture(data.background);
          }
        }
        if (data.environment !== void 0) {
          object.environment = getTexture(data.environment);
        }
        if (data.fog !== void 0) {
          if (data.fog.type === "Fog") {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === "FogExp2") {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
          if (data.fog.name !== "") {
            object.fog.name = data.fog.name;
          }
        }
        if (data.backgroundBlurriness !== void 0) object.backgroundBlurriness = data.backgroundBlurriness;
        if (data.backgroundIntensity !== void 0) object.backgroundIntensity = data.backgroundIntensity;
        if (data.backgroundRotation !== void 0) object.backgroundRotation.fromArray(data.backgroundRotation);
        if (data.environmentIntensity !== void 0) object.environmentIntensity = data.environmentIntensity;
        if (data.environmentRotation !== void 0) object.environmentRotation.fromArray(data.environmentRotation);
        break;
      case "PerspectiveCamera":
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== void 0) object.focus = data.focus;
        if (data.zoom !== void 0) object.zoom = data.zoom;
        if (data.filmGauge !== void 0) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== void 0) object.filmOffset = data.filmOffset;
        if (data.view !== void 0) object.view = Object.assign({}, data.view);
        break;
      case "OrthographicCamera":
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== void 0) object.zoom = data.zoom;
        if (data.view !== void 0) object.view = Object.assign({}, data.view);
        break;
      case "AmbientLight":
        object = new AmbientLight(data.color, data.intensity);
        break;
      case "DirectionalLight":
        object = new DirectionalLight(data.color, data.intensity);
        object.target = data.target || "";
        break;
      case "PointLight":
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;
      case "RectAreaLight":
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;
      case "SpotLight":
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        object.target = data.target || "";
        break;
      case "HemisphereLight":
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case "LightProbe":
        object = new LightProbe().fromJSON(data);
        break;
      case "SkinnedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new SkinnedMesh(geometry, material);
        if (data.bindMode !== void 0) object.bindMode = data.bindMode;
        if (data.bindMatrix !== void 0) object.bindMatrix.fromArray(data.bindMatrix);
        if (data.skeleton !== void 0) object.skeleton = data.skeleton;
        break;
      case "Mesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new Mesh(geometry, material);
        break;
      case "InstancedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        const count = data.count;
        const instanceMatrix = data.instanceMatrix;
        const instanceColor = data.instanceColor;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
        if (instanceColor !== void 0) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
        break;
      case "BatchedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new BatchedMesh(data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material);
        object.geometry = geometry;
        object.perObjectFrustumCulled = data.perObjectFrustumCulled;
        object.sortObjects = data.sortObjects;
        object._drawRanges = data.drawRanges;
        object._reservedRanges = data.reservedRanges;
        object._visibility = data.visibility;
        object._active = data.active;
        object._bounds = data.bounds.map((bound) => {
          const box = new Box3();
          box.min.fromArray(bound.boxMin);
          box.max.fromArray(bound.boxMax);
          const sphere = new Sphere();
          sphere.radius = bound.sphereRadius;
          sphere.center.fromArray(bound.sphereCenter);
          return {
            boxInitialized: bound.boxInitialized,
            box,
            sphereInitialized: bound.sphereInitialized,
            sphere
          };
        });
        object._maxInstanceCount = data.maxInstanceCount;
        object._maxVertexCount = data.maxVertexCount;
        object._maxIndexCount = data.maxIndexCount;
        object._geometryInitialized = data.geometryInitialized;
        object._geometryCount = data.geometryCount;
        object._matricesTexture = getTexture(data.matricesTexture.uuid);
        if (data.colorsTexture !== void 0) object._colorsTexture = getTexture(data.colorsTexture.uuid);
        break;
      case "LOD":
        object = new LOD();
        break;
      case "Line":
        object = new Line(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineLoop":
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineSegments":
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "PointCloud":
      case "Points":
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "Sprite":
        object = new Sprite(getMaterial(data.material));
        break;
      case "Group":
        object = new Group();
        break;
      case "Bone":
        object = new Bone();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data.uuid;
    if (data.name !== void 0) object.name = data.name;
    if (data.matrix !== void 0) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== void 0) object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== void 0) object.position.fromArray(data.position);
      if (data.rotation !== void 0) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== void 0) object.quaternion.fromArray(data.quaternion);
      if (data.scale !== void 0) object.scale.fromArray(data.scale);
    }
    if (data.up !== void 0) object.up.fromArray(data.up);
    if (data.castShadow !== void 0) object.castShadow = data.castShadow;
    if (data.receiveShadow !== void 0) object.receiveShadow = data.receiveShadow;
    if (data.shadow) {
      if (data.shadow.intensity !== void 0) object.shadow.intensity = data.shadow.intensity;
      if (data.shadow.bias !== void 0) object.shadow.bias = data.shadow.bias;
      if (data.shadow.normalBias !== void 0) object.shadow.normalBias = data.shadow.normalBias;
      if (data.shadow.radius !== void 0) object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== void 0) object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== void 0) object.shadow.camera = this.parseObject(data.shadow.camera);
    }
    if (data.visible !== void 0) object.visible = data.visible;
    if (data.frustumCulled !== void 0) object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== void 0) object.renderOrder = data.renderOrder;
    if (data.userData !== void 0) object.userData = data.userData;
    if (data.layers !== void 0) object.layers.mask = data.layers;
    if (data.children !== void 0) {
      const children = data.children;
      for (let i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials, textures, animations));
      }
    }
    if (data.animations !== void 0) {
      const objectAnimations = data.animations;
      for (let i = 0; i < objectAnimations.length; i++) {
        const uuid = objectAnimations[i];
        object.animations.push(animations[uuid]);
      }
    }
    if (data.type === "LOD") {
      if (data.autoUpdate !== void 0) object.autoUpdate = data.autoUpdate;
      const levels = data.levels;
      for (let l2 = 0; l2 < levels.length; l2++) {
        const level = levels[l2];
        const child = object.getObjectByProperty("uuid", level.object);
        if (child !== void 0) {
          object.addLevel(child, level.distance, level.hysteresis);
        }
      }
    }
    return object;
  }
  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0) return;
    object.traverse(function(child) {
      if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
        const skeleton = skeletons[child.skeleton];
        if (skeleton === void 0) {
          console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
        } else {
          child.bind(skeleton, child.bindMatrix);
        }
      }
    });
  }
  bindLightTargets(object) {
    object.traverse(function(child) {
      if (child.isDirectionalLight || child.isSpotLight) {
        const uuid = child.target;
        const target = object.getObjectByProperty("uuid", uuid);
        if (target !== void 0) {
          child.target = target;
        } else {
          child.target = new Object3D();
        }
      }
    });
  }
}
const TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping
};
const TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter
};
const _matrix = /* @__PURE__ */ new Matrix4();
class Raycaster {
  constructor(origin, direction2, near = 0, far = Infinity) {
    this.ray = new Ray$1(origin, direction2);
    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(origin, direction2) {
    this.ray.set(origin, direction2);
  }
  setFromCamera(coords, camera) {
    if (camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  }
  setFromXRController(controller) {
    _matrix.identity().extractRotation(controller.matrixWorld);
    this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
    return this;
  }
  intersectObject(object, recursive = true, intersects2 = []) {
    intersect(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  }
  intersectObjects(objects, recursive = true, intersects2 = []) {
    for (let i = 0, l2 = objects.length; i < l2; i++) {
      intersect(objects[i], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersect(object, raycaster, intersects2, recursive) {
  let propagate = true;
  if (object.layers.test(raycaster.layers)) {
    const result = object.raycast(raycaster, intersects2);
    if (result === false) propagate = false;
  }
  if (propagate === true && recursive === true) {
    const children = object.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      intersect(children[i], raycaster, intersects2, true);
    }
  }
}
const _startP = /* @__PURE__ */ new Vector3();
const _startEnd = /* @__PURE__ */ new Vector3();
class Line3 {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target) {
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t = startEnd_startP / startEnd2;
    if (clampToLine) {
      t = clamp(t, 0, 1);
    }
    return t;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class AxesHelper extends LineSegments {
  constructor(size = 1) {
    const vertices = [
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size
    ];
    const colors = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "AxesHelper";
  }
  setColors(xAxisColor, yAxisColor, zAxisColor) {
    const color = new Color();
    const array = this.geometry.attributes.color.array;
    color.set(xAxisColor);
    color.toArray(array, 0);
    color.toArray(array, 3);
    color.set(yAxisColor);
    color.toArray(array, 6);
    color.toArray(array, 9);
    color.set(zAxisColor);
    color.toArray(array, 12);
    color.toArray(array, 15);
    this.geometry.attributes.color.needsUpdate = true;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class Controls extends EventDispatcher {
  constructor(object, domElement = null) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.enabled = true;
    this.state = -1;
    this.keys = {};
    this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };
    this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
class STLLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(data) {
    function isBinary(data2) {
      const reader = new DataView(data2);
      const face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
      const n_faces = reader.getUint32(80, true);
      const expect = 80 + 32 / 8 + n_faces * face_size;
      if (expect === reader.byteLength) {
        return true;
      }
      const solid = [115, 111, 108, 105, 100];
      for (let off = 0; off < 5; off++) {
        if (matchDataViewAt(solid, reader, off)) return false;
      }
      return true;
    }
    function matchDataViewAt(query, reader, offset) {
      for (let i = 0, il = query.length; i < il; i++) {
        if (query[i] !== reader.getUint8(offset + i)) return false;
      }
      return true;
    }
    function parseBinary(data2) {
      const reader = new DataView(data2);
      const faces = reader.getUint32(80, true);
      let r, g, b, hasColors = false, colors;
      let defaultR, defaultG, defaultB, alpha;
      for (let index = 0; index < 80 - 10; index++) {
        if (reader.getUint32(index, false) == 1129270351 && reader.getUint8(index + 4) == 82 && reader.getUint8(index + 5) == 61) {
          hasColors = true;
          colors = new Float32Array(faces * 3 * 3);
          defaultR = reader.getUint8(index + 6) / 255;
          defaultG = reader.getUint8(index + 7) / 255;
          defaultB = reader.getUint8(index + 8) / 255;
          alpha = reader.getUint8(index + 9) / 255;
        }
      }
      const dataOffset = 84;
      const faceLength = 12 * 4 + 2;
      const geometry = new BufferGeometry();
      const vertices = new Float32Array(faces * 3 * 3);
      const normals = new Float32Array(faces * 3 * 3);
      const color = new Color();
      for (let face = 0; face < faces; face++) {
        const start = dataOffset + face * faceLength;
        const normalX = reader.getFloat32(start, true);
        const normalY = reader.getFloat32(start + 4, true);
        const normalZ = reader.getFloat32(start + 8, true);
        if (hasColors) {
          const packedColor = reader.getUint16(start + 48, true);
          if ((packedColor & 32768) === 0) {
            r = (packedColor & 31) / 31;
            g = (packedColor >> 5 & 31) / 31;
            b = (packedColor >> 10 & 31) / 31;
          } else {
            r = defaultR;
            g = defaultG;
            b = defaultB;
          }
        }
        for (let i = 1; i <= 3; i++) {
          const vertexstart = start + i * 12;
          const componentIdx = face * 3 * 3 + (i - 1) * 3;
          vertices[componentIdx] = reader.getFloat32(vertexstart, true);
          vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);
          vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);
          normals[componentIdx] = normalX;
          normals[componentIdx + 1] = normalY;
          normals[componentIdx + 2] = normalZ;
          if (hasColors) {
            color.setRGB(r, g, b, SRGBColorSpace);
            colors[componentIdx] = color.r;
            colors[componentIdx + 1] = color.g;
            colors[componentIdx + 2] = color.b;
          }
        }
      }
      geometry.setAttribute("position", new BufferAttribute(vertices, 3));
      geometry.setAttribute("normal", new BufferAttribute(normals, 3));
      if (hasColors) {
        geometry.setAttribute("color", new BufferAttribute(colors, 3));
        geometry.hasColors = true;
        geometry.alpha = alpha;
      }
      return geometry;
    }
    function parseASCII(data2) {
      const geometry = new BufferGeometry();
      const patternSolid = /solid([\s\S]*?)endsolid/g;
      const patternFace = /facet([\s\S]*?)endfacet/g;
      const patternName = /solid\s(.+)/;
      let faceCounter = 0;
      const patternFloat = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source;
      const patternVertex = new RegExp("vertex" + patternFloat + patternFloat + patternFloat, "g");
      const patternNormal = new RegExp("normal" + patternFloat + patternFloat + patternFloat, "g");
      const vertices = [];
      const normals = [];
      const groupNames = [];
      const normal = new Vector3();
      let result;
      let groupCount = 0;
      let startVertex = 0;
      let endVertex = 0;
      while ((result = patternSolid.exec(data2)) !== null) {
        startVertex = endVertex;
        const solid = result[0];
        const name = (result = patternName.exec(solid)) !== null ? result[1] : "";
        groupNames.push(name);
        while ((result = patternFace.exec(solid)) !== null) {
          let vertexCountPerFace = 0;
          let normalCountPerFace = 0;
          const text = result[0];
          while ((result = patternNormal.exec(text)) !== null) {
            normal.x = parseFloat(result[1]);
            normal.y = parseFloat(result[2]);
            normal.z = parseFloat(result[3]);
            normalCountPerFace++;
          }
          while ((result = patternVertex.exec(text)) !== null) {
            vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
            normals.push(normal.x, normal.y, normal.z);
            vertexCountPerFace++;
            endVertex++;
          }
          if (normalCountPerFace !== 1) {
            console.error("THREE.STLLoader: Something isn't right with the normal of face number " + faceCounter);
          }
          if (vertexCountPerFace !== 3) {
            console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + faceCounter);
          }
          faceCounter++;
        }
        const start = startVertex;
        const count = endVertex - startVertex;
        geometry.userData.groupNames = groupNames;
        geometry.addGroup(start, count, groupCount);
        groupCount++;
      }
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      return geometry;
    }
    function ensureString(buffer) {
      if (typeof buffer !== "string") {
        return new TextDecoder().decode(buffer);
      }
      return buffer;
    }
    function ensureBinary(buffer) {
      if (typeof buffer === "string") {
        const array_buffer = new Uint8Array(buffer.length);
        for (let i = 0; i < buffer.length; i++) {
          array_buffer[i] = buffer.charCodeAt(i) & 255;
        }
        return array_buffer.buffer || array_buffer;
      } else {
        return buffer;
      }
    }
    const binData = ensureBinary(data);
    return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));
  }
}
const _color$1 = new Color();
class PLYLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.propertyNameMapping = {};
    this.customPropertyMapping = {};
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  setPropertyNameMapping(mapping) {
    this.propertyNameMapping = mapping;
  }
  setCustomPropertyNameMapping(mapping) {
    this.customPropertyMapping = mapping;
  }
  parse(data) {
    function parseHeader(data2, headerLength = 0) {
      const patternHeader = /^ply([\s\S]*)end_header(\r\n|\r|\n)/;
      let headerText = "";
      const result = patternHeader.exec(data2);
      if (result !== null) {
        headerText = result[1];
      }
      const header = {
        comments: [],
        elements: [],
        headerLength,
        objInfo: ""
      };
      const lines = headerText.split(/\r\n|\r|\n/);
      let currentElement;
      function make_ply_element_property(propertValues, propertyNameMapping) {
        const property = { type: propertValues[0] };
        if (property.type === "list") {
          property.name = propertValues[3];
          property.countType = propertValues[1];
          property.itemType = propertValues[2];
        } else {
          property.name = propertValues[1];
        }
        if (property.name in propertyNameMapping) {
          property.name = propertyNameMapping[property.name];
        }
        return property;
      }
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        line = line.trim();
        if (line === "") continue;
        const lineValues = line.split(/\s+/);
        const lineType = lineValues.shift();
        line = lineValues.join(" ");
        switch (lineType) {
          case "format":
            header.format = lineValues[0];
            header.version = lineValues[1];
            break;
          case "comment":
            header.comments.push(line);
            break;
          case "element":
            if (currentElement !== void 0) {
              header.elements.push(currentElement);
            }
            currentElement = {};
            currentElement.name = lineValues[0];
            currentElement.count = parseInt(lineValues[1]);
            currentElement.properties = [];
            break;
          case "property":
            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));
            break;
          case "obj_info":
            header.objInfo = line;
            break;
          default:
            console.log("unhandled", lineType, lineValues);
        }
      }
      if (currentElement !== void 0) {
        header.elements.push(currentElement);
      }
      return header;
    }
    function parseASCIINumber(n, type) {
      switch (type) {
        case "char":
        case "uchar":
        case "short":
        case "ushort":
        case "int":
        case "uint":
        case "int8":
        case "uint8":
        case "int16":
        case "uint16":
        case "int32":
        case "uint32":
          return parseInt(n);
        case "float":
        case "double":
        case "float32":
        case "float64":
          return parseFloat(n);
      }
    }
    function parseASCIIElement(properties, tokens) {
      const element = {};
      for (let i = 0; i < properties.length; i++) {
        if (tokens.empty()) return null;
        if (properties[i].type === "list") {
          const list = [];
          const n = parseASCIINumber(tokens.next(), properties[i].countType);
          for (let j = 0; j < n; j++) {
            if (tokens.empty()) return null;
            list.push(parseASCIINumber(tokens.next(), properties[i].itemType));
          }
          element[properties[i].name] = list;
        } else {
          element[properties[i].name] = parseASCIINumber(tokens.next(), properties[i].type);
        }
      }
      return element;
    }
    function createBuffer() {
      const buffer = {
        indices: [],
        vertices: [],
        normals: [],
        uvs: [],
        faceVertexUvs: [],
        colors: [],
        faceVertexColors: []
      };
      for (const customProperty of Object.keys(scope.customPropertyMapping)) {
        buffer[customProperty] = [];
      }
      return buffer;
    }
    function mapElementAttributes(properties) {
      const elementNames = properties.map((property) => {
        return property.name;
      });
      function findAttrName(names) {
        for (let i = 0, l2 = names.length; i < l2; i++) {
          const name = names[i];
          if (elementNames.includes(name)) return name;
        }
        return null;
      }
      return {
        attrX: findAttrName(["x", "px", "posx"]) || "x",
        attrY: findAttrName(["y", "py", "posy"]) || "y",
        attrZ: findAttrName(["z", "pz", "posz"]) || "z",
        attrNX: findAttrName(["nx", "normalx"]),
        attrNY: findAttrName(["ny", "normaly"]),
        attrNZ: findAttrName(["nz", "normalz"]),
        attrS: findAttrName(["s", "u", "texture_u", "tx"]),
        attrT: findAttrName(["t", "v", "texture_v", "ty"]),
        attrR: findAttrName(["red", "diffuse_red", "r", "diffuse_r"]),
        attrG: findAttrName(["green", "diffuse_green", "g", "diffuse_g"]),
        attrB: findAttrName(["blue", "diffuse_blue", "b", "diffuse_b"])
      };
    }
    function parseASCII(data2, header) {
      const buffer = createBuffer();
      const patternBody = /end_header\s+(\S[\s\S]*\S|\S)\s*$/;
      let body, matches;
      if ((matches = patternBody.exec(data2)) !== null) {
        body = matches[1].split(/\s+/);
      } else {
        body = [];
      }
      const tokens = new ArrayStream(body);
      loop: for (let i = 0; i < header.elements.length; i++) {
        const elementDesc = header.elements[i];
        const attributeMap = mapElementAttributes(elementDesc.properties);
        for (let j = 0; j < elementDesc.count; j++) {
          const element = parseASCIIElement(elementDesc.properties, tokens);
          if (!element) break loop;
          handleElement(buffer, elementDesc.name, element, attributeMap);
        }
      }
      return postProcess(buffer);
    }
    function postProcess(buffer) {
      let geometry2 = new BufferGeometry();
      if (buffer.indices.length > 0) {
        geometry2.setIndex(buffer.indices);
      }
      geometry2.setAttribute("position", new Float32BufferAttribute(buffer.vertices, 3));
      if (buffer.normals.length > 0) {
        geometry2.setAttribute("normal", new Float32BufferAttribute(buffer.normals, 3));
      }
      if (buffer.uvs.length > 0) {
        geometry2.setAttribute("uv", new Float32BufferAttribute(buffer.uvs, 2));
      }
      if (buffer.colors.length > 0) {
        geometry2.setAttribute("color", new Float32BufferAttribute(buffer.colors, 3));
      }
      if (buffer.faceVertexUvs.length > 0 || buffer.faceVertexColors.length > 0) {
        geometry2 = geometry2.toNonIndexed();
        if (buffer.faceVertexUvs.length > 0) geometry2.setAttribute("uv", new Float32BufferAttribute(buffer.faceVertexUvs, 2));
        if (buffer.faceVertexColors.length > 0) geometry2.setAttribute("color", new Float32BufferAttribute(buffer.faceVertexColors, 3));
      }
      for (const customProperty of Object.keys(scope.customPropertyMapping)) {
        if (buffer[customProperty].length > 0) {
          geometry2.setAttribute(
            customProperty,
            new Float32BufferAttribute(
              buffer[customProperty],
              scope.customPropertyMapping[customProperty].length
            )
          );
        }
      }
      geometry2.computeBoundingSphere();
      return geometry2;
    }
    function handleElement(buffer, elementName, element, cacheEntry) {
      if (elementName === "vertex") {
        buffer.vertices.push(element[cacheEntry.attrX], element[cacheEntry.attrY], element[cacheEntry.attrZ]);
        if (cacheEntry.attrNX !== null && cacheEntry.attrNY !== null && cacheEntry.attrNZ !== null) {
          buffer.normals.push(element[cacheEntry.attrNX], element[cacheEntry.attrNY], element[cacheEntry.attrNZ]);
        }
        if (cacheEntry.attrS !== null && cacheEntry.attrT !== null) {
          buffer.uvs.push(element[cacheEntry.attrS], element[cacheEntry.attrT]);
        }
        if (cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null) {
          _color$1.setRGB(
            element[cacheEntry.attrR] / 255,
            element[cacheEntry.attrG] / 255,
            element[cacheEntry.attrB] / 255,
            SRGBColorSpace
          );
          buffer.colors.push(_color$1.r, _color$1.g, _color$1.b);
        }
        for (const customProperty of Object.keys(scope.customPropertyMapping)) {
          for (const elementProperty of scope.customPropertyMapping[customProperty]) {
            buffer[customProperty].push(element[elementProperty]);
          }
        }
      } else if (elementName === "face") {
        const vertex_indices = element.vertex_indices || element.vertex_index;
        const texcoord = element.texcoord;
        if (vertex_indices.length === 3) {
          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);
          if (texcoord && texcoord.length === 6) {
            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);
            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);
            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);
          }
        } else if (vertex_indices.length === 4) {
          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);
          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);
        }
        if (cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null) {
          _color$1.setRGB(
            element[cacheEntry.attrR] / 255,
            element[cacheEntry.attrG] / 255,
            element[cacheEntry.attrB] / 255,
            SRGBColorSpace
          );
          buffer.faceVertexColors.push(_color$1.r, _color$1.g, _color$1.b);
          buffer.faceVertexColors.push(_color$1.r, _color$1.g, _color$1.b);
          buffer.faceVertexColors.push(_color$1.r, _color$1.g, _color$1.b);
        }
      }
    }
    function binaryReadElement(at, properties) {
      const element = {};
      let read = 0;
      for (let i = 0; i < properties.length; i++) {
        const property = properties[i];
        const valueReader = property.valueReader;
        if (property.type === "list") {
          const list = [];
          const n = property.countReader.read(at + read);
          read += property.countReader.size;
          for (let j = 0; j < n; j++) {
            list.push(valueReader.read(at + read));
            read += valueReader.size;
          }
          element[property.name] = list;
        } else {
          element[property.name] = valueReader.read(at + read);
          read += valueReader.size;
        }
      }
      return [element, read];
    }
    function setPropertyBinaryReaders(properties, body, little_endian) {
      function getBinaryReader(dataview, type, little_endian2) {
        switch (type) {
          case "int8":
          case "char":
            return { read: (at) => {
              return dataview.getInt8(at);
            }, size: 1 };
          case "uint8":
          case "uchar":
            return { read: (at) => {
              return dataview.getUint8(at);
            }, size: 1 };
          case "int16":
          case "short":
            return { read: (at) => {
              return dataview.getInt16(at, little_endian2);
            }, size: 2 };
          case "uint16":
          case "ushort":
            return { read: (at) => {
              return dataview.getUint16(at, little_endian2);
            }, size: 2 };
          case "int32":
          case "int":
            return { read: (at) => {
              return dataview.getInt32(at, little_endian2);
            }, size: 4 };
          case "uint32":
          case "uint":
            return { read: (at) => {
              return dataview.getUint32(at, little_endian2);
            }, size: 4 };
          case "float32":
          case "float":
            return { read: (at) => {
              return dataview.getFloat32(at, little_endian2);
            }, size: 4 };
          case "float64":
          case "double":
            return { read: (at) => {
              return dataview.getFloat64(at, little_endian2);
            }, size: 8 };
        }
      }
      for (let i = 0, l2 = properties.length; i < l2; i++) {
        const property = properties[i];
        if (property.type === "list") {
          property.countReader = getBinaryReader(body, property.countType, little_endian);
          property.valueReader = getBinaryReader(body, property.itemType, little_endian);
        } else {
          property.valueReader = getBinaryReader(body, property.type, little_endian);
        }
      }
    }
    function parseBinary(data2, header) {
      const buffer = createBuffer();
      const little_endian = header.format === "binary_little_endian";
      const body = new DataView(data2, header.headerLength);
      let result, loc = 0;
      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {
        const elementDesc = header.elements[currentElement];
        const properties = elementDesc.properties;
        const attributeMap = mapElementAttributes(properties);
        setPropertyBinaryReaders(properties, body, little_endian);
        for (let currentElementCount = 0; currentElementCount < elementDesc.count; currentElementCount++) {
          result = binaryReadElement(loc, properties);
          loc += result[1];
          const element = result[0];
          handleElement(buffer, elementDesc.name, element, attributeMap);
        }
      }
      return postProcess(buffer);
    }
    function extractHeaderText(bytes) {
      let i = 0;
      let cont = true;
      let line = "";
      const lines = [];
      const startLine = new TextDecoder().decode(bytes.subarray(0, 5));
      const hasCRNL = /^ply\r\n/.test(startLine);
      do {
        const c = String.fromCharCode(bytes[i++]);
        if (c !== "\n" && c !== "\r") {
          line += c;
        } else {
          if (line === "end_header") cont = false;
          if (line !== "") {
            lines.push(line);
            line = "";
          }
        }
      } while (cont && i < bytes.length);
      if (hasCRNL === true) i++;
      return { headerText: lines.join("\r") + "\r", headerLength: i };
    }
    let geometry;
    const scope = this;
    if (data instanceof ArrayBuffer) {
      const bytes = new Uint8Array(data);
      const { headerText, headerLength } = extractHeaderText(bytes);
      const header = parseHeader(headerText, headerLength);
      if (header.format === "ascii") {
        const text = new TextDecoder().decode(bytes);
        geometry = parseASCII(text, header);
      } else {
        geometry = parseBinary(data, header);
      }
    } else {
      geometry = parseASCII(data, parseHeader(data));
    }
    return geometry;
  }
}
class ArrayStream {
  constructor(arr) {
    this.arr = arr;
    this.i = 0;
  }
  empty() {
    return this.i >= this.arr.length;
  }
  next() {
    return this.arr[this.i++];
  }
}
const _object_pattern = /^[og]\s*(.+)?/;
const _material_library_pattern = /^mtllib /;
const _material_use_pattern = /^usemtl /;
const _map_use_pattern = /^usemap /;
const _face_vertex_data_separator_pattern = /\s+/;
const _vA$1 = new Vector3();
const _vB$1 = new Vector3();
const _vC$1 = new Vector3();
const _ab = new Vector3();
const _cb = new Vector3();
const _color = new Color();
function ParserState() {
  const state = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(name, fromDeclaration) {
      if (this.object && this.object.fromDeclaration === false) {
        this.object.name = name;
        this.object.fromDeclaration = fromDeclaration !== false;
        return;
      }
      const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
      this.object = {
        name: name || "",
        fromDeclaration: fromDeclaration !== false,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: false
        },
        materials: [],
        smooth: true,
        startMaterial: function(name2, libraries) {
          const previous = this._finalize(false);
          if (previous && (previous.inherited || previous.groupCount <= 0)) {
            this.materials.splice(previous.index, 1);
          }
          const material = {
            index: this.materials.length,
            name: name2 || "",
            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
            smooth: previous !== void 0 ? previous.smooth : this.smooth,
            groupStart: previous !== void 0 ? previous.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: false,
            clone: function(index) {
              const cloned = {
                index: typeof index === "number" ? index : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: false
              };
              cloned.clone = this.clone.bind(cloned);
              return cloned;
            }
          };
          this.materials.push(material);
          return material;
        },
        currentMaterial: function() {
          if (this.materials.length > 0) {
            return this.materials[this.materials.length - 1];
          }
          return void 0;
        },
        _finalize: function(end) {
          const lastMultiMaterial = this.currentMaterial();
          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
            lastMultiMaterial.inherited = false;
          }
          if (end && this.materials.length > 1) {
            for (let mi = this.materials.length - 1; mi >= 0; mi--) {
              if (this.materials[mi].groupCount <= 0) {
                this.materials.splice(mi, 1);
              }
            }
          }
          if (end && this.materials.length === 0) {
            this.materials.push({
              name: "",
              smooth: this.smooth
            });
          }
          return lastMultiMaterial;
        }
      };
      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
        const declared = previousMaterial.clone(0);
        declared.inherited = true;
        this.object.materials.push(declared);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
    },
    parseVertexIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseNormalIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseUVIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    },
    addVertex: function(a, b, c) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addVertexPoint: function(a) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    },
    addVertexLine: function(a) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    },
    addNormal: function(a, b, c) {
      const src = this.normals;
      const dst = this.object.geometry.normals;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addFaceNormal: function(a, b, c) {
      const src = this.vertices;
      const dst = this.object.geometry.normals;
      _vA$1.fromArray(src, a);
      _vB$1.fromArray(src, b);
      _vC$1.fromArray(src, c);
      _cb.subVectors(_vC$1, _vB$1);
      _ab.subVectors(_vA$1, _vB$1);
      _cb.cross(_ab);
      _cb.normalize();
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
    },
    addColor: function(a, b, c) {
      const src = this.colors;
      const dst = this.object.geometry.colors;
      if (src[a] !== void 0) dst.push(src[a + 0], src[a + 1], src[a + 2]);
      if (src[b] !== void 0) dst.push(src[b + 0], src[b + 1], src[b + 2]);
      if (src[c] !== void 0) dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addUV: function(a, b, c) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
      dst.push(src[b + 0], src[b + 1]);
      dst.push(src[c + 0], src[c + 1]);
    },
    addDefaultUV: function() {
      const dst = this.object.geometry.uvs;
      dst.push(0, 0);
      dst.push(0, 0);
      dst.push(0, 0);
    },
    addUVLine: function(a) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
    },
    addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
      const vLen = this.vertices.length;
      let ia = this.parseVertexIndex(a, vLen);
      let ib = this.parseVertexIndex(b, vLen);
      let ic = this.parseVertexIndex(c, vLen);
      this.addVertex(ia, ib, ic);
      this.addColor(ia, ib, ic);
      if (na !== void 0 && na !== "") {
        const nLen = this.normals.length;
        ia = this.parseNormalIndex(na, nLen);
        ib = this.parseNormalIndex(nb, nLen);
        ic = this.parseNormalIndex(nc, nLen);
        this.addNormal(ia, ib, ic);
      } else {
        this.addFaceNormal(ia, ib, ic);
      }
      if (ua !== void 0 && ua !== "") {
        const uvLen = this.uvs.length;
        ia = this.parseUVIndex(ua, uvLen);
        ib = this.parseUVIndex(ub, uvLen);
        ic = this.parseUVIndex(uc, uvLen);
        this.addUV(ia, ib, ic);
        this.object.geometry.hasUVIndices = true;
      } else {
        this.addDefaultUV();
      }
    },
    addPointGeometry: function(vertices) {
      this.object.geometry.type = "Points";
      const vLen = this.vertices.length;
      for (let vi = 0, l2 = vertices.length; vi < l2; vi++) {
        const index = this.parseVertexIndex(vertices[vi], vLen);
        this.addVertexPoint(index);
        this.addColor(index);
      }
    },
    addLineGeometry: function(vertices, uvs) {
      this.object.geometry.type = "Line";
      const vLen = this.vertices.length;
      const uvLen = this.uvs.length;
      for (let vi = 0, l2 = vertices.length; vi < l2; vi++) {
        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
      }
      for (let uvi = 0, l2 = uvs.length; uvi < l2; uvi++) {
        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
      }
    }
  };
  state.startObject("", false);
  return state;
}
class OBJLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.materials = null;
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  setMaterials(materials) {
    this.materials = materials;
    return this;
  }
  parse(text) {
    const state = new ParserState();
    if (text.indexOf("\r\n") !== -1) {
      text = text.replace(/\r\n/g, "\n");
    }
    if (text.indexOf("\\\n") !== -1) {
      text = text.replace(/\\\n/g, "");
    }
    const lines = text.split("\n");
    let result = [];
    for (let i = 0, l2 = lines.length; i < l2; i++) {
      const line = lines[i].trimStart();
      if (line.length === 0) continue;
      const lineFirstChar = line.charAt(0);
      if (lineFirstChar === "#") continue;
      if (lineFirstChar === "v") {
        const data = line.split(_face_vertex_data_separator_pattern);
        switch (data[0]) {
          case "v":
            state.vertices.push(
              parseFloat(data[1]),
              parseFloat(data[2]),
              parseFloat(data[3])
            );
            if (data.length >= 7) {
              _color.setRGB(
                parseFloat(data[4]),
                parseFloat(data[5]),
                parseFloat(data[6]),
                SRGBColorSpace
              );
              state.colors.push(_color.r, _color.g, _color.b);
            } else {
              state.colors.push(void 0, void 0, void 0);
            }
            break;
          case "vn":
            state.normals.push(
              parseFloat(data[1]),
              parseFloat(data[2]),
              parseFloat(data[3])
            );
            break;
          case "vt":
            state.uvs.push(
              parseFloat(data[1]),
              parseFloat(data[2])
            );
            break;
        }
      } else if (lineFirstChar === "f") {
        const lineData = line.slice(1).trim();
        const vertexData = lineData.split(_face_vertex_data_separator_pattern);
        const faceVertices = [];
        for (let j = 0, jl = vertexData.length; j < jl; j++) {
          const vertex2 = vertexData[j];
          if (vertex2.length > 0) {
            const vertexParts = vertex2.split("/");
            faceVertices.push(vertexParts);
          }
        }
        const v1 = faceVertices[0];
        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {
          const v2 = faceVertices[j];
          const v3 = faceVertices[j + 1];
          state.addFace(
            v1[0],
            v2[0],
            v3[0],
            v1[1],
            v2[1],
            v3[1],
            v1[2],
            v2[2],
            v3[2]
          );
        }
      } else if (lineFirstChar === "l") {
        const lineParts = line.substring(1).trim().split(" ");
        let lineVertices = [];
        const lineUVs = [];
        if (line.indexOf("/") === -1) {
          lineVertices = lineParts;
        } else {
          for (let li = 0, llen = lineParts.length; li < llen; li++) {
            const parts = lineParts[li].split("/");
            if (parts[0] !== "") lineVertices.push(parts[0]);
            if (parts[1] !== "") lineUVs.push(parts[1]);
          }
        }
        state.addLineGeometry(lineVertices, lineUVs);
      } else if (lineFirstChar === "p") {
        const lineData = line.slice(1).trim();
        const pointData = lineData.split(" ");
        state.addPointGeometry(pointData);
      } else if ((result = _object_pattern.exec(line)) !== null) {
        const name = (" " + result[0].slice(1).trim()).slice(1);
        state.startObject(name);
      } else if (_material_use_pattern.test(line)) {
        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
      } else if (_material_library_pattern.test(line)) {
        state.materialLibraries.push(line.substring(7).trim());
      } else if (_map_use_pattern.test(line)) {
        console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
      } else if (lineFirstChar === "s") {
        result = line.split(" ");
        if (result.length > 1) {
          const value = result[1].trim().toLowerCase();
          state.object.smooth = value !== "0" && value !== "off";
        } else {
          state.object.smooth = true;
        }
        const material = state.object.currentMaterial();
        if (material) material.smooth = state.object.smooth;
      } else {
        if (line === "\0") continue;
        console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
      }
    }
    state.finalize();
    const container = new Group();
    container.materialLibraries = [].concat(state.materialLibraries);
    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
    if (hasPrimitives === true) {
      for (let i = 0, l2 = state.objects.length; i < l2; i++) {
        const object = state.objects[i];
        const geometry = object.geometry;
        const materials = object.materials;
        const isLine = geometry.type === "Line";
        const isPoints = geometry.type === "Points";
        let hasVertexColors = false;
        if (geometry.vertices.length === 0) continue;
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute(geometry.vertices, 3));
        if (geometry.normals.length > 0) {
          buffergeometry.setAttribute("normal", new Float32BufferAttribute(geometry.normals, 3));
        }
        if (geometry.colors.length > 0) {
          hasVertexColors = true;
          buffergeometry.setAttribute("color", new Float32BufferAttribute(geometry.colors, 3));
        }
        if (geometry.hasUVIndices === true) {
          buffergeometry.setAttribute("uv", new Float32BufferAttribute(geometry.uvs, 2));
        }
        const createdMaterials = [];
        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
          const sourceMaterial = materials[mi];
          const materialHash = sourceMaterial.name + "_" + sourceMaterial.smooth + "_" + hasVertexColors;
          let material = state.materials[materialHash];
          if (this.materials !== null) {
            material = this.materials.create(sourceMaterial.name);
            if (isLine && material && !(material instanceof LineBasicMaterial)) {
              const materialLine = new LineBasicMaterial();
              Material.prototype.copy.call(materialLine, material);
              materialLine.color.copy(material.color);
              material = materialLine;
            } else if (isPoints && material && !(material instanceof PointsMaterial)) {
              const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false });
              Material.prototype.copy.call(materialPoints, material);
              materialPoints.color.copy(material.color);
              materialPoints.map = material.map;
              material = materialPoints;
            }
          }
          if (material === void 0) {
            if (isLine) {
              material = new LineBasicMaterial();
            } else if (isPoints) {
              material = new PointsMaterial({ size: 1, sizeAttenuation: false });
            } else {
              material = new MeshPhongMaterial();
            }
            material.name = sourceMaterial.name;
            material.flatShading = sourceMaterial.smooth ? false : true;
            material.vertexColors = hasVertexColors;
            state.materials[materialHash] = material;
          }
          createdMaterials.push(material);
        }
        let mesh;
        if (createdMaterials.length > 1) {
          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
            const sourceMaterial = materials[mi];
            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
          }
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials);
          }
        } else {
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials[0]);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials[0]);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials[0]);
          }
        }
        mesh.name = object.name;
        container.add(mesh);
      }
    } else {
      if (state.vertices.length > 0) {
        const material = new PointsMaterial({ size: 1, sizeAttenuation: false });
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute(state.vertices, 3));
        if (state.colors.length > 0 && state.colors[0] !== void 0) {
          buffergeometry.setAttribute("color", new Float32BufferAttribute(state.colors, 3));
          material.vertexColors = true;
        }
        const points = new Points(buffergeometry, material);
        container.add(points);
      }
    }
    return container;
  }
}
const _taskCache = /* @__PURE__ */ new WeakMap();
class DRACOLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config2) {
    this.decoderConfig = config2;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      this.parse(buffer, onLoad, onError);
    }, onProgress, onError);
  }
  parse(buffer, onLoad, onError = () => {
  }) {
    this.decodeDracoFile(buffer, onLoad, null, null, SRGBColorSpace, onError).catch(onError);
  }
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace, onError = () => {
  }) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs,
      vertexColorSpace
    };
    return this.decodeGeometry(buffer, taskConfig).then(callback).catch(onError);
  }
  decodeGeometry(buffer, taskConfig) {
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache.has(buffer)) {
      const cachedTask = _taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = { resolve, reject };
        worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache.set(buffer, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const result = geometryData.attributes[i];
      const name = result.name;
      const array = result.array;
      const itemSize = result.itemSize;
      const attribute = new BufferAttribute(array, itemSize);
      if (name === "color") {
        this._assignVertexColorSpace(attribute, result.vertexColorSpace);
        attribute.normalized = array instanceof Float32Array === false;
      }
      geometry.setAttribute(name, attribute);
    }
    return geometry;
  }
  _assignVertexColorSpace(attribute, inputColorSpace) {
    if (inputColorSpace !== SRGBColorSpace) return;
    const _color2 = new Color();
    for (let i = 0, il = attribute.count; i < il; i++) {
      _color2.fromBufferAttribute(attribute, i);
      ColorManagement.toWorkingColorSpace(_color2, SRGBColorSpace);
      attribute.setXYZ(i, _color2.r, _color2.g, _color2.b);
    }
  }
  _loadLibrary(url, responseType) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.decoderPath);
    loader.setResponseType(responseType);
    loader.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader.load(url, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate();
    }
    this.workerPool.length = 0;
    if (this.workerSourceURL !== "") {
      URL.revokeObjectURL(this.workerSourceURL);
    }
    return this;
  }
}
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module) => {
          const draco = module.draco;
          const decoder = new draco.Decoder();
          try {
            const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index) buffers.push(geometry.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, array, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(array);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1) continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
      if (attributeName === "color") {
        attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;
      }
      geometry.attributes.push(attributeResult);
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}
class TrackerResource {
  constructor() {
    this.resourceSet = /* @__PURE__ */ new Set();
  }
  track(resource) {
    if (!resource) {
      return resource;
    }
    if (Array.isArray(resource)) {
      resource.forEach((child) => this.track(child));
      return resource;
    }
    if (resource.dispose || resource instanceof Object3D) {
      this.resourceSet.add(resource);
    }
    if (resource instanceof Object3D) {
      this.track(resource.geometry);
      this.track(resource.material);
      this.track(resource.children);
    } else if (resource instanceof Material) {
      for (const value of Object.values(resource)) {
        if (value instanceof Texture) {
          this.track(value);
        }
      }
      if (resource.uniforms) {
        for (const value of Object.values(resource.uniforms)) {
          if (value) {
            const uniformValue = value.value;
            if (uniformValue instanceof Texture || Array.isArray(uniformValue)) {
              this.track(uniformValue);
            }
          }
        }
      }
    }
    return resource;
  }
  untrack(resource) {
    this.resourceSet.delete(resource);
  }
  dispose() {
    for (const item of this.resourceSet) {
      if (item instanceof Object3D) {
        if (item.parent) {
          item.parent.remove(item);
        }
      }
      if (item.dispose) {
        item.dispose();
      }
    }
    this.resourceSet.clear();
  }
}
class TrackFile {
  constructor() {
    this.fileUrlSet = /* @__PURE__ */ new Set();
  }
  add(url) {
    this.fileUrlSet.add(url);
  }
  free() {
    for (const url of this.fileUrlSet) {
      URL.revokeObjectURL(url);
    }
    this.fileUrlSet.clear();
  }
}
const trackFileUrl = new TrackFile();
var eModelFile = /* @__PURE__ */ ((eModelFile2) => {
  eModelFile2["unknown"] = "unkown";
  eModelFile2["drc"] = "drc";
  eModelFile2["stl"] = "stl";
  eModelFile2["ply"] = "ply";
  eModelFile2["obj"] = "obj";
  eModelFile2["jsonbg"] = "jsonbg";
  eModelFile2["mq"] = "mq";
  return eModelFile2;
})(eModelFile || {});
function toCleanPath(path) {
  return path.split("?")[0];
}
function infoExtPath(path) {
  const target = {
    support: false,
    type: "unkown"
    /* unknown */
  };
  let cleanPath = toCleanPath(path);
  const pos1 = cleanPath.lastIndexOf("/");
  const name = cleanPath.substring(pos1 + 1);
  const ext = name.substring(name.lastIndexOf(".") + 1).toLowerCase();
  Object.keys(eModelFile).forEach((e) => {
    if (typeof e == "string" && e == ext) {
      target.support = true;
      if (["drc", "mq"].includes(ext)) {
        target.type = "mq";
      } else if (ext == "stl") {
        target.type = "stl";
      } else if (ext == "ply") {
        target.type = "ply";
      } else if (ext == "obj") {
        target.type = "obj";
      } else if (ext == "jsonbg") {
        target.type = "jsonbg";
      } else {
        throw `unsupport file ext type ${ext}`;
      }
    }
  });
  return target;
}
class CommonLoader {
  constructor(path, options) {
    this.options = options || {};
    if (!this.options.drcPath) this.options.drcPath = "js/libs/draco/";
    this.loader = null;
    this.infoExt = infoExtPath(path);
    if (!this.infoExt.support) {
      throw `unsupport type ${path}`;
    }
    switch (this.infoExt.type.toString()) {
      case "drc":
      case "mq": {
        this.loader = new DRACOLoader();
        this.loader.setDecoderPath(this.options.drcPath);
        this.loader.setDecoderConfig({ type: "js" });
        this.loader.preload();
        if (this.options.code == 1) {
          this.loader.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD",
            VFlag: "GENERIC"
          };
          this.loader.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array",
            VFlag: "Uint16Array"
          };
        } else if (this.options.code == 2) {
          this.loader.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD",
            flag: "GENERIC"
          };
          this.loader.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array",
            flag: "Uint8Array"
          };
        }
        break;
      }
      case "stl": {
        this.loader = new STLLoader();
        break;
      }
      case "ply": {
        this.loader = new PLYLoader();
        break;
      }
      case "obj": {
        this.loader = new OBJLoader();
        break;
      }
      case "jsonbg": {
        this.loader = new BufferGeometryLoader();
        break;
      }
    }
  }
  static getName(path) {
    return path.substring(toCleanPath(path).lastIndexOf("/") + 1);
  }
  load(path, cb = () => {
  }) {
    const { loader } = this;
    if (!loader) return;
    return new Promise((resolve) => {
      loader.load(path, function(geometry) {
        geometry.computeVertexNormals();
        if (geometry.attributes["uv"]) geometry.computeTangents();
        resolve(geometry);
      }, cb);
    });
  }
  dracoDecodeGeometry(buffer) {
    const { loader, infoExt } = this;
    if (!loader) return;
    if (!(infoExt.type == "drc" || infoExt.type == "mq")) return;
    const taskConfig = {
      attributeIDs: loader.defaultAttributeIDs,
      attributeTypes: loader.defaultAttributeTypes,
      useUniqueIDs: false
    };
    return new Promise((resolve) => {
      loader.decodeGeometry(buffer, taskConfig).then((geometry) => {
        resolve(geometry);
      });
    });
  }
  dispose() {
    const { infoExt, loader } = this;
    if (loader && [
      "drc",
      "mq"
      /* mq */
    ].includes(infoExt.type)) {
      loader.dispose();
    }
  }
  parse(buffer) {
    const { loader, infoExt } = this;
    if (loader && [
      "stl"
      /* stl */
    ].includes(infoExt.type)) {
      return loader.parse(buffer);
    }
    throw new Error("un-support loader parse for arraybuffer");
  }
}
class PathLoader extends CommonLoader {
  constructor(path, options) {
    super(path, options);
  }
  load(path, cb = () => {
  }) {
    if (!this.loader) return;
    return super.load(path, cb);
  }
}
class FilePathLoader extends PathLoader {
  constructor(filename, options) {
    super(filename, options);
  }
  load(file, cb = () => {
  }) {
    const url = URL.createObjectURL(file);
    trackFileUrl.add(url);
    return super.load(url, cb);
  }
}
class PLYExporter {
  parse(object, onDone, options = {}) {
    function traverseMeshes(cb) {
      object.traverse(function(child) {
        if (child.isMesh === true || child.isPoints) {
          const mesh = child;
          const geometry = mesh.geometry;
          if (geometry.hasAttribute("position") === true) {
            cb(mesh, geometry);
          }
        }
      });
    }
    const defaultOptions = {
      binary: false,
      excludeAttributes: [],
      // normal, uv, color, index
      littleEndian: false
    };
    options = Object.assign(defaultOptions, options);
    const excludeAttributes = options.excludeAttributes;
    let includeIndices = true;
    let includeNormals = false;
    let includeColors = false;
    let includeUVs = false;
    let vertexCount = 0;
    let faceCount = 0;
    object.traverse(function(child) {
      if (child.isMesh === true) {
        const mesh = child;
        const geometry = mesh.geometry;
        const vertices = geometry.getAttribute("position");
        const normals = geometry.getAttribute("normal");
        const uvs = geometry.getAttribute("uv");
        const colors = geometry.getAttribute("color");
        const indices = geometry.getIndex();
        if (vertices === void 0) {
          return;
        }
        vertexCount += vertices.count;
        faceCount += indices ? indices.count / 3 : vertices.count / 3;
        if (normals !== void 0) includeNormals = true;
        if (uvs !== void 0) includeUVs = true;
        if (colors !== void 0) includeColors = true;
      } else if (child.isPoints) {
        const mesh = child;
        const geometry = mesh.geometry;
        const vertices = geometry.getAttribute("position");
        const normals = geometry.getAttribute("normal");
        const colors = geometry.getAttribute("color");
        vertexCount += vertices.count;
        if (normals !== void 0) includeNormals = true;
        if (colors !== void 0) includeColors = true;
        includeIndices = false;
      }
    });
    const tempColor = new Color();
    includeIndices = includeIndices && excludeAttributes.indexOf("index") === -1;
    includeNormals = includeNormals && excludeAttributes.indexOf("normal") === -1;
    includeColors = includeColors && excludeAttributes.indexOf("color") === -1;
    includeUVs = includeUVs && excludeAttributes.indexOf("uv") === -1;
    if (includeIndices && faceCount !== Math.floor(faceCount)) {
      console.error(
        "PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3."
      );
      return null;
    }
    const indexByteCount = 4;
    let header = `ply
format ${options.binary ? options.littleEndian ? "binary_little_endian" : "binary_big_endian" : "ascii"} 1.0
element vertex ${vertexCount}
property float x
property float y
property float z
`;
    if (includeNormals === true) {
      header += "property float nx\nproperty float ny\nproperty float nz\n";
    }
    if (includeUVs === true) {
      header += "property float s\nproperty float t\n";
    }
    if (includeColors === true) {
      header += "property uchar red\nproperty uchar green\nproperty uchar blue\n";
    }
    if (includeIndices === true) {
      header += `element face ${faceCount}
property list uchar int vertex_index
`;
    }
    header += "end_header\n";
    const vertex2 = new Vector3();
    const normalMatrixWorld = new Matrix3();
    let result = null;
    if (options.binary === true) {
      const headerBin = new TextEncoder().encode(header);
      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));
      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;
      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));
      new Uint8Array(output.buffer).set(headerBin, 0);
      let vOffset = headerBin.length;
      let fOffset = headerBin.length + vertexListLength;
      let writtenVertices = 0;
      traverseMeshes(function(mesh, geometry) {
        const vertices = geometry.getAttribute("position");
        const normals = geometry.getAttribute("normal");
        const uvs = geometry.getAttribute("uv");
        const colors = geometry.getAttribute("color");
        const indices = geometry.getIndex();
        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);
        for (let i = 0, l2 = vertices.count; i < l2; i++) {
          vertex2.fromBufferAttribute(vertices, i);
          vertex2.applyMatrix4(mesh.matrixWorld);
          output.setFloat32(vOffset, vertex2.x, options.littleEndian);
          vOffset += 4;
          output.setFloat32(vOffset, vertex2.y, options.littleEndian);
          vOffset += 4;
          output.setFloat32(vOffset, vertex2.z, options.littleEndian);
          vOffset += 4;
          if (includeNormals === true) {
            if (normals != null) {
              vertex2.fromBufferAttribute(normals, i);
              vertex2.applyMatrix3(normalMatrixWorld).normalize();
              output.setFloat32(vOffset, vertex2.x, options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, vertex2.y, options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, vertex2.z, options.littleEndian);
              vOffset += 4;
            } else {
              output.setFloat32(vOffset, 0, options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, 0, options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, 0, options.littleEndian);
              vOffset += 4;
            }
          }
          if (includeUVs === true) {
            if (uvs != null) {
              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);
              vOffset += 4;
            } else {
              output.setFloat32(vOffset, 0, options.littleEndian);
              vOffset += 4;
              output.setFloat32(vOffset, 0, options.littleEndian);
              vOffset += 4;
            }
          }
          if (includeColors === true) {
            if (colors != null) {
              tempColor.fromBufferAttribute(colors, i);
              ColorManagement.fromWorkingColorSpace(tempColor, SRGBColorSpace);
              output.setUint8(vOffset, Math.floor(tempColor.r * 255));
              vOffset += 1;
              output.setUint8(vOffset, Math.floor(tempColor.g * 255));
              vOffset += 1;
              output.setUint8(vOffset, Math.floor(tempColor.b * 255));
              vOffset += 1;
            } else {
              output.setUint8(vOffset, 255);
              vOffset += 1;
              output.setUint8(vOffset, 255);
              vOffset += 1;
              output.setUint8(vOffset, 255);
              vOffset += 1;
            }
          }
        }
        if (includeIndices === true) {
          if (indices !== null) {
            for (let i = 0, l2 = indices.count; i < l2; i += 3) {
              output.setUint8(fOffset, 3);
              fOffset += 1;
              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);
              fOffset += indexByteCount;
              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);
              fOffset += indexByteCount;
              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);
              fOffset += indexByteCount;
            }
          } else {
            for (let i = 0, l2 = vertices.count; i < l2; i += 3) {
              output.setUint8(fOffset, 3);
              fOffset += 1;
              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);
              fOffset += indexByteCount;
              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);
              fOffset += indexByteCount;
              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);
              fOffset += indexByteCount;
            }
          }
        }
        writtenVertices += vertices.count;
      });
      result = output.buffer;
    } else {
      let writtenVertices = 0;
      let vertexList = "";
      let faceList = "";
      traverseMeshes(function(mesh, geometry) {
        const vertices = geometry.getAttribute("position");
        const normals = geometry.getAttribute("normal");
        const uvs = geometry.getAttribute("uv");
        const colors = geometry.getAttribute("color");
        const indices = geometry.getIndex();
        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);
        for (let i = 0, l2 = vertices.count; i < l2; i++) {
          vertex2.fromBufferAttribute(vertices, i);
          vertex2.applyMatrix4(mesh.matrixWorld);
          let line = vertex2.x + " " + vertex2.y + " " + vertex2.z;
          if (includeNormals === true) {
            if (normals != null) {
              vertex2.fromBufferAttribute(normals, i);
              vertex2.applyMatrix3(normalMatrixWorld).normalize();
              line += " " + vertex2.x + " " + vertex2.y + " " + vertex2.z;
            } else {
              line += " 0 0 0";
            }
          }
          if (includeUVs === true) {
            if (uvs != null) {
              line += " " + uvs.getX(i) + " " + uvs.getY(i);
            } else {
              line += " 0 0";
            }
          }
          if (includeColors === true) {
            if (colors != null) {
              tempColor.fromBufferAttribute(colors, i);
              ColorManagement.fromWorkingColorSpace(tempColor, SRGBColorSpace);
              line += " " + Math.floor(tempColor.r * 255) + " " + Math.floor(tempColor.g * 255) + " " + Math.floor(tempColor.b * 255);
            } else {
              line += " 255 255 255";
            }
          }
          vertexList += line + "\n";
        }
        if (includeIndices === true) {
          if (indices !== null) {
            for (let i = 0, l2 = indices.count; i < l2; i += 3) {
              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;
              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;
              faceList += ` ${indices.getX(i + 2) + writtenVertices}
`;
            }
          } else {
            for (let i = 0, l2 = vertices.count; i < l2; i += 3) {
              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}
`;
            }
          }
          faceCount += indices ? indices.count / 3 : vertices.count / 3;
        }
        writtenVertices += vertices.count;
      });
      result = `${header}${vertexList}${includeIndices ? `${faceList}
` : "\n"}`;
    }
    if (typeof onDone === "function") requestAnimationFrame(() => onDone(result));
    return result;
  }
}
class STLExporter {
  parse(scene, options = {}) {
    options = Object.assign({
      binary: false
    }, options);
    const binary = options.binary;
    const objects = [];
    let triangles = 0;
    scene.traverse(function(object) {
      if (object.isMesh) {
        const geometry = object.geometry;
        const index = geometry.index;
        const positionAttribute = geometry.getAttribute("position");
        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;
        objects.push({
          object3d: object,
          geometry
        });
      }
    });
    let output;
    let offset = 80;
    if (binary === true) {
      const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;
      const arrayBuffer = new ArrayBuffer(bufferLength);
      output = new DataView(arrayBuffer);
      output.setUint32(offset, triangles, true);
      offset += 4;
    } else {
      output = "";
      output += "solid exported\n";
    }
    const vA = new Vector3();
    const vB = new Vector3();
    const vC = new Vector3();
    const cb = new Vector3();
    const ab = new Vector3();
    const normal = new Vector3();
    for (let i = 0, il = objects.length; i < il; i++) {
      const object = objects[i].object3d;
      const geometry = objects[i].geometry;
      const index = geometry.index;
      const positionAttribute = geometry.getAttribute("position");
      if (index !== null) {
        for (let j = 0; j < index.count; j += 3) {
          const a = index.getX(j + 0);
          const b = index.getX(j + 1);
          const c = index.getX(j + 2);
          writeFace(a, b, c, positionAttribute, object);
        }
      } else {
        for (let j = 0; j < positionAttribute.count; j += 3) {
          const a = j + 0;
          const b = j + 1;
          const c = j + 2;
          writeFace(a, b, c, positionAttribute, object);
        }
      }
    }
    if (binary === false) {
      output += "endsolid exported\n";
    }
    return output;
    function writeFace(a, b, c, positionAttribute, object) {
      vA.fromBufferAttribute(positionAttribute, a);
      vB.fromBufferAttribute(positionAttribute, b);
      vC.fromBufferAttribute(positionAttribute, c);
      if (object.isSkinnedMesh === true) {
        object.applyBoneTransform(a, vA);
        object.applyBoneTransform(b, vB);
        object.applyBoneTransform(c, vC);
      }
      vA.applyMatrix4(object.matrixWorld);
      vB.applyMatrix4(object.matrixWorld);
      vC.applyMatrix4(object.matrixWorld);
      writeNormal(vA, vB, vC);
      writeVertex(vA);
      writeVertex(vB);
      writeVertex(vC);
      if (binary === true) {
        output.setUint16(offset, 0, true);
        offset += 2;
      } else {
        output += "		endloop\n";
        output += "	endfacet\n";
      }
    }
    function writeNormal(vA2, vB2, vC2) {
      cb.subVectors(vC2, vB2);
      ab.subVectors(vA2, vB2);
      cb.cross(ab).normalize();
      normal.copy(cb).normalize();
      if (binary === true) {
        output.setFloat32(offset, normal.x, true);
        offset += 4;
        output.setFloat32(offset, normal.y, true);
        offset += 4;
        output.setFloat32(offset, normal.z, true);
        offset += 4;
      } else {
        output += "	facet normal " + normal.x + " " + normal.y + " " + normal.z + "\n";
        output += "		outer loop\n";
      }
    }
    function writeVertex(vertex2) {
      if (binary === true) {
        output.setFloat32(offset, vertex2.x, true);
        offset += 4;
        output.setFloat32(offset, vertex2.y, true);
        offset += 4;
        output.setFloat32(offset, vertex2.z, true);
        offset += 4;
      } else {
        output += "			vertex " + vertex2.x + " " + vertex2.y + " " + vertex2.z + "\n";
      }
    }
  }
}
class DRACOExporter {
  parse(object, options = {}) {
    options = Object.assign({
      decodeSpeed: 5,
      encodeSpeed: 5,
      encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,
      quantization: [16, 8, 8, 8, 8],
      exportUvs: true,
      exportNormals: true,
      exportColor: false,
      exportFlag: false
    }, options);
    if (DracoEncoderModule === void 0) {
      throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");
    }
    const geometry = object.geometry;
    const dracoEncoder = DracoEncoderModule();
    const encoder = new dracoEncoder.Encoder();
    let builder;
    let dracoObject;
    if (object.isMesh === true) {
      builder = new dracoEncoder.MeshBuilder();
      dracoObject = new dracoEncoder.Mesh();
      const vertices = geometry.getAttribute("position");
      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
      const faces = geometry.getIndex();
      if (faces !== null) {
        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);
      } else {
        const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);
        for (let i = 0; i < faces2.length; i++) {
          faces2[i] = i;
        }
        builder.AddFacesToMesh(dracoObject, vertices.count, faces2);
      }
      if (options.exportNormals === true) {
        const normals = geometry.getAttribute("normal");
        if (normals !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);
        }
      }
      if (options.exportUvs === true) {
        const uvs = geometry.getAttribute("uv");
        if (uvs !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);
        }
      }
      if (options.exportColor === true) {
        const colors = geometry.getAttribute("color");
        if (colors !== void 0) {
          const array = createVertexColorSRGBArray(colors);
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, array);
        }
      }
      if (options.exportFlag === true) {
        const flags = geometry.getAttribute("flag");
        if (flags !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.GENERIC, flags.count, flags.itemSize, flags.array);
        }
      }
    } else if (object.isPoints === true) {
      builder = new dracoEncoder.PointCloudBuilder();
      dracoObject = new dracoEncoder.PointCloud();
      const vertices = geometry.getAttribute("position");
      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
      if (options.exportColor === true) {
        const colors = geometry.getAttribute("color");
        if (colors !== void 0) {
          const array = createVertexColorSRGBArray(colors);
          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, array);
        }
      }
    } else {
      throw new Error("DRACOExporter: Unsupported object type.");
    }
    const encodedData = new dracoEncoder.DracoInt8Array();
    const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;
    const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;
    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);
    if (options.encoderMethod !== void 0) {
      encoder.SetEncodingMethod(options.encoderMethod);
    }
    if (options.quantization !== void 0) {
      for (let i = 0; i < 5; i++) {
        if (options.quantization[i] !== void 0) {
          encoder.SetAttributeQuantization(i, options.quantization[i]);
        }
      }
    }
    let length;
    if (object.isMesh === true) {
      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);
    } else {
      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);
    }
    dracoEncoder.destroy(dracoObject);
    if (length === 0) {
      throw new Error("THREE.DRACOExporter: Draco encoding failed.");
    }
    const outputData = new Int8Array(new ArrayBuffer(length));
    for (let i = 0; i < length; i++) {
      outputData[i] = encodedData.GetValue(i);
    }
    dracoEncoder.destroy(encodedData);
    dracoEncoder.destroy(encoder);
    dracoEncoder.destroy(builder);
    return outputData;
  }
}
function createVertexColorSRGBArray(attribute) {
  const _color2 = new Color();
  const count = attribute.count;
  const itemSize = attribute.itemSize;
  const array = new Float32Array(count * itemSize);
  for (let i = 0, il = count; i < il; i++) {
    _color2.fromBufferAttribute(attribute, i);
    ColorManagement.fromWorkingColorSpace(_color2, SRGBColorSpace);
    array[i * itemSize] = _color2.r;
    array[i * itemSize + 1] = _color2.g;
    array[i * itemSize + 2] = _color2.b;
    if (itemSize === 4) {
      array[i * itemSize + 3] = attribute.getW(i);
    }
  }
  return array;
}
DRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;
DRACOExporter.MESH_SEQUENTIAL_ENCODING = 0;
DRACOExporter.POINT_CLOUD = 0;
DRACOExporter.TRIANGULAR_MESH = 1;
DRACOExporter.INVALID = -1;
DRACOExporter.POSITION = 0;
DRACOExporter.NORMAL = 1;
DRACOExporter.COLOR = 2;
DRACOExporter.TEX_COORD = 3;
DRACOExporter.GENERIC = 4;
const mesh2ply = (mesh) => {
  return new Promise((resolve) => {
    const exporter = new PLYExporter();
    exporter.parse(
      mesh,
      (buffer) => {
        resolve(buffer);
      },
      {
        binary: true
      }
    );
  });
};
const mesh2stl = (mesh, { isBinary }) => {
  return new Promise((resolve) => {
    const exporter = new STLExporter();
    resolve(exporter.parse(mesh, { binary: isBinary }));
  });
};
const mesh2drc = (mesh, options = {}) => {
  return new Promise((resolve) => {
    const exporter = new DRACOExporter();
    resolve(exporter.parse(mesh, {
      exportColor: false,
      exportUvs: false,
      exportNormals: false,
      quantization: [14, 8, 8, 8, 8],
      ...options
    }));
  });
};
async function bindDracoEncoder(drcPath) {
  if (!drcPath) drcPath = "/js/libs/draco/draco_encoder.js";
  await fetch(drcPath).then((res) => res.text()).then((txt) => {
    const blob = new Blob([txt], { type: "application/javascript" });
    const blobURL = URL.createObjectURL(blob);
    const scriptElement = document.createElement("script");
    scriptElement.src = blobURL;
    document.head.appendChild(scriptElement);
  });
}
function toLocalFile(arrBuffer, filename) {
  const href = window.URL.createObjectURL(new Blob([arrBuffer], { type: "application/octet-stream" }));
  const tagA = document.createElement("a");
  tagA.href = href;
  tagA.download = filename;
  tagA.click();
  window.URL.revokeObjectURL(href);
}
const ud = {
  boxOfScene: 90,
  // 
  boxOfEditorTarget: 120
};
const cameraViews = {
  anterior: {
    up: [0, 1, 0],
    position: [0, 0, ud.boxOfScene],
    rotation: [0, 0, 0]
  },
  anteriorLeft: {
    up: [0, 1, 0],
    position: [-ud.boxOfScene, 0, 0],
    rotation: [0, MathUtils.degToRad(65), 0]
  },
  anteriorRight: {
    up: [0, 1, 0],
    position: [ud.boxOfScene, 0, 0],
    rotation: [0, MathUtils.degToRad(-65), 0]
  },
  anteriorUpper: {
    up: [0, 0, 1],
    position: [0, -ud.boxOfScene, 0],
    rotation: [MathUtils.degToRad(90), 0, 0]
  },
  anteriorLower: {
    up: [0, 0, -1],
    position: [0, ud.boxOfScene, 0],
    rotation: [MathUtils.degToRad(-90), 0, 0]
  },
  editorJawFront: {
    up: [0, 1, 0],
    position: [0, 0, ud.boxOfEditorTarget],
    rotation: [0, 0, 0]
  },
  editorJawUpper: {
    up: [0, 0, 1],
    position: [0, -ud.boxOfEditorTarget, 0],
    rotation: [MathUtils.degToRad(90), 0, 0]
  },
  editorJawLower: {
    up: [0, 0, -1],
    position: [0, ud.boxOfEditorTarget, 0],
    rotation: [MathUtils.degToRad(-90), 0, 0]
  },
  editorJawRight: {
    up: [0, 1, 0],
    position: [ud.boxOfEditorTarget, 0, 0],
    rotation: [0, MathUtils.degToRad(-65), 0]
  },
  editorJawLeft: {
    up: [0, 1, 0],
    position: [-ud.boxOfEditorTarget, 0, 0],
    rotation: [0, MathUtils.degToRad(65), 0]
  }
};
function viewDir(index) {
  if (index == 1) return cameraViews["anteriorLeft"];
  else if (index == 3) return cameraViews["anteriorRight"];
  else if (index == 4) return cameraViews["anteriorLower"];
  else if (index == 5) return cameraViews["anteriorUpper"];
  return cameraViews["anterior"];
}
function setXYZ(arr, i, x, y, z) {
  arr[i + 0] = x;
  arr[i + 1] = y;
  arr[i + 2] = z;
}
function inMinMax(current, min, max) {
  return Math.min(Math.max(current, min), max);
}
function getVFov(aspect2, hFov) {
  return 2 * Math.atan(Math.tan(hFov / 2) / aspect2);
}
class SwitchCamera extends Camera {
  constructor(cameraAngle = 20) {
    super();
    this.persp = new PerspectiveCamera();
    this.ortho = new OrthographicCamera(-1, 1, 1, -1);
    this.camera = this.persp;
    this.isOrtho = false;
    this.projectionMatrix = new Matrix4();
    this.orthoView = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.perspView = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.fov = Math.PI / 4;
    this.fovMin = Math.PI / 6;
    this.fovMax = Math.PI / 2;
    this.aspect = 1;
    this.near = 0.1;
    this.far = 1e4;
    this.zoom = 1;
    this.zoomMin = Math.PI / 4;
    this.zoomMax = Math.PI;
    this.width = 0;
    this.height = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.tan = Math.atan(cameraAngle / 2 * (Math.PI / 180));
  }
  getCamera() {
    return this.camera;
  }
  switch(control) {
    if (this.isOrtho) {
      this.toPerspective();
      this.isOrtho = false;
      this.camera = this.persp;
    } else {
      this.toOrthographic(control);
      this.isOrtho = true;
      this.camera = this.ortho;
    }
    if (control) control.object = this.camera;
  }
  toOrthographic(control) {
    const { persp, ortho, tan } = this;
    const distance = persp.position.distanceTo(control.target);
    let halfHeight = tan * distance;
    let halfWidth = halfHeight * persp.aspect;
    ortho.top = halfHeight;
    ortho.bottom = -halfHeight;
    ortho.left = -halfWidth;
    ortho.right = halfWidth;
    ortho.zoom = 1;
    ortho.lookAt(control.target);
    this.syncCameraPosture(true);
    ortho.updateProjectionMatrix();
  }
  toPerspective() {
    const { persp, ortho, tan } = this;
    this.syncCameraPosture(false);
    let frustumHeight = (ortho.top - ortho.bottom) / ortho.zoom;
    let halfHeight = frustumHeight / 2;
    let distance = halfHeight / tan;
    persp.position.copy(ortho.position).normalize().multiplyScalar(distance);
    persp.updateProjectionMatrix();
  }
  syncCameraPosture(toOrtho) {
    const { persp, ortho } = this;
    if (toOrtho) {
      ortho.position.copy(persp.position);
      ortho.quaternion.copy(persp.quaternion);
      ortho.scale.copy(persp.scale);
      ortho.up.copy(persp.up);
      ortho.updateMatrix();
      ortho.updateMatrixWorld();
    } else {
      persp.position.copy(ortho.position);
      persp.quaternion.copy(ortho.quaternion);
      persp.scale.copy(ortho.scale);
      persp.up.copy(ortho.up);
      persp.updateMatrix();
      persp.updateMatrixWorld();
    }
  }
  getWorldCameraPosition() {
    const { position, quaternion } = this.camera;
    const pos = position.clone();
    const quat = quaternion.clone();
    quat.invert();
    pos.applyQuaternion(quat);
    return pos;
  }
  getOrthoViewWidth(mat) {
    const w = mat.elements[0], x = mat.elements[12];
    const left = -(x + 1) / w;
    const right = (1 - x) / w;
    return right - left;
  }
  getCurrentViewportWidth() {
    const { tan } = this;
    const { near, far, zoom } = this.ortho;
    const { aspect: aspect2 } = this.persp;
    const wCameraPos = this.getWorldCameraPosition();
    const height = tan * wCameraPos.z;
    const width = height * aspect2;
    const projectionMatrix = new Matrix4();
    projectionMatrix.makeOrthographic(-width, width, height, -height, near, far);
    const vpWidth = this.getOrthoViewWidth(projectionMatrix) / zoom;
    return vpWidth;
  }
  updateViewDir(code) {
    const { camera } = this;
    const data = viewDir(code);
    camera.lookAt(0, 0, 0);
    camera.up.set(0, 1, 0);
    camera.quaternion.identity();
    camera.scale.set(1, 1, 1);
    camera.up.set(data.up[0], data.up[1], data.up[2]);
    camera.rotation.set(data.rotation[0], data.rotation[1], data.rotation[2]);
    camera.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const { isOrtho, orthoView: ov, perspView: pv, near, far } = this;
    if (isOrtho) {
      this.updateOrthoView();
      this.projectionMatrix.makeOrthographic(ov.left, ov.right, ov.top, ov.bottom, near, far);
    } else {
      this.updatePerspView();
      this.projectionMatrix.makePerspective(pv.left, pv.right, pv.top, pv.bottom, near, far);
    }
  }
  updateOrthoView() {
    const { fov: fov2, aspect: aspect2, orthoView } = this;
    const wCameraPos = this.getWorldCameraPosition();
    const halfHeight = Math.tan(fov2 / 2) * wCameraPos.z;
    const halfWidth = halfHeight * aspect2;
    orthoView.left = -halfWidth;
    orthoView.right = halfWidth;
    orthoView.top = halfHeight;
    orthoView.bottom = -halfHeight;
  }
  updatePerspView() {
    const { fov: fov2, near, aspect: aspect2, perspView, offsetX, offsetY } = this;
    const tan = Math.tan(fov2 / 2), halfHeight = near * tan, height = 2 * halfHeight, width = aspect2 * height, left = -0.5 * width * (1 + offsetX);
    perspView.left = left;
    perspView.right = left + width;
    perspView.top = halfHeight * (1 + offsetY) - height;
    perspView.bottom = halfHeight * (1 + offsetY);
  }
  updateCameraInfo() {
    this.updateProjectionMatrix();
  }
  setClip(near, far) {
    this.near = near;
    this.far = far;
    this.updateCameraInfo();
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.aspect = width / height;
    this.updateCameraInfo();
  }
  setAspect(aspect2) {
    if (Number.isNaN(aspect2))
      throw new Error("Camera has incorrect aspect");
    this.aspect = aspect2;
    this.updateCameraInfo();
  }
  resize(width, height) {
    this.setSize(width, height);
  }
  setZoom(zoom) {
    this.zoom = inMinMax(zoom, this.zoomMin, this.zoomMax);
    this.dispatchEvent({ type: "zoomChanged" });
  }
  updateFov(fov2) {
    const hFov = getVFov(this.aspect, fov2);
    this.fov = inMinMax(hFov, this.fovMin, this.fovMax);
  }
}
function linearInterpolate(begin, end, percentage) {
  return begin + percentage * (end - begin);
}
function toTypedArray(t, e) {
  const n = new t(e.length);
  e.forEach((t2, e2) => n[e2] = t2);
  return n;
}
class Plane2 {
  constructor(origin, normal) {
    this.origin = origin;
    this.normal = normal;
  }
}
class BasePath {
  constructor(hasHead = true, hasTail = true) {
    this.hasHead = hasHead;
    this.hasTail = hasTail;
  }
  getSteps(begin, end, n, offset, options = {}) {
    const r = this.getSegmentPoints(begin, end, n, offset, options), i = [];
    for (let a = 0; a < r.length - 1; a++) i.push({ a: r[a], b: r[a + 1], i: a });
    return i;
  }
  getSegmentPoints(begin, end, n, offset, options = {}) {
    let showTail = true, showHead = true;
    if (typeof options.showTail == "boolean") showTail = options.showTail;
    if (typeof options.showHead == "boolean") showHead = options.showHead;
    const a = [], s2 = 1e-5, c = [
      new Vector3(0, s2, 1),
      new Vector3(s2, s2, 0),
      new Vector3(0.99997, n, 0),
      new Vector3(0.99998, n, -1),
      new Vector3(1 - s2, 1, -1)
    ], l2 = [...c].reverse(), iterateTotal = this.getIterations(end - begin);
    if (showHead && 0 !== offset) {
      for (const o of c) a.push({
        p: begin + o.x * offset,
        r: o.y,
        tangent: o.z
      });
    }
    const d = 0 !== offset ? 1 : 3;
    for (let o = 0; o <= iterateTotal; o++) {
      a.push({
        p: linearInterpolate(begin + offset, end - offset, o / iterateTotal),
        r: d
      });
    }
    if (showTail && 0 !== offset) {
      for (const o of l2) a.push({
        p: end - o.x * offset,
        r: o.y,
        tangent: -o.z
      });
    }
    return a;
  }
  getIterations(times) {
    if (!times) return 1;
    return 1;
  }
  getPointAt(e) {
    return {
      point: new Vector3(),
      tangent: new Vector3()
    };
  }
  getPathNormal() {
    return new Vector3();
  }
}
class Arc extends BasePath {
  constructor(plane, radius, start) {
    super();
    this.plane = plane;
    this.radius = radius;
    this.start = start;
  }
  getPoints(t) {
    const e = this.getBasis(), { normal, origin } = this.plane, i = [], a = 2 * Math.PI;
    for (let s2 = 0; s2 < t; ++s2) {
      const c = new Vector3(), l2 = s2 / t;
      c.add(e.x.clone().multiplyScalar(this.radius * Math.cos(l2 * a))), c.add(e.y.clone().multiplyScalar(this.radius * Math.sin(l2 * a)));
      const u = new Vector3().crossVectors(c, e.z).normalize();
      i.push({
        point: c.clone().add(origin),
        tangent: u,
        normal,
        pointNormal: c.clone()
      });
    }
    return i;
  }
  getIterations(t) {
    const e = Math.abs(t) / (2 * Math.PI);
    return Math.floor(60 * e);
  }
  getPathNormal() {
    return this.plane.normal;
  }
  getPointAt(t) {
    const e = this.getBasis(), n = this.getCirclePoint(t, this.radius), r = new Vector3().crossVectors(e.z, n.clone().sub(this.plane.origin)).normalize();
    return { point: n, tangent: r };
  }
  getBasis() {
    const { normal: t } = this.plane;
    if (this.start) {
      const e = this.start.clone(), n = t.clone();
      return { x: e, y: new Vector3().crossVectors(e, n).normalize(), z: n };
    }
    const z = new Vector3(0, 0, 1), y = new Vector3(0, 1, 0), x = new Vector3(1, 0, 0), i = t.angleTo(z), a = new Vector3().crossVectors(t, z).normalize();
    y.applyAxisAngle(a, -i), x.applyAxisAngle(a, -i), z.applyAxisAngle(a, -i);
    return { x, y, z };
  }
  getCirclePoint(t, e) {
    const n = this.getBasis(), r = new Vector3();
    return r.add(n.x.clone().multiplyScalar(e * Math.cos(t))), r.add(n.y.clone().multiplyScalar(e * Math.sin(t))), r;
  }
}
class Ray2 extends BasePath {
  constructor(origin, ray2, planeNormal) {
    super();
    this.origin = origin;
    this.ray = ray2;
    this.planeNormal = planeNormal;
  }
  getPathNormal() {
    return this.planeNormal;
  }
  getPointAt(length) {
    const dir = this.ray.clone();
    return {
      point: this.origin.clone().add(dir.clone().multiplyScalar(length)),
      tangent: dir.multiplyScalar(-1)
    };
  }
  getIterations() {
    return 2;
  }
}
function l(point, points) {
  const n = function(t, e) {
    const [n2, o, r] = e.map((t2) => t2.clone());
    o.sub(n2);
    r.sub(n2);
    o.multiplyScalar(1 / 3);
    r.multiplyScalar(1 / 3);
    n2.add(o).add(r);
    return n2.sub(t);
  }(point, points).normalize(), planeNormal = function(t) {
    const [e, n2, r] = t.map((t2) => t2.clone());
    n2.sub(e);
    r.sub(e);
    return new Vector3().crossVectors(n2, r).normalize();
  }(points);
  return n.dot(planeNormal);
}
const s = Math.PI;
class ArrowOnPathGeometry extends BufferGeometry {
  constructor(ray2, begin, end, radius, total, d = 2, offset = s / 4, options = {}) {
    const cache = {}, arrPosition = [], arrNormal = [];
    let g = 0;
    const index = [], b = ray2.getSteps(begin, end, d, offset, options);
    for (const o of b) {
      const e = [o.a, o.b], [n, i] = e.map((e2) => {
        const { point, tangent } = ray2.getPointAt(e2.p), i2 = ray2.getPathNormal();
        return new Arc(new Plane2(point, tangent), radius * e2.r, i2.clone()).getPoints(Math.max(3, total));
      }), [s2] = e.map((e2) => ray2.getPointAt(e2.p));
      for (let t = 0; t < total; ++t) {
        const e2 = (t + 1) % total, r = w(
          o.i,
          t,
          n[t].point.clone(),
          o.a.tangent ? s2.tangent.clone().multiplyScalar(o.a.tangent) : n[t].pointNormal.clone().normalize()
        ), a = w(
          o.i + 1,
          t,
          i[t].point.clone(),
          o.b.tangent ? s2.tangent.clone().multiplyScalar(o.b.tangent) : n[t].pointNormal.clone().normalize()
        ), c = w(
          o.i + 1,
          e2,
          i[e2].point.clone(),
          o.b.tangent ? s2.tangent.clone().multiplyScalar(o.b.tangent) : n[e2].pointNormal.clone().normalize()
        ), l2 = w(
          o.i,
          e2,
          n[e2].point.clone(),
          o.a.tangent ? s2.tangent.clone().multiplyScalar(o.a.tangent) : n[e2].pointNormal.clone().normalize()
        );
        y(index, r, a, c, s2.point);
        y(index, r, c, l2, s2.point);
      }
    }
    function y(index2, e, n, r, i) {
      const a = [e, n, r].map((t) => new Vector3(...arrPosition.slice(3 * t, 3 * t + 3)));
      l(i.clone(), a) > 0 ? index2.push(e, n, r) : index2.push(e, r, n);
    }
    function w(t, e, n, o) {
      const key = `${t},${e}`;
      if (!cache[key]) {
        arrPosition.push(n.x);
        arrPosition.push(n.y);
        arrPosition.push(n.z);
        arrNormal.push(o.x);
        arrNormal.push(o.y);
        arrNormal.push(o.z);
        cache[key] = g;
        g++;
      }
      return cache[key];
    }
    const A = toTypedArray(Float32Array, arrPosition), x = toTypedArray(Float32Array, arrNormal), S = toTypedArray(Uint32Array, index);
    super();
    this.setAttribute("position", new BufferAttribute(A, 3)), this.setAttribute("normal", new BufferAttribute(x, 3, true)), this.setAttribute("tangent", new BufferAttribute(x, 3, true)), this.setAttribute("uv", new BufferAttribute(new Float32Array(A.length / 3 * 2), 2)), this.setIndex(new BufferAttribute(S, 1));
  }
}
class AxesArrow extends Object3D {
  constructor(size = 0.035, radius = 2e-4, options = {}) {
    super();
    this.size = size;
    this.radius = radius;
    const scaleFactor = options.textScaleFactor || radius;
    const xOptions = Object.assign(Object.assign({}, options), {
      color: "#ff0000",
      label: "+x",
      showTail: true,
      showHead: false,
      scaleFactor
    });
    this.add(this.newAxis(xOptions));
    const yOptions = Object.assign(Object.assign({}, options), {
      color: "#00ff00",
      label: "+y",
      showTail: false,
      showHead: true,
      scaleFactor
    });
    this.add(this.newAxis(yOptions));
    const zOptions = Object.assign(Object.assign({}, options), {
      color: "#0000ff",
      label: "+z",
      showTail: true,
      showHead: false,
      scaleFactor
    });
    this.add(this.newAxis(zOptions));
  }
  newAxis(options = {}) {
    const { size, radius } = this;
    const color = options.color || "#00ff00";
    const label = options.label || "+x";
    const offset = radius * 7000000000000001e-19 / 2e-4, n = new Ray2(new Vector3(0, 0, -175e-5), new Vector3(0, 0, 1), new Vector3(1, 0, 0)), geo = new ArrowOnPathGeometry(n, -size, size, radius, 10, 1.7, offset, options);
    const arrow = new Mesh(geo, new MeshBasicMaterial({ color, side: DoubleSide }));
    arrow.scale.set(100, 100, 100);
    arrow.position.set(0, 0, 0);
    if (label == "+x") {
      arrow.rotateOnAxis(new Vector3(0, 1, 0), Math.PI / 2);
    } else if (label == "+y") {
      arrow.rotateOnAxis(new Vector3(1, 0, 0), Math.PI / 2);
    } else ;
    return arrow;
  }
}
const _changeEvent = { type: "change" };
const _startEvent = { type: "start" };
const _endEvent = { type: "end" };
const _EPS = 1e-6;
const _STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };
const _v2 = new Vector2();
const _mouseChange = new Vector2();
const _objectUp = new Vector3();
const _pan = new Vector3();
const _axis = new Vector3();
const _quaternion = new Quaternion();
const _eyeDirection = new Vector3();
const _objectUpDirection = new Vector3();
const _objectSidewaysDirection = new Vector3();
const _moveDirection = new Vector3();
class TrackballControls extends Controls {
  constructor(object, domElement = null) {
    super(object, domElement);
    this.enabled = true;
    this.screen = { left: 0, top: 0, width: 0, height: 0 };
    this.rotateSpeed = 1;
    this.zoomSpeed = 1.2;
    this.panSpeed = 0.3;
    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ];
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.state = _STATE.NONE;
    this.keyState = _STATE.NONE;
    this.target = new Vector3();
    this._lastPosition = new Vector3();
    this._lastZoom = 1;
    this._touchZoomDistanceStart = 0;
    this._touchZoomDistanceEnd = 0;
    this._lastAngle = 0;
    this._eye = new Vector3();
    this._movePrev = new Vector2();
    this._moveCurr = new Vector2();
    this._lastAxis = new Vector3();
    this._zoomStart = new Vector2();
    this._zoomEnd = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._pointers = [];
    this._pointerPositions = {};
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this._onPointerCancel = onPointerCancel.bind(this);
    this._onContextMenu = onContextMenu.bind(this);
    this._onMouseWheel = onMouseWheel.bind(this);
    this._onKeyDown = onKeyDown.bind(this);
    this._onKeyUp = onKeyUp.bind(this);
    this._onTouchStart = onTouchStart.bind(this);
    this._onTouchMove = onTouchMove.bind(this);
    this._onTouchEnd = onTouchEnd.bind(this);
    this._onMouseDown = onMouseDown.bind(this);
    this._onMouseMove = onMouseMove.bind(this);
    this._onMouseUp = onMouseUp.bind(this);
    this._target0 = this.target.clone();
    this._position0 = this.object.position.clone();
    this._up0 = this.object.up.clone();
    this._zoom0 = this.object.zoom;
    if (domElement !== null) {
      this.connect();
      this.handleResize();
    }
    this.update();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown);
    window.addEventListener("keyup", this._onKeyUp);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerCancel);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown);
    window.removeEventListener("keyup", this._onKeyUp);
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerCancel);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  handleResize() {
    const box = this.domElement.getBoundingClientRect();
    const d = this.domElement.ownerDocument.documentElement;
    this.screen.left = box.left + window.pageXOffset - d.clientLeft;
    this.screen.top = box.top + window.pageYOffset - d.clientTop;
    this.screen.width = box.width;
    this.screen.height = box.height;
  }
  update() {
    this._eye.subVectors(this.object.position, this.target);
    if (!this.noRotate) {
      this._rotateCamera();
    }
    if (!this.noZoom) {
      this._zoomCamera();
    }
    if (!this.noPan) {
      this._panCamera();
    }
    this.object.position.addVectors(this.target, this._eye);
    if (this.object.isPerspectiveCamera) {
      this._checkDistances();
      this.object.lookAt(this.target);
      if (this._lastPosition.distanceToSquared(this.object.position) > _EPS) {
        this.dispatchEvent(_changeEvent);
        this._lastPosition.copy(this.object.position);
      }
    } else if (this.object.isOrthographicCamera) {
      this.object.lookAt(this.target);
      if (this._lastPosition.distanceToSquared(this.object.position) > _EPS || this._lastZoom !== this.object.zoom) {
        this.dispatchEvent(_changeEvent);
        this._lastPosition.copy(this.object.position);
        this._lastZoom = this.object.zoom;
      }
    } else {
      console.warn("THREE.TrackballControls: Unsupported camera type.");
    }
  }
  reset() {
    this.state = _STATE.NONE;
    this.keyState = _STATE.NONE;
    this.target.copy(this._target0);
    this.object.position.copy(this._position0);
    this.object.up.copy(this._up0);
    this.object.zoom = this._zoom0;
    this.object.updateProjectionMatrix();
    this._eye.subVectors(this.object.position, this.target);
    this.object.lookAt(this.target);
    this.dispatchEvent(_changeEvent);
    this._lastPosition.copy(this.object.position);
    this._lastZoom = this.object.zoom;
  }
  _panCamera() {
    _mouseChange.copy(this._panEnd).sub(this._panStart);
    if (_mouseChange.lengthSq()) {
      if (this.object.isOrthographicCamera) {
        const scale_x = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth;
        const scale_y = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
        _mouseChange.x *= scale_x;
        _mouseChange.y *= scale_y;
      }
      _mouseChange.multiplyScalar(this._eye.length() * this.panSpeed);
      _pan.copy(this._eye).cross(this.object.up).setLength(_mouseChange.x);
      _pan.add(_objectUp.copy(this.object.up).setLength(_mouseChange.y));
      this.object.position.add(_pan);
      this.target.add(_pan);
      if (this.staticMoving) {
        this._panStart.copy(this._panEnd);
      } else {
        this._panStart.add(_mouseChange.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
      }
    }
  }
  _rotateCamera() {
    _moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
    let angle = _moveDirection.length();
    if (angle) {
      this._eye.copy(this.object.position).sub(this.target);
      _eyeDirection.copy(this._eye).normalize();
      _objectUpDirection.copy(this.object.up).normalize();
      _objectSidewaysDirection.crossVectors(_objectUpDirection, _eyeDirection).normalize();
      _objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);
      _objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);
      _moveDirection.copy(_objectUpDirection.add(_objectSidewaysDirection));
      _axis.crossVectors(_moveDirection, this._eye).normalize();
      angle *= this.rotateSpeed;
      _quaternion.setFromAxisAngle(_axis, angle);
      this._eye.applyQuaternion(_quaternion);
      this.object.up.applyQuaternion(_quaternion);
      this._lastAxis.copy(_axis);
      this._lastAngle = angle;
    } else if (!this.staticMoving && this._lastAngle) {
      this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor);
      this._eye.copy(this.object.position).sub(this.target);
      _quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);
      this._eye.applyQuaternion(_quaternion);
      this.object.up.applyQuaternion(_quaternion);
    }
    this._movePrev.copy(this._moveCurr);
  }
  _zoomCamera() {
    let factor;
    if (this.state === _STATE.TOUCH_ZOOM_PAN) {
      factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;
      this._touchZoomDistanceStart = this._touchZoomDistanceEnd;
      if (this.object.isPerspectiveCamera) {
        this._eye.multiplyScalar(factor);
      } else if (this.object.isOrthographicCamera) {
        this.object.zoom = MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);
        if (this._lastZoom !== this.object.zoom) {
          this.object.updateProjectionMatrix();
        }
      } else {
        console.warn("THREE.TrackballControls: Unsupported camera type");
      }
    } else {
      factor = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed;
      if (factor !== 1 && factor > 0) {
        if (this.object.isPerspectiveCamera) {
          this._eye.multiplyScalar(factor);
        } else if (this.object.isOrthographicCamera) {
          this.object.zoom = MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);
          if (this._lastZoom !== this.object.zoom) {
            this.object.updateProjectionMatrix();
          }
        } else {
          console.warn("THREE.TrackballControls: Unsupported camera type");
        }
      }
      if (this.staticMoving) {
        this._zoomStart.copy(this._zoomEnd);
      } else {
        this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;
      }
    }
  }
  _getMouseOnScreen(pageX, pageY) {
    _v2.set(
      (pageX - this.screen.left) / this.screen.width,
      (pageY - this.screen.top) / this.screen.height
    );
    return _v2;
  }
  _getMouseOnCircle(pageX, pageY) {
    _v2.set(
      (pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
      (this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width
      // screen.width intentional
    );
    return _v2;
  }
  _addPointer(event) {
    this._pointers.push(event);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i].pointerId == event.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
    }
  }
  _trackPointer(event) {
    let position = this._pointerPositions[event.pointerId];
    if (position === void 0) {
      position = new Vector2();
      this._pointerPositions[event.pointerId] = position;
    }
    position.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointer = event.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointer.pointerId];
  }
  _checkDistances() {
    if (!this.noZoom || !this.noPan) {
      if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {
        this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance));
        this._zoomStart.copy(this._zoomEnd);
      }
      if (this._eye.lengthSq() < this.minDistance * this.minDistance) {
        this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance));
        this._zoomStart.copy(this._zoomEnd);
      }
    }
  }
}
function onPointerDown(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchEnd(event);
  } else {
    this._onMouseUp();
  }
  this._removePointer(event);
  if (this._pointers.length === 0) {
    this.domElement.releasePointerCapture(event.pointerId);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
  }
}
function onPointerCancel(event) {
  this._removePointer(event);
}
function onKeyUp() {
  if (this.enabled === false) return;
  this.keyState = _STATE.NONE;
  window.addEventListener("keydown", this._onKeyDown);
}
function onKeyDown(event) {
  if (this.enabled === false) return;
  window.removeEventListener("keydown", this._onKeyDown);
  if (this.keyState !== _STATE.NONE) {
    return;
  } else if (event.code === this.keys[_STATE.ROTATE] && !this.noRotate) {
    this.keyState = _STATE.ROTATE;
  } else if (event.code === this.keys[_STATE.ZOOM] && !this.noZoom) {
    this.keyState = _STATE.ZOOM;
  } else if (event.code === this.keys[_STATE.PAN] && !this.noPan) {
    this.keyState = _STATE.PAN;
  }
}
function onMouseDown(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      this.state = _STATE.ZOOM;
      break;
    case MOUSE.ROTATE:
      this.state = _STATE.ROTATE;
      break;
    case MOUSE.PAN:
      this.state = _STATE.PAN;
      break;
    default:
      this.state = _STATE.NONE;
  }
  const state = this.keyState !== _STATE.NONE ? this.keyState : this.state;
  if (state === _STATE.ROTATE && !this.noRotate) {
    this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
    this._movePrev.copy(this._moveCurr);
  } else if (state === _STATE.ZOOM && !this.noZoom) {
    this._zoomStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));
    this._zoomEnd.copy(this._zoomStart);
  } else if (state === _STATE.PAN && !this.noPan) {
    this._panStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));
    this._panEnd.copy(this._panStart);
  }
  this.dispatchEvent(_startEvent);
}
function onMouseMove(event) {
  const state = this.keyState !== _STATE.NONE ? this.keyState : this.state;
  if (state === _STATE.ROTATE && !this.noRotate) {
    this._movePrev.copy(this._moveCurr);
    this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
  } else if (state === _STATE.ZOOM && !this.noZoom) {
    this._zoomEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));
  } else if (state === _STATE.PAN && !this.noPan) {
    this._panEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));
  }
}
function onMouseUp() {
  this.state = _STATE.NONE;
  this.dispatchEvent(_endEvent);
}
function onMouseWheel(event) {
  if (this.enabled === false) return;
  if (this.noZoom === true) return;
  event.preventDefault();
  switch (event.deltaMode) {
    case 2:
      this._zoomStart.y -= event.deltaY * 0.025;
      break;
    case 1:
      this._zoomStart.y -= event.deltaY * 0.01;
      break;
    default:
      this._zoomStart.y -= event.deltaY * 25e-5;
      break;
  }
  this.dispatchEvent(_startEvent);
  this.dispatchEvent(_endEvent);
}
function onContextMenu(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function onTouchStart(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      this.state = _STATE.TOUCH_ROTATE;
      this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY));
      this._movePrev.copy(this._moveCurr);
      break;
    default:
      this.state = _STATE.TOUCH_ZOOM_PAN;
      const dx = this._pointers[0].pageX - this._pointers[1].pageX;
      const dy = this._pointers[0].pageY - this._pointers[1].pageY;
      this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
      const x = (this._pointers[0].pageX + this._pointers[1].pageX) / 2;
      const y = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
      this._panStart.copy(this._getMouseOnScreen(x, y));
      this._panEnd.copy(this._panStart);
      break;
  }
  this.dispatchEvent(_startEvent);
}
function onTouchMove(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      this._movePrev.copy(this._moveCurr);
      this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
      break;
    default:
      const position = this._getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
      const x = (event.pageX + position.x) / 2;
      const y = (event.pageY + position.y) / 2;
      this._panEnd.copy(this._getMouseOnScreen(x, y));
      break;
  }
}
function onTouchEnd(event) {
  switch (this._pointers.length) {
    case 0:
      this.state = _STATE.NONE;
      break;
    case 1:
      this.state = _STATE.TOUCH_ROTATE;
      this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
      this._movePrev.copy(this._moveCurr);
      break;
    case 2:
      this.state = _STATE.TOUCH_ZOOM_PAN;
      for (let i = 0; i < this._pointers.length; i++) {
        if (this._pointers[i].pointerId !== event.pointerId) {
          const position = this._pointerPositions[this._pointers[i].pointerId];
          this._moveCurr.copy(this._getMouseOnCircle(position.x, position.y));
          this._movePrev.copy(this._moveCurr);
          break;
        }
      }
      break;
  }
  this.dispatchEvent(_endEvent);
}
var eColorState = /* @__PURE__ */ ((eColorState2) => {
  eColorState2[eColorState2["backwards"] = 0] = "backwards";
  eColorState2[eColorState2["currently"] = 1] = "currently";
  return eColorState2;
})(eColorState || {});
class MqRender {
  constructor(name, cState) {
    this.renderName = name;
    this.colorState = cState;
    if (cState == 0) {
      ColorManagement.enabled = false;
    } else {
      ColorManagement.enabled = true;
    }
    this.options = {};
    this.rc = {
      width: 0,
      height: 0,
      dpr: window.devicePixelRatio
    };
    this.callbackId = 0;
    this.track = new TrackerResource();
    this.scene = new Scene();
    this.group = new Group();
    this.group.name = "group";
    this.scene.add(this.group);
    this.scene2 = new Scene();
    this.group2 = new Group();
    this.group2.name = "group2";
    this.scene2.add(this.group2);
    this.sceneOrtho = new Scene();
    this.cameraNear = 10;
    this.cameraFar = 1e4;
    this.cameraAngle = 25;
    this.cameraAngle = 20;
    this.cameraOrtho = new OrthographicCamera(-1, 1, 1, -1, this.cameraNear, this.cameraFar);
    this.cameraOrtho.position.z = 10;
    this.tan = Math.atan(this.cameraAngle / 2 * (Math.PI / 180));
    this.camera = new SwitchCamera(this.cameraAngle);
    this.handler4Before = [];
    this.handler4After = [];
  }
  init(options) {
    const { rc } = this;
    this.options = options;
    this.options.cameraPositionZ = options.cameraPositionZ || 90;
    if (options.cameraNear) this.cameraNear = options.cameraNear;
    rc.width = options.width;
    rc.height = options.height;
    if (options.devicePixelRatio) rc.dpr = options.devicePixelRatio;
    if (options.container instanceof HTMLElement) {
      const optionRender = options.renderOption || {
        antialias: true,
        alpha: true,
        precision: "highp"
      };
      if (options.container instanceof HTMLCanvasElement) {
        optionRender.canvas = options.container;
        this.renderer = new WebGLRenderer(optionRender);
      } else {
        this.renderer = new WebGLRenderer(optionRender);
        options.container.appendChild(this.renderer.domElement);
      }
      this.renderer.outputColorSpace = SRGBColorSpace;
      this.renderer.setClearColor(new Color(options.clearColor || 16777215), 1);
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.autoClear = false;
      if (options.useShadow) {
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = PCFSoftShadowMap;
      }
      this.renderer.domElement.addEventListener("webglcontextlost", (event) => {
      });
    } else {
      throw new Error("container is not a HTMLElement or Canvas");
    }
  }
  initControl(camera) {
    const { renderer, options } = this;
    const optControl = options.optionControl || {};
    let enableZoom = true, enablePan = true, enableRotate = true;
    let speedZoom = 1.2, speedPan = 3.5, speedRotate = 2;
    if (typeof optControl.enableZoom == "boolean") enableZoom = optControl.enableZoom;
    if (typeof optControl.enablePan == "boolean") enablePan = optControl.enablePan;
    if (typeof optControl.enableRotate == "boolean") enableRotate = optControl.enableRotate;
    if (optControl.speedZoom) speedZoom = optControl.speedZoom;
    if (optControl.speedPan) speedPan = optControl.speedPan;
    if (optControl.speedRotate) speedRotate = optControl.speedRotate;
    const { domElement } = renderer;
    const control = new TrackballControls(camera, domElement);
    control.zoomSpeed = speedZoom;
    control.panSpeed = speedPan;
    control.rotateSpeed = speedRotate;
    control.noZoom = !enableZoom;
    control.noPan = !enablePan;
    control.noRotate = !enableRotate;
    control.staticMoving = true;
    control.keys = ["65", "83", "68"];
    control.target.set(0, 0, 0);
    control.minZoom = 0.01;
    control.maxZoom = 90;
    this.control = control;
    if (this.control.screen.width < 1 || this.control.screen.height < 1) {
      this.control.handleResize();
    }
  }
  dispose() {
    cancelAnimationFrame(this.callbackId);
  }
  updateFrame() {
  }
  getBox(theScene) {
    function getBoundingBox(root, bbx2) {
      if (root.geometry && root) {
        root.geometry.computeBoundingBox();
        bbx2.union(root.geometry.boundingBox);
      } else {
        root.children.forEach((e) => getBoundingBox(e, bbx2));
      }
    }
    const box3 = new Box3();
    const bbx = this.track.track(box3);
    const size = new Vector3();
    const center = new Vector3();
    getBoundingBox(theScene, bbx);
    bbx.getSize(size);
    bbx.getCenter(center);
    return {
      size,
      center,
      box3
    };
  }
  setAxes(size, radius = 0.01, axesOptions = {}) {
    var _a;
    const { scene, scene2, track, options, renderName } = this;
    const axes = new AxesArrow(size, radius, axesOptions);
    axes.name = "axesHelper";
    if (renderName == "editor-solution") {
      if (!scene.getObjectByName(axes.name)) {
        scene.add(axes);
        track.track(axes);
      }
      if (options.twoScene) {
        const axes2 = axes.clone();
        if (!scene2.getObjectByName(axes2.name)) {
          scene2.add(axes2);
          track.track(axes2);
        }
      }
    } else if (renderName == "multi-view-render") {
      (_a = options.viewStateList) == null ? void 0 : _a.forEach((view, i) => {
        var _a2;
        (_a2 = view.scene) == null ? void 0 : _a2.add(i == 0 ? axes : axes.clone());
      });
    }
    this.updateFrame();
  }
  debugExportMesh(mesh, name) {
    mesh2stl(mesh.clone(), { isBinary: true }).then((buffer) => toLocalFile(buffer, `${name}.stl`));
  }
  getScene(index = 0) {
    const { viewStateList } = this.options;
    if (viewStateList.length > 0) {
      return viewStateList[index].scene;
    }
    return this.scene;
  }
  updateVisitGroup(cb, options = {}) {
    var _a;
    const { group, group2, options: selfOptions, renderName } = this;
    if (renderName == "editor-solution") {
      group.children.forEach((m) => cb(m, { id: 1 }));
      if (selfOptions.twoScene) {
        group2.children.forEach((m) => cb(m, { id: 2 }));
      }
    } else if (renderName == "multi-view-render") {
      (_a = selfOptions.viewStateList) == null ? void 0 : _a.forEach((view) => {
        var _a2;
        (_a2 = view.scene) == null ? void 0 : _a2.children.forEach((m) => {
          cb(m, view);
        });
      });
    }
  }
  oneFrame(theCamera) {
    const {
      rc,
      options,
      renderer,
      camera,
      sceneOrtho,
      cameraOrtho,
      meshGrid,
      labelUnit,
      handler4Before,
      handler4After
    } = this;
    const { width: fullWidth, height: fullHeight } = rc;
    const { viewStateList } = options;
    if (viewStateList && renderer) {
      const countViews = viewStateList.length;
      handler4Before.forEach((e) => e());
      for (let i = 0; i < countViews; i++) {
        const view = viewStateList[i];
        const left = Math.floor(fullWidth * view.left);
        const bottom = Math.floor(fullHeight * view.bottom);
        const width = Math.floor(fullWidth * view.width);
        const height = Math.floor(fullHeight * view.height);
        if (view.scene) {
          const option1 = {
            left,
            bottom,
            width,
            height,
            view,
            index: i,
            total: countViews
          };
          if (view.updateCamera) {
            view.updateCamera(theCamera, view.scene, cameraOrtho, option1);
          } else {
            localUpdateCamera(theCamera, view.scene, cameraOrtho, option1);
          }
          renderer.setViewport(left, bottom, width, height);
          renderer.setScissor(left, bottom, width, height);
          renderer.setScissorTest(true);
          renderer.setClearColor(view.clearColor);
          renderer.render(view.scene, theCamera);
          if (camera.isOrtho) {
            if (meshGrid) {
              meshGrid.visible = true;
              meshGrid.updateSize(camera.getCurrentViewportWidth(), cameraOrtho);
              if (labelUnit) {
                labelUnit.target.visible = true;
                labelUnit.update(meshGrid.unit.toString());
              }
            }
          } else {
            if (meshGrid) {
              meshGrid.visible = false;
              if (labelUnit) labelUnit.target.visible = false;
            }
          }
          viewStateList.forEach((view2) => {
            if (view2.strSprite) view2.strSprite.target.visible = view2.strSprite.code == i;
          });
          renderer.render(sceneOrtho, cameraOrtho);
        }
      }
      handler4After.forEach((e) => e());
    }
  }
  getCameraPosition() {
    const { camera } = this;
    const pos = new Vector3();
    pos.copy(camera.getCamera().position);
    return pos;
  }
  addUi(ui) {
    const { sceneOrtho } = this;
    sceneOrtho.add(ui);
  }
  addBeforHandler(e) {
    this.handler4Before.push(e);
  }
  addAfterHandler(e) {
    this.handler4After.push(e);
  }
}
function localUpdateCamera(camera, scene, oCamera, options) {
  const { width, height, view, index, total } = options;
  scene.add(camera);
  if (!scene.background && view) scene.background = view.background;
  if (index == 0) {
    if (camera instanceof PerspectiveCamera) {
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }
    camera.updateMatrixWorld(true);
  }
  const hW = width / 2, hH = height / 2;
  oCamera.left = -hW;
  oCamera.right = hW;
  oCamera.top = hH;
  oCamera.bottom = -hH;
  oCamera.updateProjectionMatrix();
}
var eTheme = /* @__PURE__ */ ((eTheme2) => {
  eTheme2["light"] = "Light";
  eTheme2["dark"] = "Dark";
  return eTheme2;
})(eTheme || {});
const themeLight = {
  name: "Light",
  lights: [
    {
      type: "ambient",
      color: new Color().setRGB(0.9, 0.9, 0.9),
      intensity: 1.2
    },
    {
      type: "point",
      color: new Color().setRGB(0.5, 0.5, 0.7),
      position: new Vector3(-1, 1, 4),
      distance: 300,
      intensity: 2.5
    },
    {
      type: "point",
      color: new Color().setRGB(0.7, 0.5, 0.5),
      position: new Vector3(1, -1, 4),
      distance: 300,
      intensity: 2.5
    },
    {
      type: "directional",
      color: new Color().setRGB(1, 1, 1),
      position: new Vector3(0, 0, 3),
      intensity: 1.2
    }
  ]
};
const themeDark = {
  name: "Dark",
  lights: [
    {
      type: "ambient",
      color: new Color().setRGB(0.9, 0.9, 0.9),
      intensity: 0.3
    },
    {
      type: "point",
      color: new Color().setRGB(0.5, 0.5, 0.7),
      position: new Vector3(-1, 1, 4),
      distance: 300,
      intensity: 0.8
    },
    {
      type: "point",
      color: new Color().setRGB(0.7, 0.5, 0.5),
      position: new Vector3(1, -1, 4),
      distance: 300,
      intensity: 0.8
    },
    {
      type: "directional",
      color: new Color().setRGB(0.6, 0.6, 0.6),
      position: new Vector3(0, 0, 3),
      intensity: 0.6
    }
  ]
};
const CacheTheme = /* @__PURE__ */ new Map();
CacheTheme.set("Light", themeLight);
CacheTheme.set("Dark", themeDark);
function getThemeByName(name) {
  let theme;
  if (name && CacheTheme.has(name)) {
    theme = CacheTheme.get(name);
  } else {
    theme = CacheTheme.get(
      "Light"
      /* light */
    );
  }
  if (theme) return theme;
  throw new Error("no valid theme");
}
class OrthoGrid1 extends Mesh {
  constructor(size, theme = 0) {
    const themeColor = new Vector3(0, 0, 0);
    if (theme == 1) themeColor.set(0.5, 0.5, 0.5);
    const geometry = new PlaneGeometry(1, 1);
    const material = new ShaderMaterial({
      uniforms: {
        lineStep: { value: 0 },
        lineWidth: { value: 0 },
        sceneCenterX: { value: 0 },
        sceneCenterY: { value: 0 },
        theme: { value: themeColor }
      },
      depthTest: false,
      depthFunc: AlwaysDepth,
      transparent: true,
      vertexShader: `			
			void main() {			
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);			
			}
			`,
      fragmentShader: `	
			uniform vec3 theme;
			uniform float lineStep;
			uniform float lineWidth;
			uniform float sceneCenterX;
			uniform float sceneCenterY;
			void main() {
				float x = sceneCenterX - gl_FragCoord.x;
				float y = sceneCenterY - gl_FragCoord.y;
				
				float regularX = abs(mod(x, lineStep));
				float regularY = abs(mod(y, lineStep));
				
				float masterX = abs(mod(x, lineStep * 10.0));
				float masterY = abs(mod(y, lineStep * 10.0));
				
				if (masterX < lineWidth || masterY < lineWidth) {
					gl_FragColor = vec4(theme.x, theme.y, theme.z, 0.3);
				} else if (regularX < lineWidth || regularY < lineWidth) {
					gl_FragColor = vec4(theme.x, theme.y, theme.z, 0.1);
				} else {
					gl_FragColor = vec4(theme.x, theme.y, theme.z, 0.0);
				}
			}
			`,
      extensions: {
        // derivatives: true
      }
    });
    super(geometry, material);
    this.unit = 1;
    this.stepSize = size || 5;
    this.onBeforeRender = (renderer, scene, camera, geometry2, material2, group) => {
    };
  }
  /**
   * 
   * @param vpWidth 
   * @param fullCamera 
   */
  updateSize(vpWidth, fullCamera) {
    const { stepSize } = this;
    let screenWidth = fullCamera.right - fullCamera.left;
    let screenHeight = fullCamera.top - fullCamera.bottom;
    const size1 = screenWidth / vpWidth;
    const tmp1 = Math.abs(stepSize / size1);
    const scale = 10 ** Math.ceil(Math.log(tmp1) / Math.log(10));
    const size1Physical = size1 * scale;
    const lineWidth = Math.ceil(window.devicePixelRatio);
    this.scale.set(screenWidth * 2, screenHeight * 2, 1);
    this.position.set(screenWidth / 2, screenHeight / 2, 0);
    const material = this.material;
    material.uniforms.lineStep.value = size1Physical;
    material.uniforms.lineWidth.value = lineWidth;
    material.uniforms.sceneCenterX.value = Math.floor(0.5 * screenWidth);
    material.uniforms.sceneCenterY.value = Math.floor(0.5 * screenHeight);
    this.unit = scale;
  }
}
const strTexture = {
  vs: `
varying vec2 v_uv;

void main() {
    v_uv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
  fs: `
uniform sampler2D texPlane;
uniform float opacity;
uniform float cellScale;
uniform float cellX;
uniform float cellY;

varying vec2 v_uv;

void main() {
    vec2 uv2 = v_uv * cellScale;
    vec2 cellOffset = vec2(cellX, 1.0 - cellScale - cellY);
    vec4 texel = texture2D(texPlane, uv2 + cellOffset);
    gl_FragColor = vec4(vec3(texel), texel.a * opacity);
}
`
};
const CellSize = 256;
const TextureAltsSize = 4096;
const CellScale = CellSize / TextureAltsSize;
class TextureAlts {
  constructor() {
    this.cellCoordinates = /* @__PURE__ */ new Map();
    this.canvas = document.createElement("canvas");
    this.ctx = this.canvas.getContext("2d");
    this.canvas.width = TextureAltsSize;
    this.canvas.height = TextureAltsSize;
    this.x = 0;
    this.y = 0;
    this.texture = new Texture(this.canvas);
  }
  toNextCell() {
    const widthOver = this.x + CellSize >= TextureAltsSize;
    this.x = widthOver ? 0 : this.x + CellSize, this.y = widthOver ? this.y + CellSize : this.y;
  }
  addTextureCell(target) {
    const { cellCoordinates, x, y, ctx, texture } = this;
    const hash = target.getHash();
    if (this.hasCell(hash))
      return;
    cellCoordinates.set(hash, { x, y });
    target.renderTexture(ctx, { x, y });
    texture.needsUpdate = true;
    this.toNextCell();
  }
  getCellParameters(hash) {
    const { cellCoordinates, texture, canvas } = this;
    const t = cellCoordinates.get(hash);
    if (void 0 === t)
      throw new Error(`cannot exist cell by hash ${hash} `);
    return {
      texture,
      canvas,
      scale: CellScale,
      x: t.x / TextureAltsSize,
      y: t.y / TextureAltsSize,
      ox: t.x,
      oy: t.y
    };
  }
  getTexture() {
    return this.texture;
  }
  hasCell(hash) {
    const { cellCoordinates } = this;
    return void 0 !== cellCoordinates.get(hash);
  }
}
class StrCell {
  constructor(text, options) {
    this.text = text;
    this.options = options;
  }
  getHash() {
    return "strCell_" + this.text;
  }
  renderTexture(ctx, { x, y }) {
    const { options, text } = this;
    ctx.fillStyle = options.fillStyle || "black";
    let str = `${text}${options.hasPostfix ? options.postfix || "mm" : ""}`;
    ctx.textAlign = "center";
    ctx.font = options.fontInfo || "100 72px sans-serif";
    const textMetrics = ctx.measureText(text);
    if (options.noFix) {
      ctx.fillText(str, x + (CellSize - textMetrics.width) / 2, y + CellSize / 2);
    } else {
      ctx.fillText(str, x + CellSize / 2, y + CellSize / 2);
    }
  }
}
const gAltas = new TextureAlts();
class StrSprite {
  constructor(text, options = {}) {
    this.code = -1;
    this.options = options;
    this.opacity = 1;
    this.textMap = /* @__PURE__ */ new Map();
    this.canvas = document.createElement("canvas");
    this.ctx = this.canvas.getContext("2d");
    this.canvas.width = CellSize;
    this.canvas.height = CellSize;
    this.texture = new Texture(this.canvas);
    const cell = new StrCell(text, options);
    gAltas.addTextureCell(cell);
    this.textMap.set(text, cell);
    const material = new SpriteMaterial({
      map: this.texture,
      depthTest: false,
      depthFunc: AlwaysDepth
    });
    this.target = new Sprite(material);
    this.target.name = `${options.name ? options.name : ""}${text}`;
    this.target.userData = {
      gAltas
    };
    this.updateData(cell);
  }
  update(text, opacity = 1) {
    const { textMap, options } = this;
    let cell = textMap.get(text);
    if (cell == void 0) {
      cell = new StrCell(text, options);
      textMap.set(text, cell);
      gAltas.addTextureCell(cell);
    }
    this.updateData(cell);
  }
  updateData(cell) {
    const { ctx, target, texture } = this;
    const { canvas, ox, oy } = gAltas.getCellParameters(cell.getHash());
    ctx.clearRect(0, 0, CellSize, CellSize);
    ctx.drawImage(canvas, ox, oy, CellSize, CellSize, 0, 0, CellSize, CellSize);
    target.material.needsUpdate = true;
    setTimeout(() => {
      texture.needsUpdate = true;
      target.material.needsUpdate = true;
    }, 500);
  }
}
class StrMesh {
  constructor(text, options = {}) {
    this.options = options;
    this.opacity = 1;
    this.textMap = /* @__PURE__ */ new Map();
    if (text === void 0) text = "";
    const cell = new StrCell(text, options);
    gAltas.addTextureCell(cell);
    this.textMap.set(text, cell);
    const material = new ShaderMaterial({
      transparent: true,
      // depthTest: false,
      vertexShader: strTexture.vs,
      fragmentShader: strTexture.fs,
      uniforms: {
        opacity: {
          value: 1
        },
        texPlane: {
          value: null
        },
        cellX: {
          value: null
        },
        cellY: {
          value: null
        },
        cellScale: {
          value: CellScale
        }
      }
    });
    this.material = material;
    const geometry = new PlaneGeometry(1, 1);
    this.target = new Mesh(geometry, material);
    this.target.name = `${options.name ? options.name : ""}${text}`;
    this.updateTexture(cell);
  }
  updateTexture(cell) {
    const { material } = this;
    const { x, y, texture } = gAltas.getCellParameters(cell.getHash());
    material.uniforms.texPlane.value = texture;
    material.uniforms.cellX.value = x;
    material.uniforms.cellY.value = y;
    material.needsUpdate = true;
    setTimeout(() => {
      material.needsUpdate = true;
    }, 500);
  }
}
var eEntryCode = /* @__PURE__ */ ((eEntryCode2) => {
  eEntryCode2[eEntryCode2["none"] = 0] = "none";
  eEntryCode2[eEntryCode2["aiwebUi"] = 1] = "aiwebUi";
  eEntryCode2[eEntryCode2["aiWebUiNoFitViewport"] = 2] = "aiWebUiNoFitViewport";
  eEntryCode2[eEntryCode2["moonSmile"] = 3] = "moonSmile";
  return eEntryCode2;
})(eEntryCode || {});
class MqMultiViewEditor extends MqRender {
  constructor(entryCode = 0) {
    super("multi-view-render", eColorState.currently);
    this.entryCode = entryCode;
    this.cameraFar = 1e4;
    this.tan = 1;
    this.theme = getThemeByName(entryCode == 3 ? eTheme.dark : void 0);
    this.compiledLights = /* @__PURE__ */ new WeakMap();
  }
  init(options, theme) {
    var _a;
    const { cameraNear, cameraAngle, cameraFar } = this;
    super.init(options);
    this.renderer.outputColorSpace = SRGBColorSpace;
    const ratio = options.width / options.height;
    const halfW = options.width / 2, halfH = options.height / 2;
    this.camera.ortho = new OrthographicCamera(-halfW, halfW, halfH, -halfH, cameraNear, cameraFar);
    this.camera.ortho.position.set(0, 0, options.cameraPositionZ);
    this.camera.persp = new PerspectiveCamera(cameraAngle, ratio, cameraNear, cameraFar);
    this.camera.persp.position.set(0, 0, options.cameraPositionZ);
    this.camera.isOrtho = false;
    this.camera.camera = this.camera.persp;
    const { domElement } = this.renderer;
    const winResize = () => {
      const { clientWidth, clientHeight } = domElement.parentElement;
      this.resize(clientWidth, clientHeight);
    };
    window.addEventListener("resize", winResize);
    this.resize(options.width, options.height);
    this.initControl(this.camera.getCamera());
    if (this.control) this.control.enabled = options.useControl;
    this.applyAppearance(theme);
    if (options.useGrid) {
      const optionGrid = options.optionGrid || {};
      const sizeScale2 = optionGrid.scale || 100;
      const xPos = optionGrid.xPos || options.width / 2 / 2 * 0.9;
      const yPos = optionGrid.yPos || -options.height * 0.45;
      this.meshGrid = new OrthoGrid1(10, options.themeGrid);
      this.sceneOrtho.add(this.meshGrid);
      this.labelUnit = new StrSprite("10", {
        hasPostfix: true,
        fontInfo: "100 32px sans-serif",
        fillStyle: "red"
      });
      this.labelUnit.target.center.set(0.5, 0.5);
      this.labelUnit.target.scale.set(sizeScale2, sizeScale2, 1);
      this.labelUnit.target.position.set(xPos, yPos, 0);
      this.labelUnit.target.visible = true;
      this.sceneOrtho.add(this.labelUnit.target);
    }
    const sizeScale = 80;
    (_a = options.viewStateList) == null ? void 0 : _a.forEach((view, index) => {
      if (view.label) {
        view.strSprite = new StrSprite(view.label);
        view.strSprite.target.center.set(0.5, 0.5);
        view.strSprite.target.scale.set(sizeScale, sizeScale, 1);
        view.strSprite.target.position.set(0, -options.height * 0.45, 0);
        view.strSprite.code = index;
        view.strSprite.target.name = `label_str_${index}`;
        this.sceneOrtho.add(view.strSprite.target);
      }
    });
  }
  applyAppearance(theme = this.theme) {
    const { viewStateList } = this.options;
    if (void 0 !== this.currentLights) {
      this.currentLights.forEach((light) => {
        if (this.compiledLights.has(light)) {
          const instance = this.compiledLights.get(light);
          if (instance instanceof PointLight || instance instanceof DirectionalLight) {
            this.camera.persp.remove(instance);
          } else {
            viewStateList == null ? void 0 : viewStateList.forEach((view, index) => {
              var _a, _b, _c;
              if (index == 0) (_a = view.scene) == null ? void 0 : _a.remove(instance);
              else {
                const al = (_b = view.scene) == null ? void 0 : _b.getObjectByName("AmbientLight");
                if (al) (_c = view.scene) == null ? void 0 : _c.remove(al);
              }
            });
          }
        }
      });
    }
    this.currentLights = theme.lights.map((e) => Object.assign({}, e));
    this.applyLights();
  }
  applyLights(lightData) {
    const { viewStateList } = this.options;
    const lights = lightData || this.currentLights || [];
    lights.forEach((light) => {
      if ("point" === light.type) {
        if (!this.compiledLights.has(light)) {
          const pointLight = new PointLight(light.color, light.intensity, light.distance);
          pointLight.name = "PointLight";
          if (light.position) pointLight.position.copy(light.position);
          this.compiledLights.set(light, pointLight);
          this.camera.persp.add(pointLight);
          this.camera.ortho.add(pointLight.clone());
        }
      } else if ("directional" === light.type) {
        if (!this.compiledLights.has(light)) {
          const dirLight = new DirectionalLight(light.color, light.intensity);
          dirLight.name = "DirectionalLight";
          if (light.position) dirLight.position.copy(light.position);
          this.compiledLights.set(light, dirLight);
          this.camera.persp.add(dirLight);
          this.camera.ortho.add(dirLight.clone());
        }
      } else if ("ambient" === light.type && !this.compiledLights.has(light)) {
        const ambientLight = new AmbientLight(light.color, light.intensity);
        ambientLight.name = "AmbientLight";
        this.compiledLights.set(light, ambientLight);
        viewStateList == null ? void 0 : viewStateList.forEach((view, index) => {
          var _a;
          (_a = view.scene) == null ? void 0 : _a.add(index == 0 ? ambientLight : ambientLight.clone());
        });
      }
    });
  }
  resize(width, height) {
    const { rc, renderer } = this;
    let newWidth = rc.width;
    let newHeight = rc.height;
    if (width) {
      newWidth = width;
      rc.width = width;
    }
    if (height) {
      newHeight = height;
      rc.height = height;
    }
    renderer.setSize(newWidth, newHeight);
  }
  callAnimate() {
    const { rc, renderer, control, camera } = this;
    if (!renderer) return;
    renderer.setPixelRatio(rc.dpr);
    const animate = (t) => {
      this.oneFrame(camera.getCamera());
      if (control) control.update();
      renderer.getContext().finish();
    };
    renderer.setAnimationLoop(animate);
  }
  updateWindowSize(width, height) {
    const { rc } = this;
    rc.width = width;
    rc.height = height;
    this.resize(width, height);
  }
  computeSceneBox() {
    var _a;
    const { options, cameraAngle, camera } = this;
    const sides = [];
    (_a = options.viewStateList) == null ? void 0 : _a.forEach((view) => {
      const box = this.getBox(view.scene);
      const side = Math.max(box.size.x, box.size.y, box.size.z);
      sides.push({ side, box });
    });
    let idx = 0, maxSide = sides[0].side;
    for (let i = 1; i < sides.length; i++) {
      if (sides[idx].side < sides[i].side) {
        idx = i;
        maxSide = sides[i].side;
      }
    }
    camera.persp.position.z = maxSide * 3;
    camera.ortho.position.z = maxSide * 3;
  }
  switchCamera() {
    const { control, camera } = this;
    if (control) camera.switch(control);
    this.updateFrame();
  }
  add(mesh, name) {
    var _a;
    const { options: inOptions, entryCode } = this;
    (_a = inOptions.viewStateList) == null ? void 0 : _a.forEach((view) => {
      var _a2;
      if (view.name == name) (_a2 = view.scene) == null ? void 0 : _a2.add(mesh);
    });
    if ([
      1
      /* aiwebUi */
    ].includes(entryCode)) {
      this.cameraFitViewport();
      this.computeSceneBox();
    }
    this.updateFrame();
  }
  /**
   * 
   * @param target name or Mesh
   */
  remove(target) {
    var _a;
    const { options: inOptions, entryCode } = this;
    (_a = inOptions.viewStateList) == null ? void 0 : _a.forEach((view) => {
      const scene = view.scene;
      if (scene) {
        if (typeof target == "string") {
          const obj = scene.getObjectByName(target);
          if (obj) scene.remove(obj);
        } else {
          scene.remove(target);
        }
      }
    });
    if ([
      1
      /* aiwebUi */
    ].includes(entryCode)) {
      this.cameraFitViewport();
      this.computeSceneBox();
    }
    this.updateFrame();
  }
  findByName(name) {
    const { options } = this;
    const res = [];
    options.viewStateList.forEach((view) => {
      const scene = view.scene;
      if (scene) {
        const tmp2 = scene.getObjectByName(name);
        res.push(tmp2);
      }
    });
    return res;
  }
  updateFrame() {
    const { camera } = this;
    this.oneFrame(camera.getCamera());
  }
  cameraFitViewport() {
    const { options, camera, renderer } = this;
    if (!options || !renderer) return;
    if (!options.viewStateList) return;
    const theScene = options.viewStateList[0].scene;
    const { size } = this.getBox(theScene);
    const maxside = Math.max(size.x, size.y, size.z);
    const aspect2 = renderer.domElement.width / renderer.domElement.height;
    let fitSideH = maxside * Math.sqrt(3);
    let fitSideV = fitSideH / aspect2;
    const persp = camera.persp;
    persp.projectionMatrix.makePerspective(-fitSideH, fitSideH, fitSideV, -fitSideV, persp.near, persp.far);
    persp.updateProjectionMatrix();
  }
}
const GumShader = {
  vertexShader: `
            attribute vec4 tangent;
            attribute vec4 tangent2;
            attribute vec2 uv2;

            varying vec2 vUv;
            varying vec2 vUv2;
            varying vec4 vUv2Color;
            varying vec3 vNormal;
            varying vec4 normalTex2;
            varying vec3 vTangent;
            varying vec3 vBinormal;
            varying vec4 mPos;
            varying vec3 vViewPosition;

            uniform sampler2D map;
            uniform sampler2D normalMap;

            void main() {
                vUv = uv;
                vUv2 = uv2;

                vUv2Color = texture2D(map, vUv2);
                normalTex2 = texture2D( normalMap, vUv2 );

                vec3 objectNormal = vec3( normal );
                vec3 transformedNormal = objectNormal;

                transformedNormal = normalMatrix * transformedNormal;

                vNormal = normalize(transformedNormal);
                vec4 tan = (tangent + tangent2) / 2.0;
                vTangent = normalize( normalMatrix * tan.xyz );
                vBinormal = normalize( cross( vNormal, vTangent ) * tan.w );

                vViewPosition = -(modelViewMatrix * vec4(position, 1.0)).xyz;
                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

                vec4 projectedVertex = projectionMatrix * mvPosition;
                gl_Position = projectedVertex;
                mPos = mvPosition;
            }
		`,
  fragmentShader: `
            precision highp float;
            precision highp int;

            uniform vec3 diffuse;
            uniform vec3 lightColor;
            uniform float opacity;
            uniform float reflection;
            uniform float illumination;
            uniform float glossiness;
            uniform float reflectivity;
            uniform float shineFactor;
            uniform sampler2D map;
            uniform sampler2D normalMap;
            uniform sampler2D specularMap;
            uniform sampler2D reflectMap;

            varying vec2 vUv;
            varying vec4 vUv2Color;
            varying vec3 vNormal;
            varying vec4 normalTex2;
            varying vec3 vTangent;
            varying vec3 vBinormal;
            varying vec4 mPos;
            varying vec3 vViewPosition;

            
            struct PointLight {
                vec3 position;
                vec3 color;
            };
            uniform PointLight pointLights[ 3 ];

            void main() {
                vec4 diffuseColor = vec4( diffuse, opacity );

                vec4 uvColor = texture2D(map, vUv);
                diffuseColor *= ((uvColor + vUv2Color) / 2.0);

                float roughness = 2.0 * pow(100.0, glossiness);
                float roughnessResult = 13.0 - 10.0 * glossiness;
                float reflectionF = pow(reflectivity, 2.0) * pow(glossiness, 0.5);
                float reflection = reflectionF * reflection;
                float iReflection = sqrt(1.0 - reflectionF * reflection);
                float highLightFactor = reflectivity * pow(glossiness, 0.5) * shineFactor;
                vec3 lighting = lightColor;
                vec3 highLight = vec3(0.0);

				vec3 normal = vec3(1.0);
                #ifdef FLAT_SHADED
                    vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
                    vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
                    normal = normalize( cross( fdx, fdy ) );
                #else
	                vec2 normalScale = vec2(1.5);
	                vec4 noco = texture2D( normalMap, vUv );
	                vec3 normalTex = ((normalTex2 + noco) / 2.0).xyz * 2.0 - 1.0;
	                normalTex.xy *= normalScale;
	                normalTex = normalize( normalTex );
	                mat3 tsb = mat3( vTangent, vBinormal, vNormal );
	                normal = normalize( tsb * normalTex );
                #endif

                PointLight pointLight;
                for (int i = 0; i < 3; i++) {
                    pointLight = pointLights[ i ];
                    lighting += max(dot(normal, normalize(pointLight.position)), 0.0) * pointLight.color;
                    float highLightValue = max(dot(normalize(reflect(pointLight.position - mPos.xyz, normal)), normalize(mPos.xyz)), 0.001);
                    float tempLight = 1.0 / max(pow(highLightValue, roughness), 0.001);
                    highLight += pointLight.color[i] * pow(roughnessResult, 1.0 - tempLight) * tempLight;
                }

                vec3 specularValue = vec3(1.0);
                specularValue = texture2D(specularMap, vUv).rgb;

                vec3 reflectionColor = vec3(0.0);
                vec3 reflectNormal = normalize(reflect(mPos.xyz, normal));
                if (reflectNormal.z < 0.0)
                    reflectNormal.xy *= 2.0 / length(reflectNormal.xy) - 1.0;
                reflectionColor = texture2D(reflectMap, vec2(0.5, 0.5) - reflectNormal.xy * 0.25).rgb;

                vec3 fColor = mix(diffuseColor.rgb * lighting, diffuseColor.rgb, illumination);
                fColor *= mix(vec3(1.0), vec3(iReflection) + reflectionColor * reflection, specularValue);
                vec3 resultingColor = fColor + (highLight * highLightFactor * specularValue);
                gl_FragColor = linearToOutputTexel(vec4( resultingColor, opacity ));
            }
		`
};
const TeethShader = {
  vertexShader: `
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec4 mPos;

            void main() {
                vColor = color;

                vec3 objectNormal = vec3( normal );
                vec3 transformedNormal = objectNormal;
                transformedNormal = normalMatrix * transformedNormal;
                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

                vNormal = transformedNormal;

                vec4 projectedVertex = projectionMatrix * mvPosition;
                gl_Position = projectedVertex;
                mPos = mvPosition;
            }
		`,
  fragmentShader: `
            precision highp float;
            precision highp int;

            uniform vec3 diffuse;
            uniform vec3 lightColor;
            uniform float opacity;
            uniform float reflection;
            uniform float illumination;
            uniform float glossiness;
            uniform float reflectivity;
            uniform float shineFactor;
            uniform sampler2D reflectMap;

            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec4 mPos;

            
            struct PointLight {
                vec3 position;
                vec3 color;
            };
            uniform PointLight pointLights[ 3 ];

            void main() {
                vec4 diffuseColor = vec4( diffuse, opacity );
                diffuseColor *= vec4(vColor, 1.0);

                float roughness = 2.0 * pow(100.0, glossiness);
                float roughnessResult = 13.0 - 10.0 * glossiness;
                float reflectionF = pow(reflectivity, 2.0) * pow(glossiness, 0.5);
                float reflection = reflectionF * reflection;
                float iReflection = sqrt(1.0 - reflectionF * reflection);
                float highLightFactor = reflectivity * pow(glossiness, 0.5) * shineFactor;
                vec3 lighting = lightColor;
                vec3 highLight = vec3(0.0);
                vec3 normal = normalize( vNormal );

                #ifdef FLAT_SHADED
                    vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
                    vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
                    normal = normalize( cross( fdx, fdy ) );
                #else
                    float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
                    normal = normalize( vNormal );
                    normal *= faceDirection;
                #endif

                PointLight pointLight;
                for (int i = 0; i < 3; i++) {
                    pointLight = pointLights[ i ];
                    lighting += max(dot(normal, normalize(pointLight.position)), 0.0) * pointLight.color;
                    float highLightValue = max(dot(normalize(reflect(pointLight.position - mPos.xyz, normal)), normalize(mPos.xyz)), 0.001);
                    float tempLight = 1.0 / max(pow(highLightValue, roughness), 0.001);
                    highLight += pointLight.color[i] * pow(roughnessResult, 1.0 - tempLight) * tempLight;
                }

                vec3 specularValue = vec3(1.0);
                vec3 reflectionColor = vec3(0.0);
                vec3 reflectNormal = normalize(reflect(mPos.xyz, normal));
                if (reflectNormal.z < 0.0)
                    reflectNormal.xy *= 2.0 / length(reflectNormal.xy) - 1.0;
                reflectionColor = texture2D(reflectMap, vec2(0.5, 0.5) - reflectNormal.xy * 0.25).rgb;

                vec3 fColor = mix(diffuseColor.rgb * lighting, diffuseColor.rgb, illumination);
                fColor *= mix(vec3(1.0), vec3(iReflection) + reflectionColor * reflection, specularValue);
                vec3 resultingColor = fColor + (highLight * highLightFactor * specularValue);
                gl_FragColor = vec4( resultingColor, opacity );
            }
		`
};
const cModelCrownColor = {
  r: 232 / 255,
  g: 217 / 255,
  b: 213 / 255
};
const pngGumColor = "data:image/png;base64,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";
const pngNormalMap = "data:image/png;base64,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";
const pngReflectMap = "data:image/png;base64,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CDzBpVPxrx7C0IfoWxWt8wBaNuD8qqKZO3CxCW2POcM1ilJAppZOw9upfNMstN5A03ypt/I+J/eQkK4mr2FvH7ozkr1Q492N1b39e6bc3w848HKQy2qF4QAADRhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDQuNC4wLUV4aXYyIj4KIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgIHhtbG5zOkdJTVA9Imh0dHA6Ly93d3cuZ2ltcC5vcmcveG1wLyIKICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICB4bXBNTTpEb2N1bWVudElEPSJnaW1wOmRvY2lkOmdpbXA6ZGNkMDI2NWMtNWMzZi00ZWQyLTlkNTItZDJiNWZiOWM1NjEyIgogICB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmFhNjk2Mjk5LWI3ZDItNGU5OC04ZThkLWU5NWQwZTBiNzBlMyIKICAgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjQyZDM1Y2YyLTdjYTgtNDkwOC04MzUzLTI2NTljNDM2OWFjMSIKICAgZGM6Rm9ybWF0PSJpbWFnZS9wbmciCiAgIEdJTVA6QVBJPSIyLjAiCiAgIEdJTVA6UGxhdGZvcm09IldpbmRvd3MiCiAgIEdJTVA6VGltZVN0YW1wPSIxNjM4NDk3MzA1NTAwODU3IgogICBHSU1QOlZlcnNpb249IjIuMTAuMjgiCiAgIHRpZmY6T3JpZW50YXRpb249IjEiCiAgIHhtcDpDcmVhdG9yVG9vbD0iR0lNUCAyLjEwIj4KICAgPHhtcE1NOkhpc3Rvcnk+CiAgICA8cmRmOlNlcT4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ODk2NzNjYzItMzdlYi00MTUxLWI5YjgtNTIxZGZiYTc4NDExIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKFdpbmRvd3MpIgogICAgICBzdEV2dDp3aGVuPSIyMDIxLTEyLTAzVDEwOjA4OjI1Ii8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PmVn48YAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflDAMCCBnyLpTYAAAgAElEQVR42uy963pkuY0sihvXStW8/7NO5SIBnB+4kKlq7/GMPe5yn5H1VcsqqZTKBEggEBFA+Cu94ef/8/wcExKhELMQs7BwfMTCxEwsQjSIh7AwD2YRGiJDeAiPIYNZWIQpv5yJ6gOm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";
const pngUvDiffuseMap = "data:image/png;base64,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";
const pngLutMap = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAADACAIAAACCr3QZAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AAAKoSURBVGiB7VpLcsMgDJUY7n+5HqJH6JIuim0hPSHhknSmiaaLGPT0waAPLn99fpCmJn6zGi9ELP4Uk+Tuj8UOGRpkFTQtmaQ2JqJKrK0kYvFDi6tGvGUdYApwTnsaAABIHQDMaq4ZnpRJLtllDWgZoN6DT4draQ2H2If6wERENVxHhXnGsgKTZke0qtfQNJPcvQw0MDUjn+V4/jz0ceD0IVXvmZ9xu5eadkLo5JXz0MfvbO9VwCJiWcOdvaQo0Ih9MMFqquFgxhgvP0w0nNpbYEwH8ClMc2JkJWYQfy1wCGQTK4xTh9NscylMovI9sMc4YMrwlNhY1YgcfUQAL5k7ANamz9cYaNid47w8DQnUGjGtmqSLk8AecnyYGbnqg2uSKwU6PdPp1XwuiTOtUakwE3ATWNYwzIhMmSIn3E9jqxfIMJ1hJm8S4YX1NTw6Kd4vQ70ayQDWFvXQEBToI+CadnsGC1iwqoo2RmJTJqU0/b7QjRx5eGz9k2I9yHHLkW+PD0F+gONr4X5GT3gPkzAGD+5MAyxC9vRxg1QVGuJ2QM0/Pra+JMBpB/ylRu3A9tg61hpXi4VrinJxseSGRRATX4l9VMFkMP2kFVA6cMakk8kD66bpZ8gzT4zLpJhqVQocnZAwKUc2sQcbK8wP2IcFmucH4NiedmBGf3SptlXDG/AqgP9Zt+7W8Aa8AW/AMwH/4UzX1oIG+rcaNtwZx59qQx8GBs+k5gmCgGZ+BIBczTe+D2+DHV/8cm+veSbNqBD6KOgQE1Fts+vTRrpVAP+JMIi0C7x186nPtv3La4P3fKNhEnO/pVkGpHugy4OWwpQuPB0JbvbTC1ff53lAmGYe+OzYIfH4cPTTesYnPgG+E+auoIopZ3k7a5/RPkwd4vHWIUfe/wm49A2MLkqn0mLyXgAAAABJRU5ErkJggg==";
const gTextures = {
  uvMap: null,
  normalMap: null,
  reflectMap: null,
  uvDiffuse: null,
  lutMap: null,
  lutData: void 0
};
new TextureLoader().load(pngGumColor, (tex) => {
  tex.colorSpace = SRGBColorSpace;
  gTextures.uvMap = tex;
});
new TextureLoader().load(pngNormalMap, (tex) => {
  tex.colorSpace = NoColorSpace;
  gTextures.normalMap = tex;
});
new TextureLoader().load(pngReflectMap, (tex) => {
  tex.colorSpace = SRGBColorSpace;
  gTextures.reflectMap = tex;
});
new TextureLoader().load(pngUvDiffuseMap, (tex) => {
  tex.colorSpace = NoColorSpace;
  gTextures.uvDiffuse = tex;
});
new TextureLoader().load(pngLutMap, (tex) => {
  tex.colorSpace = SRGBColorSpace;
  gTextures.lutMap = tex;
  const canvas = document.createElement("canvas");
  const cxt = canvas.getContext("2d");
  canvas.width = tex.image.width;
  canvas.height = tex.image.height;
  cxt == null ? void 0 : cxt.drawImage(tex.image, 0, 0, canvas.width, canvas.height);
  gTextures.lutData = cxt == null ? void 0 : cxt.getImageData(0, 0, canvas.width, canvas.height).data;
});
function getCacheTextures() {
  return gTextures;
}
var eMaterialType = /* @__PURE__ */ ((eMaterialType2) => {
  eMaterialType2[eMaterialType2["legacyGum"] = 1] = "legacyGum";
  eMaterialType2[eMaterialType2["legacyCrown"] = 3] = "legacyCrown";
  eMaterialType2[eMaterialType2["standard"] = 2] = "standard";
  eMaterialType2[eMaterialType2["legacyPhong"] = 4] = "legacyPhong";
  return eMaterialType2;
})(eMaterialType || {});
const materialGumShader = (options) => {
  const gTextures2 = getCacheTextures();
  const diffuseColor = new Color().setRGB(0.92, 0.88, 0.89, LinearSRGBColorSpace);
  const material = new ShaderMaterial({
    uniforms: {
      // diffuse: { value: new Vector3(0.92, 0.88, 0.89) },
      diffuse: { value: new Vector3(diffuseColor.r, diffuseColor.g, diffuseColor.b) },
      lightColor: { value: new Color().setHex(13944261, LinearSRGBColorSpace) },
      pointLights: {
        value: [
          {
            position: new Vector3(0, 0, 5),
            color: new Vector3(0.4, 0.5, 0.45)
          },
          {
            position: new Vector3(-3, 0, -5),
            color: new Vector3(0, 0, 0)
          },
          {
            position: new Vector3(3, 0, -5),
            color: new Vector3(0, 0, 0)
          }
        ]
      },
      opacity: { value: 1 },
      reflection: { value: 0.85 },
      illumination: { value: 0 },
      glossiness: { value: 0.69 },
      reflectivity: { value: 0.55 },
      shineFactor: { value: 2 },
      map: { value: gTextures2.uvMap },
      normalMap: { value: gTextures2.normalMap },
      specularMap: { value: gTextures2.uvMap },
      reflectMap: { value: gTextures2.reflectMap }
    },
    vertexShader: GumShader.vertexShader,
    fragmentShader: GumShader.fragmentShader,
    defines: {
      // 'USE_UV': true,
    },
    transparent: true,
    side: DoubleSide,
    precision: "highp",
    polygonOffset: true,
    userData: {
      type: "Gum"
    }
  });
  return material;
};
const materialPhong = (bufferGeo, options) => {
  const hasColor = typeof options.hasColor == "boolean" ? options.hasColor : true;
  const color = new Color(options.color || cModelCrownColor);
  let material = new MeshPhongMaterial({
    side: DoubleSide,
    transparent: false,
    depthTest: true,
    depthWrite: true,
    vertexColors: true,
    //
    color,
    specular: 1118481,
    // emissive: options.emissiveColor || 0x000000,
    reflectivity: 1,
    shininess: 10,
    combine: MultiplyBlending
  });
  if (hasColor) {
    let colors = [];
    for (let i = 0; i < bufferGeo.attributes.position.count; i++) {
      colors.push(color.r);
      colors.push(color.g);
      colors.push(color.b);
    }
    bufferGeo.setAttribute("color", new Float32BufferAttribute(colors, 3));
    bufferGeo.computeVertexNormals();
    bufferGeo.normalizeNormals();
    bufferGeo.attributes.color.needsUpdate = true;
  }
  if (options.debug) {
    console.log("phong material", color, hasColor);
  }
  return material;
};
function materialToothCrownBasic(bufferGeo, options) {
  const hasColor = typeof options.hasColor == "boolean" ? options.hasColor : true;
  const color = new Color().setRGB(cModelCrownColor.r, cModelCrownColor.g, cModelCrownColor.b);
  if (options.color) {
    color.setHex(options.color, LinearSRGBColorSpace);
  }
  const attributes = bufferGeo.attributes;
  let material = new MeshBasicMaterial({
    side: DoubleSide,
    vertexColors: true,
    color,
    userData: {
      type: "toothCrown"
    }
  });
  if (hasColor) {
    let colors = [];
    for (let i = 0; i < attributes.position.count; i++) {
      colors.push(color.r);
      colors.push(color.g);
      colors.push(color.b);
    }
    bufferGeo.setAttribute("color", new Float32BufferAttribute(colors, 3));
    bufferGeo.computeVertexNormals();
    bufferGeo.normalizeNormals();
    bufferGeo.attributes.color.needsUpdate = true;
  }
  return material;
}
function materialToothCrown(geometry, isUpper, options) {
  const gTextures2 = getCacheTextures();
  geometry.computeBoundingBox();
  if (!geometry.attributes.normal) {
    geometry.computeVertexNormals();
  }
  let max = geometry.boundingBox.max, min = geometry.boundingBox.min, len = Math.abs(max.y - min.y);
  const position = geometry.attributes.position;
  const factor4Color = 1.1;
  let colors = geometry.attributes.color;
  for (let i = 0; i < position.count; i++) {
    const y = position.array[i * 3 + 1];
    const perc = 1 - factor4Color * Math.abs((isUpper ? min.y : max.y) - y) / len;
    let _index = Math.floor(
      perc * gTextures2.lutMap.image.height * gTextures2.lutMap.image.width
    ) * 4;
    if (_index < 0) _index = 0;
    if (_index > gTextures2.lutData.length - 3)
      _index = gTextures2.lutData.length - 3;
    const color = new Color().setRGB(
      gTextures2.lutData[_index] / 255,
      gTextures2.lutData[_index + 1] / 255,
      gTextures2.lutData[_index + 2] / 255,
      LinearSRGBColorSpace
    );
    colors.setXYZ(i, color.r, color.g, color.b);
  }
  colors.needsUpdate = true;
  let tMaterial = new ShaderMaterial({
    uniforms: {
      diffuse: { value: new Color().setRGB(0.92, 0.88, 0.89, LinearSRGBColorSpace) },
      lightColor: { value: new Color().setHex(10457232, LinearSRGBColorSpace) },
      pointLights: {
        value: [
          {
            position: new Vector3(0, 0, 4),
            color: new Color().setRGB(0.41, 0.47, 0.45, LinearSRGBColorSpace)
          },
          {
            position: new Vector3(-2, 0, -4),
            color: new Color().setRGB(0, 0, 0, LinearSRGBColorSpace)
          },
          {
            position: new Vector3(-2, 0, -4),
            color: new Color().setRGB(0, 0, 0, LinearSRGBColorSpace)
          }
        ]
      },
      opacity: { value: 1 },
      reflection: { value: 0.54 },
      illumination: { value: 0.2 },
      glossiness: { value: 0.6 },
      reflectivity: { value: 0.44 },
      shineFactor: { value: 1.75 },
      reflectMap: { value: gTextures2.reflectMap }
    },
    vertexShader: TeethShader.vertexShader,
    fragmentShader: TeethShader.fragmentShader,
    transparent: false,
    vertexColors: true,
    side: DoubleSide,
    userData: {
      type: "toothCrown"
    }
  });
  return tMaterial;
}
const materialStandard = (bufferGeo, options) => {
  const hasColor = typeof options.hasColor == "boolean" ? options.hasColor : true;
  const color = new Color(options.color);
  let material = new MeshStandardMaterial({
    side: DoubleSide,
    // vertexColors: true,
    color
  });
  if (hasColor) {
    let colors = [];
    for (let i = 0; i < bufferGeo.attributes.position.count; i++) {
      colors.push(color.r);
      colors.push(color.g);
      colors.push(color.b);
    }
    bufferGeo.setAttribute("color", new Float32BufferAttribute(colors, 3));
    bufferGeo.computeVertexNormals();
    bufferGeo.normalizeNormals();
    bufferGeo.attributes.color.needsUpdate = true;
  }
  if (options.debug) {
    console.log("standard material", color, hasColor);
  }
  return material;
};
const geometry2Mesh = (bufferGeo, options = {}) => {
  const code = options.code || 2;
  const material = code == 1 ? materialGumShader() : code == 2 ? materialStandard(bufferGeo, options) : code == 3 ? materialToothCrownBasic(bufferGeo, options) : materialPhong(bufferGeo, options);
  const mesh = new Mesh(bufferGeo, material);
  if (options.useShadow) {
    mesh.castShadow = true;
    mesh.receiveShadow = false;
  }
  mesh.name = options.name || "";
  if (options.userData) mesh.userData = options.userData;
  if (typeof options.visible == "boolean") mesh.visible = options.visible;
  if (code == 3) {
    const tmpColor = new Color().setRGB(1, 1, 1, LinearSRGBColorSpace);
    const colors = mesh.geometry.attributes.color.array;
    for (let i = 0, il = colors.length; i < il; i += 3) {
      setXYZ(colors, i, tmpColor.r, tmpColor.g, tmpColor.b);
    }
    mesh.userData.oMaterial = mesh.material.clone();
    mesh.material = materialToothCrown(mesh.geometry, mesh.userData.isUpper);
    mesh.userData.sColor = mesh.geometry.attributes.color.clone();
  }
  return mesh;
};
function createGumMesh(name, options) {
  const geometry = new BufferGeometry();
  const mesh = new Mesh(geometry, materialGumShader());
  mesh.name = name;
  if (options.userData) mesh.userData = options.userData;
  if (typeof options.visible == "boolean") mesh.visible = options.visible;
  return mesh;
}
class MarkerLines extends LineSegments {
  constructor(axes, size = 1, options = {}) {
    let showX = options.showX ? true : false, showY = options.showY ? true : false, showZ = options.showZ ? true : false;
    const vertices = [], colors = [];
    if (showX && axes.length > 0) {
      let xAxis = axes[0].normalize().multiplyScalar(size);
      vertices.push(0, 0, 0, ...xAxis.toArray());
      if (options.color1) {
        colors.push(...options.color1, ...options.color1);
      } else {
        colors.push(1, 0, 0, 1, 0, 0);
      }
    }
    if (showY && axes.length > 1) {
      let yAxis = axes[1].normalize().multiplyScalar(size);
      vertices.push(0, 0, 0, ...yAxis.toArray());
      colors.push(0, 1, 0, 0, 1, 0);
    }
    if (showZ && axes.length > 2) {
      let zAxis = axes[2].normalize().multiplyScalar(size);
      vertices.push(0, 0, 0, ...zAxis.toArray());
      colors.push(0, 0, 1, 0, 0, 1);
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.len = axes.length;
    this.axesLength = size;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  update(pos, index = 1) {
    const arrPosition = this.geometry.attributes.position;
    let idx = index;
    if (index === 2) idx = 3;
    else if (index === 3) idx = 5;
    const newPos = Array.isArray(pos) ? new Vector3().fromArray(pos) : new Vector3().copy(pos);
    newPos.normalize().multiplyScalar(this.axesLength);
    arrPosition.setXYZ(idx, newPos.x, newPos.y, newPos.z);
    arrPosition.needsUpdate = true;
  }
}
const gFPTmplate = {
  fa: new MeshLambertMaterial({ color: 16711680 }),
  gbp: new MeshLambertMaterial({ color: 16716032 }),
  fan: new MeshLambertMaterial({ color: 16711697 }),
  lmc: new MeshLambertMaterial({ color: 16729088 }),
  ldc: new MeshLambertMaterial({ color: 52479 }),
  blmp: new MeshLambertMaterial({ color: 16742144 }),
  bdc: new MeshLambertMaterial({ color: 16750848 }),
  cc: new MeshLambertMaterial({ color: 16763904 }),
  axisfl: new MeshLambertMaterial({ color: 255 }),
  rc: new MeshLambertMaterial({ color: 4607 }),
  axisie: new MeshLambertMaterial({ color: 17663 }),
  glp: new MeshLambertMaterial({ color: 39423 }),
  axismd: new MeshLambertMaterial({ color: 56831 }),
  bmc: new MeshLambertMaterial({ color: 65280 }),
  mrm: new MeshLambertMaterial({ color: 65297 }),
  occd: new MeshLambertMaterial({ color: 65399 }),
  mrd: new MeshLambertMaterial({ color: 65433 }),
  occc: new MeshLambertMaterial({ color: 65280 }),
  occm: new MeshLambertMaterial({ color: 65535 }),
  fcm: new MeshLambertMaterial({ color: 16711680 })
};
class ToothKeyPoint extends Object3D {
  constructor(target, fpList, options = {}) {
    super();
    this.target = target;
    this.fpList = fpList;
    this.options = options;
    fpList.forEach((fp) => {
      const geo = new SphereGeometry(options.sphereRadius || 0.75, 32, 32);
      const mat = gFPTmplate[fp.name];
      if (!mat) console.warn(`unsupport key point color ${fp.name}`);
      const mesh = new Mesh(geo, mat);
      mesh.position.set(fp.x, fp.y, fp.z);
      mesh.name = fp.name;
      const ptList = [];
      ptList.push(new Vector3().set(fp.x, fp.y, fp.z));
      ptList.push(new Vector3().set(fp.x, fp.y + 10, fp.z));
      if (fp.name === void 0) {
        console.warn("feature point name is empty", fp);
      }
      const strMesh = new StrMesh(fp.name, options);
      const scale = options.strScale || [5, 5, 1];
      strMesh.target.scale.set(scale[0], scale[1], scale[2]);
      strMesh.target.position.set(0, 0, 0);
      strMesh.target.updateMatrix();
      mesh.add(strMesh.target);
      this.add(mesh);
    });
    target.add(this);
    target.updateMatrixWorld();
  }
}
function mat4Tooth(tooth) {
  const wmatS2f = new Matrix4().fromArray(tooth.start2Final).transpose();
  const w2l = new Matrix4().fromArray(tooth.world2Local).transpose();
  const l2w = new Matrix4().copy(w2l).invert();
  const lmatStep = new Matrix4().premultiply(l2w).premultiply(wmatS2f).premultiply(w2l);
  return {
    matStart: new Matrix4().transpose().elements,
    matEnd: lmatStep.transpose().elements
  };
}
function mat2Mesh(elments, mesh, options = {}) {
  const mat = new Matrix4().fromArray(elments);
  if (options.transpose) mat.transpose();
  mat.decompose(mesh.position, mesh.quaternion, mesh.scale);
  mesh.updateMatrix();
  mesh.updateMatrixWorld();
}
function create4ToothNumberMesh(group, options = {}) {
  const uMeshList = group.children.filter((e) => e.userData.isUpper && e.userData.code != "10");
  const lMeshList = group.children.filter((e) => !e.userData.isUpper && e.userData.code != "40");
  const info = { upper: [], lower: [] };
  uMeshList.forEach((e) => info.upper.push(computeToothInfo(e, options)));
  lMeshList.forEach((e) => info.lower.push(computeToothInfo(e, options)));
  return info;
}
function computeToothInfo(target, options = {}) {
  const { code, isUpper } = target.userData;
  const { metaTooth } = options;
  const meta = metaTooth.filter((e) => e.cid === +code)[0];
  const strMesh = new StrMesh(code, options);
  const mesh = strMesh.target;
  const scale = options.scale || [5, 5, 1];
  mesh.scale.set(scale[0], scale[1], scale[2]);
  const pos = new Vector3();
  const dir = new Vector3(0, 1, 0);
  if (meta) {
    pos.set(meta.fa[0], meta.fa[1], meta.fa[2]);
    dir.set(meta.flAxis[0], meta.flAxis[1], meta.flAxis[2]);
    pos.add(dir.multiplyScalar(-0.8));
    pos.add(new Vector3(meta.ieAxis[0], meta.ieAxis[1], meta.ieAxis[2]).multiplyScalar(isUpper ? 1.5 : -1.5));
  }
  mesh.position.copy(pos);
  mesh.updateMatrix();
  mesh.name = `${isUpper ? "u" : "l"}${code}`;
  mesh.userData = {
    code,
    isUpper
  };
  mesh.onBeforeRender = (renderer, scene, camera, geometry, material, group) => {
    if (mesh.visible) {
      mesh.quaternion.rotateTowards(camera.quaternion, 1);
    }
  };
  mesh.visible = false;
  target.add(mesh);
  return mesh;
}
function debug_ToothVisualPoint(target, fpList, options = {}) {
  return new ToothKeyPoint(target, fpList, options);
}
const CENTER = 0;
const AVERAGE = 1;
const SAH = 2;
const CONTAINED = 2;
const TRIANGLE_INTERSECT_COST = 1.25;
const TRAVERSAL_COST = 1;
const BYTES_PER_NODE = 6 * 4 + 4 + 4;
const IS_LEAFNODE_FLAG = 65535;
const FLOAT32_EPSILON = Math.pow(2, -24);
const SKIP_GENERATION = Symbol("SKIP_GENERATION");
function getVertexCount(geo) {
  return geo.index ? geo.index.count : geo.attributes.position.count;
}
function getTriCount(geo) {
  return getVertexCount(geo) / 3;
}
function getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {
  if (vertexCount > 65535) {
    return new Uint32Array(new BufferConstructor(4 * vertexCount));
  } else {
    return new Uint16Array(new BufferConstructor(2 * vertexCount));
  }
}
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    const index = getIndexArray(vertexCount, BufferConstructor);
    geo.setIndex(new BufferAttribute(index, 1));
    for (let i = 0; i < vertexCount; i++) {
      index[i] = i;
    }
  }
}
function getFullGeometryRange(geo, range) {
  const triCount = getTriCount(geo);
  const drawRange = range ? range : geo.drawRange;
  const start = drawRange.start / 3;
  const end = (drawRange.start + drawRange.count) / 3;
  const offset = Math.max(0, start);
  const count = Math.min(triCount, end) - offset;
  return [{
    offset: Math.floor(offset),
    count: Math.floor(count)
  }];
}
function getRootIndexRanges(geo, range) {
  if (!geo.groups || !geo.groups.length) {
    return getFullGeometryRange(geo, range);
  }
  const ranges = [];
  const rangeBoundaries = /* @__PURE__ */ new Set();
  const drawRange = range ? range : geo.drawRange;
  const drawRangeStart = drawRange.start / 3;
  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;
  for (const group of geo.groups) {
    const groupStart = group.start / 3;
    const groupEnd = (group.start + group.count) / 3;
    rangeBoundaries.add(Math.max(drawRangeStart, groupStart));
    rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));
  }
  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);
  for (let i = 0; i < sortedBoundaries.length - 1; i++) {
    const start = sortedBoundaries[i];
    const end = sortedBoundaries[i + 1];
    ranges.push({
      offset: Math.floor(start),
      count: Math.floor(end - start)
    });
  }
  return ranges;
}
function hasGroupGaps(geometry, range) {
  const vertexCount = getTriCount(geometry);
  const groups = getRootIndexRanges(geometry, range).sort((a, b) => a.offset - b.offset);
  const finalGroup = groups[groups.length - 1];
  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);
  let total = 0;
  groups.forEach(({ count }) => total += count);
  return vertexCount !== total;
}
function getBounds(triangleBounds, offset, count, target, centroidTarget) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    const hx = triangleBounds[i + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx) minx = lx;
    if (rx > maxx) maxx = rx;
    if (cx < cminx) cminx = cx;
    if (cx > cmaxx) cmaxx = cx;
    const cy = triangleBounds[i + 2];
    const hy = triangleBounds[i + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny) miny = ly;
    if (ry > maxy) maxy = ry;
    if (cy < cminy) cminy = cy;
    if (cy > cmaxy) cmaxy = cy;
    const cz = triangleBounds[i + 4];
    const hz = triangleBounds[i + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz) minz = lz;
    if (rz > maxz) maxz = rz;
    if (cz < cminz) cminz = cz;
    if (cz > cmaxz) cmaxz = cz;
  }
  target[0] = minx;
  target[1] = miny;
  target[2] = minz;
  target[3] = maxx;
  target[4] = maxy;
  target[5] = maxz;
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function computeTriangleBounds(geo, target = null, offset = null, count = null) {
  const posAttr = geo.attributes.position;
  const index = geo.index ? geo.index.array : null;
  const triCount = getTriCount(geo);
  const normalized = posAttr.normalized;
  let triangleBounds;
  if (target === null) {
    triangleBounds = new Float32Array(triCount * 6 * 4);
    offset = 0;
    count = triCount;
  } else {
    triangleBounds = target;
    offset = offset || 0;
    count = count || triCount;
  }
  const posArr = posAttr.array;
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  const getters = ["getX", "getY", "getZ"];
  for (let tri = offset; tri < offset + count; tri++) {
    const tri3 = tri * 3;
    const tri6 = tri * 6;
    let ai = tri3 + 0;
    let bi = tri3 + 1;
    let ci = tri3 + 2;
    if (index) {
      ai = index[ai];
      bi = index[bi];
      ci = index[ci];
    }
    if (!normalized) {
      ai = ai * stride + bufferOffset;
      bi = bi * stride + bufferOffset;
      ci = ci * stride + bufferOffset;
    }
    for (let el = 0; el < 3; el++) {
      let a, b, c;
      if (normalized) {
        a = posAttr[getters[el]](ai);
        b = posAttr[getters[el]](bi);
        c = posAttr[getters[el]](ci);
      } else {
        a = posArr[ai + el];
        b = posArr[bi + el];
        c = posArr[ci + el];
      }
      let min = a;
      if (b < min) min = b;
      if (c < min) min = c;
      let max = a;
      if (b > max) max = b;
      if (c > max) max = c;
      const halfExtents = (max - min) / 2;
      const el2 = el * 2;
      triangleBounds[tri6 + el2 + 0] = min + halfExtents;
      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;
    }
  }
  return triangleBounds;
}
function arrayToBox(nodeIndex32, array, target) {
  target.min.x = array[nodeIndex32];
  target.min.y = array[nodeIndex32 + 1];
  target.min.z = array[nodeIndex32 + 2];
  target.max.x = array[nodeIndex32 + 3];
  target.max.y = array[nodeIndex32 + 4];
  target.max.z = array[nodeIndex32 + 5];
  return target;
}
function getLongestEdgeIndex(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i = 0; i < 3; i++) {
    const dist = bounds[i + 3] - bounds[i];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i;
    }
  }
  return splitDimIdx;
}
function copyBounds(source, target) {
  target.set(source);
}
function unionBounds(a, b, target) {
  let aVal, bVal;
  for (let d = 0; d < 3; d++) {
    const d3 = d + 3;
    aVal = a[d];
    bVal = b[d];
    target[d] = aVal < bVal ? aVal : bVal;
    aVal = a[d3];
    bVal = b[d3];
    target[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds(startIndex, triangleBounds, bounds) {
  for (let d = 0; d < 3; d++) {
    const tCenter = triangleBounds[startIndex + 2 * d];
    const tHalf = triangleBounds[startIndex + 2 * d + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d]) {
      bounds[d] = tMin;
    }
    if (tMax > bounds[d + 3]) {
      bounds[d + 3] = tMax;
    }
  }
}
function computeSurfaceArea(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}
const BIN_COUNT = 32;
const binsSort = (a, b) => a.candidate - b.candidate;
const sahBins = new Array(BIN_COUNT).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
const leftBounds = new Float32Array(6);
function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER) {
    axis = getLongestEdgeIndex(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE) {
    axis = getLongestEdgeIndex(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH) {
    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST * count;
    const cStart = offset * 6;
    const cEnd = (offset + count) * 6;
    for (let a = 0; a < 3; a++) {
      const axisLeft = centroidBoundingData[a];
      const axisRight = centroidBoundingData[a + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT;
      if (count < BIN_COUNT / 4) {
        const truncatedBins = [...sahBins];
        truncatedBins.length = count;
        let b = 0;
        for (let c = cStart; c < cEnd; c += 6, b++) {
          const bin = truncatedBins[b];
          bin.candidate = triangleBounds[c + 2 * a];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d = 0; d < 3; d++) {
            rightCacheBounds[d] = Infinity;
            rightCacheBounds[d + 3] = -Infinity;
            leftCacheBounds[d] = Infinity;
            leftCacheBounds[d + 3] = -Infinity;
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
          expandByTriangleBounds(c, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort);
        let splitCount = count;
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi + 1, 1);
            splitCount--;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const center = triangleBounds[c + 2 * a];
          for (let bi = 0; bi < splitCount; bi++) {
            const bin = truncatedBins[bi];
            if (center >= bin.candidate) {
              expandByTriangleBounds(c, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds(c, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds2 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds2) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i = 0; i < BIN_COUNT; i++) {
          const bin = sahBins[i];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i * binWidth;
          const bounds = bin.bounds;
          for (let d = 0; d < 3; d++) {
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const triCenter = triangleBounds[c + 2 * a];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;
          const bin = sahBins[binIndex];
          bin.count++;
          expandByTriangleBounds(c, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins[BIN_COUNT - 1];
        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i = BIN_COUNT - 2; i >= 0; i--) {
          const bin = sahBins[i];
          const nextBin = sahBins[i + 1];
          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i = 0; i < BIN_COUNT - 1; i++) {
          const bin = sahBins[i];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins[i + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds(bounds, leftBounds);
            } else {
              unionBounds(bounds, leftBounds, leftBounds);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage(triangleBounds, offset, count, axis) {
  let avg = 0;
  for (let i = offset, end = offset + count; i < end; i++) {
    avg += triangleBounds[i * 6 + axis * 2];
  }
  return avg / count;
}
class MeshBVHNode {
  constructor() {
    this.boundingData = new Float32Array(6);
  }
}
function partition(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i = 0; i < 3; i++) {
        let t0 = index[left * 3 + i];
        index[left * 3 + i] = index[right * 3 + i];
        index[right * 3 + i] = t0;
      }
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
function partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      let t = indirectBuffer[left];
      indirectBuffer[left] = indirectBuffer[right];
      indirectBuffer[right] = t;
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
function IS_LEAF(n16, uint16Array2) {
  return uint16Array2[n16 + 15] === 65535;
}
function OFFSET(n32, uint32Array2) {
  return uint32Array2[n32 + 6];
}
function COUNT(n16, uint16Array2) {
  return uint16Array2[n16 + 14];
}
function LEFT_NODE(n32) {
  return n32 + 8;
}
function RIGHT_NODE(n32, uint32Array2) {
  return uint32Array2[n32 + 6];
}
function SPLIT_AXIS(n32, uint32Array2) {
  return uint32Array2[n32 + 7];
}
function BOUNDING_DATA_INDEX(n32) {
  return n32;
}
let float32Array, uint32Array, uint16Array, uint8Array;
const MAX_POINTER = Math.pow(2, 32);
function countNodes(node) {
  if ("count" in node) {
    return 1;
  } else {
    return 1 + countNodes(node.left) + countNodes(node.right);
  }
}
function populateBuffer(byteOffset, node, buffer) {
  float32Array = new Float32Array(buffer);
  uint32Array = new Uint32Array(buffer);
  uint16Array = new Uint16Array(buffer);
  uint8Array = new Uint8Array(buffer);
  return _populateBuffer(byteOffset, node);
}
function _populateBuffer(byteOffset, node) {
  const stride4Offset = byteOffset / 4;
  const stride2Offset = byteOffset / 2;
  const isLeaf = "count" in node;
  const boundingData = node.boundingData;
  for (let i = 0; i < 6; i++) {
    float32Array[stride4Offset + i] = boundingData[i];
  }
  if (isLeaf) {
    if (node.buffer) {
      const buffer = node.buffer;
      uint8Array.set(new Uint8Array(buffer), byteOffset);
      for (let offset = byteOffset, l2 = byteOffset + buffer.byteLength; offset < l2; offset += BYTES_PER_NODE) {
        const offset2 = offset / 2;
        if (!IS_LEAF(offset2, uint16Array)) {
          uint32Array[offset / 4 + 6] += stride4Offset;
        }
      }
      return byteOffset + buffer.byteLength;
    } else {
      const offset = node.offset;
      const count = node.count;
      uint32Array[stride4Offset + 6] = offset;
      uint16Array[stride2Offset + 14] = count;
      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;
      return byteOffset + BYTES_PER_NODE;
    }
  } else {
    const left = node.left;
    const right = node.right;
    const splitAxis = node.splitAxis;
    let nextUnusedPointer;
    nextUnusedPointer = _populateBuffer(byteOffset + BYTES_PER_NODE, left);
    if (nextUnusedPointer / 4 > MAX_POINTER) {
      throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
    }
    uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;
    nextUnusedPointer = _populateBuffer(nextUnusedPointer, right);
    uint32Array[stride4Offset + 7] = splitAxis;
    return nextUnusedPointer;
  }
}
function generateIndirectBuffer(geometry, useSharedArrayBuffer) {
  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;
  const useUint32 = triCount > 2 ** 16;
  const byteCount = useUint32 ? 4 : 2;
  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);
  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);
  for (let i = 0, l2 = indirectBuffer.length; i < l2; i++) {
    indirectBuffer[i] = i;
  }
  return indirectBuffer;
}
function buildTree(bvh, triangleBounds, offset, count, options) {
  const {
    maxDepth,
    verbose,
    maxLeafTris,
    strategy,
    onProgress,
    indirect
  } = options;
  const indirectBuffer = bvh._indirectBuffer;
  const geometry = bvh.geometry;
  const indexArray = geometry.index ? geometry.index.array : null;
  const partionFunc = indirect ? partition_indirect : partition;
  const totalTriangles = getTriCount(geometry);
  const cacheCentroidBoundingData = new Float32Array(6);
  let reachedMaxDepth = false;
  const root = new MeshBVHNode();
  getBounds(triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData);
  splitNode(root, offset, count, cacheCentroidBoundingData);
  return root;
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset2, count2, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geometry);
      }
    }
    if (count2 <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset2 + count2);
      node.offset = offset2;
      node.count = count2;
      return node;
    }
    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset2, count2, strategy);
    if (split.axis === -1) {
      triggerProgress(offset2 + count2);
      node.offset = offset2;
      node.count = count2;
      return node;
    }
    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset2, count2, split);
    if (splitOffset === offset2 || splitOffset === offset2 + count2) {
      triggerProgress(offset2 + count2);
      node.offset = offset2;
      node.count = count2;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode();
      const lstart = offset2;
      const lcount = splitOffset - offset2;
      node.left = left;
      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode();
      const rstart = splitOffset;
      const rcount = count2 - lcount;
      node.right = right;
      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
}
function buildPackedTree(bvh, options) {
  const geometry = bvh.geometry;
  if (options.indirect) {
    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);
    if (hasGroupGaps(geometry, options.range) && !options.verbose) {
      console.warn(
        'MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
      );
    }
  }
  if (!bvh._indirectBuffer) {
    ensureIndex(geometry, options);
  }
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  const triangleBounds = computeTriangleBounds(geometry);
  const geometryRanges = options.indirect ? getFullGeometryRange(geometry, options.range) : getRootIndexRanges(geometry, options.range);
  bvh._roots = geometryRanges.map((range) => {
    const root = buildTree(bvh, triangleBounds, range.offset, range.count, options);
    const nodeCount = countNodes(root);
    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);
    populateBuffer(0, root, buffer);
    return buffer;
  });
}
class SeparatingAxisBounds {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l2 = points.length; i < l2; i++) {
      const p = points[i];
      const val = p[field];
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l2 = points.length; i < l2; i++) {
      const p = points[i];
      const val = axis.dot(p);
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
}
SeparatingAxisBounds.prototype.setFromBox = function() {
  const p = new Vector3();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y + boxMax.y * (1 - y);
          p.z = boxMin.z * z + boxMax.z * (1 - z);
          const val = axis.dot(p);
          min = Math.min(val, min);
          max = Math.max(val, max);
        }
      }
    }
    this.min = min;
    this.max = max;
  };
}();
const closestPointLineToLine = function() {
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const v02 = new Vector3();
  return function closestPointLineToLine2(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v2 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v2);
    dir1.subVectors(l1.end, l1.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d, d2;
    if (denom !== 0) {
      d = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d = 0;
    }
    d2 = (d0232 + d * d3210) / d3232;
    result.x = d;
    result.y = d2;
  };
}();
const closestPointsSegmentToSegment = function() {
  const paramResult = new Vector2();
  const temp12 = new Vector3();
  const temp22 = new Vector3();
  return function closestPointsSegmentToSegment2(l1, l2, target1, target2) {
    closestPointLineToLine(l1, l2, paramResult);
    let d = paramResult.x;
    let d2 = paramResult.y;
    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {
      l1.at(d, target1);
      l2.at(d2, target2);
      return;
    } else if (d >= 0 && d <= 1) {
      if (d2 < 0) {
        l2.at(0, target2);
      } else {
        l2.at(1, target2);
      }
      l1.closestPointToPoint(target2, true, target1);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target2);
      return;
    } else {
      let p;
      if (d < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d2 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp12;
      const closestPoint2 = temp22;
      l1.closestPointToPoint(p2, true, temp12);
      l2.closestPointToPoint(p, true, temp22);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target2.copy(p2);
        return;
      } else {
        target1.copy(p);
        target2.copy(closestPoint2);
        return;
      }
    }
  };
}();
const sphereIntersectTriangle = function() {
  const closestPointTemp = new Vector3();
  const projectedPointTemp = new Vector3();
  const planeTemp = new Plane$1();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle2(sphere, triangle3) {
    const { radius, center } = sphere;
    const { a, b, c } = triangle3;
    lineTemp.start = a;
    lineTemp.end = b;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius) return true;
    lineTemp.start = a;
    lineTemp.end = c;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius) return true;
    lineTemp.start = b;
    lineTemp.end = c;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius) return true;
    const plane = triangle3.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle3.containsPoint(pp);
      if (cp) return true;
    }
    return false;
  };
}();
const ZERO_EPSILON = 1e-15;
function isNearZero(value) {
  return Math.abs(value) < ZERO_EPSILON;
}
class ExtendedTriangle extends Triangle {
  constructor(...args) {
    super(...args);
    this.isExtendedTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector3());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());
    this.points = [this.a, this.b, this.c];
    this.sphere = new Sphere();
    this.plane = new Plane$1();
    this.needsUpdate = true;
  }
  intersectsSphere(sphere) {
    return sphereIntersectTriangle(sphere, this);
  }
  update() {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a, b);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b, c);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c, a);
    sab3.setFromPoints(axis3, points);
    this.sphere.setFromPoints(this.points);
    this.plane.setFromNormalAndCoplanarPoint(axis0, a);
    this.needsUpdate = false;
  }
}
ExtendedTriangle.prototype.closestPointToSegment = function() {
  const point1 = new Vector3();
  const point2 = new Vector3();
  const edge = new Line3();
  return function distanceToSegment(segment, target1 = null, target2 = null) {
    const { start, end } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      const nexti = (i + 1) % 3;
      edge.start.copy(points[i]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1) target1.copy(point1);
        if (target2) target2.copy(point2);
      }
    }
    this.closestPointToPoint(start, point1);
    distSq = start.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1) target1.copy(point1);
      if (target2) target2.copy(start);
    }
    this.closestPointToPoint(end, point1);
    distSq = end.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1) target1.copy(point1);
      if (target2) target2.copy(end);
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
ExtendedTriangle.prototype.intersectsTriangle = function() {
  const saTri2 = new ExtendedTriangle();
  const arr1 = new Array(3);
  const arr2 = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  const dir = new Vector3();
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const tempDir = new Vector3();
  const edge = new Line3();
  const edge1 = new Line3();
  const edge2 = new Line3();
  const tempPoint = new Vector3();
  function triIntersectPlane(tri, plane, targetEdge) {
    const points = tri.points;
    let count = 0;
    let startPointIntersection = -1;
    for (let i = 0; i < 3; i++) {
      const { start, end } = edge;
      start.copy(points[i]);
      end.copy(points[(i + 1) % 3]);
      edge.delta(dir);
      const startIntersects = isNearZero(plane.distanceToPoint(start));
      if (isNearZero(plane.normal.dot(dir)) && startIntersects) {
        targetEdge.copy(edge);
        count = 2;
        break;
      }
      const doesIntersect = plane.intersectLine(edge, tempPoint);
      if (!doesIntersect && startIntersects) {
        tempPoint.copy(start);
      }
      if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {
        if (count <= 1) {
          const point = count === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          if (startIntersects) {
            startPointIntersection = count;
          }
        } else if (count >= 2) {
          const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          count = 2;
          break;
        }
        count++;
        if (count === 2 && startPointIntersection === -1) {
          break;
        }
      }
    }
    return count;
  }
  return function intersectsTriangle(other, target = null, suppressLog = false) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isExtendedTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const plane1 = this.plane;
    const plane2 = other.plane;
    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {
      const satBounds1 = this.satBounds;
      const satAxes1 = this.satAxes;
      arr2[0] = other.a;
      arr2[1] = other.b;
      arr2[2] = other.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds1[i];
        const sa = satAxes1[i];
        cachedSatBounds.setFromPoints(sa, arr2);
        if (sb.isSeparated(cachedSatBounds)) return false;
      }
      const satBounds2 = other.satBounds;
      const satAxes2 = other.satAxes;
      arr1[0] = this.a;
      arr1[1] = this.b;
      arr1[2] = this.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds2[i];
        const sa = satAxes2[i];
        cachedSatBounds.setFromPoints(sa, arr1);
        if (sb.isSeparated(cachedSatBounds)) return false;
      }
      for (let i = 0; i < 4; i++) {
        const sa1 = satAxes1[i];
        for (let i2 = 0; i2 < 4; i2++) {
          const sa2 = satAxes2[i2];
          cachedAxis.crossVectors(sa1, sa2);
          cachedSatBounds.setFromPoints(cachedAxis, arr1);
          cachedSatBounds2.setFromPoints(cachedAxis, arr2);
          if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;
        }
      }
      if (target) {
        if (!suppressLog) {
          console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
        }
        target.start.set(0, 0, 0);
        target.end.set(0, 0, 0);
      }
      return true;
    } else {
      const count1 = triIntersectPlane(this, plane2, edge1);
      if (count1 === 1 && other.containsPoint(edge1.end)) {
        if (target) {
          target.start.copy(edge1.end);
          target.end.copy(edge1.end);
        }
        return true;
      } else if (count1 !== 2) {
        return false;
      }
      const count2 = triIntersectPlane(other, plane1, edge2);
      if (count2 === 1 && this.containsPoint(edge2.end)) {
        if (target) {
          target.start.copy(edge2.end);
          target.end.copy(edge2.end);
        }
        return true;
      } else if (count2 !== 2) {
        return false;
      }
      edge1.delta(dir1);
      edge2.delta(dir2);
      if (dir1.dot(dir2) < 0) {
        let tmp2 = edge2.start;
        edge2.start = edge2.end;
        edge2.end = tmp2;
      }
      const s1 = edge1.start.dot(dir1);
      const e1 = edge1.end.dot(dir1);
      const s2 = edge2.start.dot(dir1);
      const e2 = edge2.end.dot(dir1);
      const separated1 = e1 < s2;
      const separated2 = s1 < e2;
      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {
        return false;
      }
      if (target) {
        tempDir.subVectors(edge1.start, edge2.start);
        if (tempDir.dot(dir1) > 0) {
          target.start.copy(edge1.start);
        } else {
          target.start.copy(edge2.start);
        }
        tempDir.subVectors(edge1.end, edge2.end);
        if (tempDir.dot(dir1) < 0) {
          target.end.copy(edge1.end);
        } else {
          target.end.copy(edge2.end);
        }
      }
      return true;
    }
  };
}();
ExtendedTriangle.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
ExtendedTriangle.prototype.distanceToTriangle = function() {
  const point = new Vector3();
  const point2 = new Vector3();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line3();
  const line2 = new Line3();
  return function distanceToTriangle(other, target1 = null, target2 = null) {
    const lineTarget = target1 || target2 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target2) {
        if (target1) lineTarget.getCenter(target1);
        if (target2) lineTarget.getCenter(target2);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      let dist;
      const field = cornerFields[i];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1) target1.copy(point);
        if (target2) target2.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1) target1.copy(thisVec);
        if (target2) target2.copy(point);
      }
    }
    for (let i = 0; i < 3; i++) {
      const f11 = cornerFields[i];
      const f12 = cornerFields[(i + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i2 = 0; i2 < 3; i2++) {
        const f21 = cornerFields[i2];
        const f22 = cornerFields[(i2 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1) target1.copy(point);
          if (target2) target2.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
class OrientedBox {
  constructor(min, max, matrix) {
    this.isOrientedBox = true;
    this.min = new Vector3();
    this.max = new Vector3();
    this.matrix = new Matrix4();
    this.invMatrix = new Matrix4();
    this.points = new Array(8).fill().map(() => new Vector3());
    this.satAxes = new Array(3).fill().map(() => new Vector3());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.needsUpdate = false;
    if (min) this.min.copy(min);
    if (max) this.max.copy(max);
    if (matrix) this.matrix.copy(matrix);
  }
  set(min, max, matrix) {
    this.min.copy(min);
    this.max.copy(max);
    this.matrix.copy(matrix);
    this.needsUpdate = true;
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
}
OrientedBox.prototype.update = /* @__PURE__ */ function() {
  return function update() {
    const matrix = this.matrix;
    const min = this.min;
    const max = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;
          const v = points[i];
          v.x = x ? max.x : min.x;
          v.y = y ? max.y : min.y;
          v.z = z ? max.z : min.z;
          v.applyMatrix4(matrix);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      const index = 1 << i;
      const pi = points[index];
      axis.subVectors(minVec, pi);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
}();
OrientedBox.prototype.intersectsBox = function() {
  const aabbBounds = new SeparatingAxisBounds();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds)) return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds)) return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds)) return false;
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds)) return false;
    }
    return true;
  };
}();
OrientedBox.prototype.intersectsTriangle = function() {
  const saTri = new ExtendedTriangle();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  return function intersectsTriangle(triangle3) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle3.isExtendedTriangle) {
      saTri.copy(triangle3);
      saTri.update();
      triangle3 = saTri;
    } else if (triangle3.needsUpdate) {
      triangle3.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle3.a;
    pointsArr[1] = triangle3.b;
    pointsArr[2] = triangle3.c;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds[i];
      const sa = satAxes[i];
      cachedSatBounds.setFromPoints(sa, pointsArr);
      if (sb.isSeparated(cachedSatBounds)) return false;
    }
    const triSatBounds = triangle3.satBounds;
    const triSatAxes = triangle3.satAxes;
    const points = this.points;
    for (let i = 0; i < 3; i++) {
      const sb = triSatBounds[i];
      const sa = triSatAxes[i];
      cachedSatBounds.setFromPoints(sa, points);
      if (sb.isSeparated(cachedSatBounds)) return false;
    }
    for (let i = 0; i < 3; i++) {
      const sa1 = satAxes[i];
      for (let i2 = 0; i2 < 4; i2++) {
        const sa2 = triSatAxes[i2];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;
      }
    }
    return true;
  };
}();
OrientedBox.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function closestPointToPoint2(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
}();
OrientedBox.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
OrientedBox.prototype.distanceToBox = function() {
  const xyzFields = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line3());
  const segments2 = new Array(12).fill().map(() => new Line3());
  const point1 = new Vector3();
  const point2 = new Vector3();
  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target2) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1) target1.copy(point1);
        if (target2) target2.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 8; i++) {
      const p = points[i];
      point2.copy(p).clamp(min, max);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1) target1.copy(p);
        if (target2) target2.copy(point2);
        if (dist < threshold2) return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i = 0; i < 3; i++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i2 = 0; i2 <= 1; i2++) {
          const nextIndex = (i + 1) % 3;
          const nextIndex2 = (i + 2) % 3;
          const index = i1 << nextIndex | i2 << nextIndex2;
          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields[i];
          const f2 = xyzFields[nextIndex];
          const f3 = xyzFields[nextIndex2];
          const line2 = segments2[count];
          const start = line2.start;
          const end = line2.end;
          start[f1] = min[f1];
          start[f2] = i1 ? min[f2] : max[f2];
          start[f3] = i2 ? min[f3] : max[f2];
          end[f1] = max[f1];
          end[f2] = i1 ? min[f2] : max[f2];
          end[f3] = i2 ? min[f3] : max[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          point2.x = x ? max.x : min.x;
          point2.y = y ? max.y : min.y;
          point2.z = z ? max.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1) target1.copy(point1);
            if (target2) target2.copy(point2);
            if (dist < threshold2) return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i = 0; i < 12; i++) {
      const l1 = segments1[i];
      for (let i2 = 0; i2 < 12; i2++) {
        const l2 = segments2[i2];
        closestPointsSegmentToSegment(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1) target1.copy(point1);
          if (target2) target2.copy(point2);
          if (dist < threshold2) return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
class PrimitivePool {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives = this._primitives;
    if (primitives.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
}
class ExtendedTrianglePoolBase extends PrimitivePool {
  constructor() {
    super(() => new ExtendedTriangle());
  }
}
const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();
class _BufferStack {
  constructor() {
    this.float32Array = null;
    this.uint16Array = null;
    this.uint32Array = null;
    const stack = [];
    let prevBuffer = null;
    this.setBuffer = (buffer) => {
      if (prevBuffer) {
        stack.push(prevBuffer);
      }
      prevBuffer = buffer;
      this.float32Array = new Float32Array(buffer);
      this.uint16Array = new Uint16Array(buffer);
      this.uint32Array = new Uint32Array(buffer);
    };
    this.clearBuffer = () => {
      prevBuffer = null;
      this.float32Array = null;
      this.uint16Array = null;
      this.uint32Array = null;
      if (stack.length !== 0) {
        this.setBuffer(stack.pop());
      }
    };
  }
}
const BufferStack = new _BufferStack();
let _box1, _box2;
const boxStack = [];
const boxPool = /* @__PURE__ */ new PrimitivePool(() => new Box3());
function shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {
  _box1 = boxPool.getPrimitive();
  _box2 = boxPool.getPrimitive();
  boxStack.push(_box1, _box2);
  BufferStack.setBuffer(bvh._roots[root]);
  const result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
  BufferStack.clearBuffer();
  boxPool.releasePrimitive(_box1);
  boxPool.releasePrimitive(_box2);
  boxStack.pop();
  boxStack.pop();
  const length = boxStack.length;
  if (length > 0) {
    _box2 = boxStack[length - 1];
    _box1 = boxStack[length - 2];
  }
  return result;
}
function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array2, _box1);
    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);
  } else {
    let getLeftOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array3, uint32Array: uint32Array3 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array3)) {
        nodeIndex322 = LEFT_NODE(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array3);
    }, getRightEndOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array3, uint32Array: uint32Array3 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array3)) {
        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array3);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array3) + COUNT(nodeIndex162, uint16Array3);
    };
    const left = LEFT_NODE(nodeIndex32);
    const right = RIGHT_NODE(nodeIndex32, uint32Array2);
    let c1 = left;
    let c2 = right;
    let score1, score2;
    let box1, box2;
    if (nodeScoreFunc) {
      box1 = _box1;
      box2 = _box2;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array2, box1);
      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array2, box2);
      score1 = nodeScoreFunc(box1);
      score2 = nodeScoreFunc(box2);
      if (score2 < score1) {
        c1 = right;
        c2 = left;
        const temp5 = score1;
        score1 = score2;
        score2 = temp5;
        box1 = box2;
      }
    }
    if (!box1) {
      box1 = _box1;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array2, box1);
    }
    const isC1Leaf = IS_LEAF(c1 * 2, uint16Array2);
    const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);
    let c1StopTraversal;
    if (c1Intersection === CONTAINED) {
      const offset = getLeftOffset(c1);
      const end = getRightEndOffset(c1);
      const count = end - offset;
      c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);
    } else {
      c1StopTraversal = c1Intersection && shapecastTraverse(
        c1,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c1StopTraversal) return true;
    box2 = _box2;
    arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array2, box2);
    const isC2Leaf = IS_LEAF(c2 * 2, uint16Array2);
    const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);
    let c2StopTraversal;
    if (c2Intersection === CONTAINED) {
      const offset = getLeftOffset(c2);
      const end = getRightEndOffset(c2);
      const count = end - offset;
      c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);
    } else {
      c2StopTraversal = c2Intersection && shapecastTraverse(
        c2,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c2StopTraversal) return true;
    return false;
  }
}
const temp = /* @__PURE__ */ new Vector3();
const temp1$2 = /* @__PURE__ */ new Vector3();
function closestPointToPoint(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
  const minThresholdSq = minThreshold * minThreshold;
  const maxThresholdSq = maxThreshold * maxThreshold;
  let closestDistanceSq = Infinity;
  let closestDistanceTriIndex = null;
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        temp.copy(point).clamp(box.min, box.max);
        return temp.distanceToSquared(point);
      },
      intersectsBounds: (box, isLeaf, score) => {
        return score < closestDistanceSq && score < maxThresholdSq;
      },
      intersectsTriangle: (tri, triIndex) => {
        tri.closestPointToPoint(point, temp);
        const distSq = point.distanceToSquared(temp);
        if (distSq < closestDistanceSq) {
          temp1$2.copy(temp);
          closestDistanceSq = distSq;
          closestDistanceTriIndex = triIndex;
        }
        if (distSq < minThresholdSq) {
          return true;
        } else {
          return false;
        }
      }
    }
  );
  if (closestDistanceSq === Infinity) return null;
  const closestDistance = Math.sqrt(closestDistanceSq);
  if (!target.point) target.point = temp1$2.clone();
  else target.point.copy(temp1$2);
  target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;
  return target;
}
const _vA = /* @__PURE__ */ new Vector3();
const _vB = /* @__PURE__ */ new Vector3();
const _vC = /* @__PURE__ */ new Vector3();
const _uvA = /* @__PURE__ */ new Vector2();
const _uvB = /* @__PURE__ */ new Vector2();
const _uvC = /* @__PURE__ */ new Vector2();
const _normalA = /* @__PURE__ */ new Vector3();
const _normalB = /* @__PURE__ */ new Vector3();
const _normalC = /* @__PURE__ */ new Vector3();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
function checkIntersection(ray2, pA, pB, pC, point, side, near, far) {
  let intersect2;
  if (side === BackSide) {
    intersect2 = ray2.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect2 = ray2.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);
  }
  if (intersect2 === null) return null;
  const distance = ray2.origin.distanceTo(point);
  if (distance < near || distance > far) return null;
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection(ray2, position, normal, uv, uv1, a, b, c, side, near, far) {
  _vA.fromBufferAttribute(position, a);
  _vB.fromBufferAttribute(position, b);
  _vC.fromBufferAttribute(position, c);
  const intersection = checkIntersection(ray2, _vA, _vB, _vC, _intersectionPoint, side, near, far);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);
      _uvB.fromBufferAttribute(uv, b);
      _uvC.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv1) {
      _uvA.fromBufferAttribute(uv1, a);
      _uvB.fromBufferAttribute(uv1, b);
      _uvC.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3());
      if (intersection.normal.dot(ray2.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
    intersection.faceIndex = a;
  }
  return intersection;
}
function intersectTri(geo, side, ray2, tri, intersections, near, far) {
  const triOffset = tri * 3;
  let a = triOffset + 0;
  let b = triOffset + 1;
  let c = triOffset + 2;
  const index = geo.index;
  if (geo.index) {
    a = index.getX(a);
    b = index.getX(b);
    c = index.getX(c);
  }
  const { position, normal, uv, uv1 } = geo.attributes;
  const intersection = checkBufferGeometryIntersection(ray2, position, normal, uv, uv1, a, b, c, side, near, far);
  if (intersection) {
    intersection.faceIndex = tri;
    if (intersections) intersections.push(intersection);
    return intersection;
  }
  return null;
}
function setTriangle(tri, i, index, pos) {
  const ta = tri.a;
  const tb = tri.b;
  const tc = tri.c;
  let i0 = i;
  let i1 = i + 1;
  let i2 = i + 2;
  if (index) {
    i0 = index.getX(i0);
    i1 = index.getX(i1);
    i2 = index.getX(i2);
  }
  ta.x = pos.getX(i0);
  ta.y = pos.getY(i0);
  ta.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc.x = pos.getX(i2);
  tc.y = pos.getY(i2);
  tc.z = pos.getZ(i2);
}
function intersectTris(bvh, side, ray2, offset, count, intersections, near, far) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    intersectTri(geometry, side, ray2, i, intersections, near, far);
  }
}
function intersectClosestTri(bvh, side, ray2, offset, count, near, far) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray2, i, null, near, far);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle3) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l2 = count + offset; i < l2; i++) {
    let tri;
    tri = i;
    setTriangle(triangle3, tri * 3, index, pos);
    triangle3.needsUpdate = true;
    if (intersectsTriangleFunc(triangle3, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}
function refit(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array2, uint16Array2, float32Array2;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l2 = roots.length; i < l2; i++) {
    buffer = roots[i];
    uint32Array2 = new Uint32Array(buffer);
    uint16Array2 = new Uint16Array(buffer);
    float32Array2 = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array2[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array2[node32Index + 6];
      const count = uint16Array2[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = 3 * offset, l2 = 3 * (offset + count); i < l2; i++) {
        let index = indexArr[i];
        const x = posAttr.getX(index);
        const y = posAttr.getY(index);
        const z = posAttr.getZ(index);
        if (x < minx) minx = x;
        if (x > maxx) maxx = x;
        if (y < miny) miny = y;
        if (y > maxy) maxy = y;
        if (z < minz) minz = z;
        if (z > maxz) maxz = z;
      }
      if (float32Array2[node32Index + 0] !== minx || float32Array2[node32Index + 1] !== miny || float32Array2[node32Index + 2] !== minz || float32Array2[node32Index + 3] !== maxx || float32Array2[node32Index + 4] !== maxy || float32Array2[node32Index + 5] !== maxz) {
        float32Array2[node32Index + 0] = minx;
        float32Array2[node32Index + 1] = miny;
        float32Array2[node32Index + 2] = minz;
        float32Array2[node32Index + 3] = maxx;
        float32Array2[node32Index + 4] = maxy;
        float32Array2[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array2[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array2[lefti];
          const maxLeftValue = float32Array2[lefti + 3];
          const minRightValue = float32Array2[righti];
          const maxRightValue = float32Array2[righti + 3];
          float32Array2[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array2[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}
function intersectRay(nodeIndex32, array, ray2, near, far) {
  let tmin, tmax, tymin, tymax, tzmin, tzmax;
  const invdirx = 1 / ray2.direction.x, invdiry = 1 / ray2.direction.y, invdirz = 1 / ray2.direction.z;
  const ox = ray2.origin.x;
  const oy = ray2.origin.y;
  const oz = ray2.origin.z;
  let minx = array[nodeIndex32];
  let maxx = array[nodeIndex32 + 3];
  let miny = array[nodeIndex32 + 1];
  let maxy = array[nodeIndex32 + 3 + 1];
  let minz = array[nodeIndex32 + 2];
  let maxz = array[nodeIndex32 + 3 + 2];
  if (invdirx >= 0) {
    tmin = (minx - ox) * invdirx;
    tmax = (maxx - ox) * invdirx;
  } else {
    tmin = (maxx - ox) * invdirx;
    tmax = (minx - ox) * invdirx;
  }
  if (invdiry >= 0) {
    tymin = (miny - oy) * invdiry;
    tymax = (maxy - oy) * invdiry;
  } else {
    tymin = (maxy - oy) * invdiry;
    tymax = (miny - oy) * invdiry;
  }
  if (tmin > tymax || tymin > tmax) return false;
  if (tymin > tmin || isNaN(tmin)) tmin = tymin;
  if (tymax < tmax || isNaN(tmax)) tmax = tymax;
  if (invdirz >= 0) {
    tzmin = (minz - oz) * invdirz;
    tzmax = (maxz - oz) * invdirz;
  } else {
    tzmin = (maxz - oz) * invdirz;
    tzmax = (minz - oz) * invdirz;
  }
  if (tmin > tzmax || tzmin > tmax) return false;
  if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
  if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
  return tmin <= far && tmax >= near;
}
function intersectTris_indirect(bvh, side, ray2, offset, count, intersections, near, far) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    let vi = _indirectBuffer ? _indirectBuffer[i] : i;
    intersectTri(geometry, side, ray2, vi, intersections, near, far);
  }
}
function intersectClosestTri_indirect(bvh, side, ray2, offset, count, near, far) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray2, _indirectBuffer ? _indirectBuffer[i] : i, null, near, far);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles_indirect(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle3) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l2 = count + offset; i < l2; i++) {
    let tri;
    tri = bvh.resolveTriangleIndex(i);
    setTriangle(triangle3, tri * 3, index, pos);
    triangle3.needsUpdate = true;
    if (intersectsTriangleFunc(triangle3, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}
function raycast(bvh, root, side, ray2, intersects2, near, far) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast$1(0, bvh, side, ray2, intersects2, near, far);
  BufferStack.clearBuffer();
}
function _raycast$1(nodeIndex32, bvh, side, ray2, intersects2, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    intersectTris(bvh, side, ray2, offset, count, intersects2, near, far);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array2, ray2, near, far)) {
      _raycast$1(leftIndex, bvh, side, ray2, intersects2, near, far);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array2);
    if (intersectRay(rightIndex, float32Array2, ray2, near, far)) {
      _raycast$1(rightIndex, bvh, side, ray2, intersects2, near, far);
    }
  }
}
const _xyzFields$1 = ["x", "y", "z"];
function raycastFirst(bvh, root, side, ray2, near, far) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst$1(0, bvh, side, ray2, near, far);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst$1(nodeIndex32, bvh, side, ray2, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    return intersectClosestTri(bvh, side, ray2, offset, count, near, far);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array2);
    const xyzAxis = _xyzFields$1[splitAxis];
    const rayDir = ray2.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array2);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array2);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array2, ray2, near, far);
    const c1Result = c1Intersection ? _raycastFirst$1(c1, bvh, side, ray2, near, far) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array2[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array2[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array2, ray2, near, far);
    const c2Result = c2Intersection ? _raycastFirst$1(c2, bvh, side, ray2, near, far) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
const boundingBox$1 = /* @__PURE__ */ new Box3();
const triangle$1 = /* @__PURE__ */ new ExtendedTriangle();
const triangle2$1 = /* @__PURE__ */ new ExtendedTriangle();
const invertedMat$1 = /* @__PURE__ */ new Matrix4();
const obb$4 = /* @__PURE__ */ new OrientedBox();
const obb2$3 = /* @__PURE__ */ new OrientedBox();
function intersectsGeometry(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry$1(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry$1(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb$4.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb$4;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    invertedMat$1.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array2, obb2$3);
      obb2$3.matrix.copy(invertedMat$1);
      obb2$3.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2$3.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset * 3, l2 = (count + offset) * 3; i < l2; i += 3) {
            setTriangle(triangle2$1, i, thisIndex, thisPos);
            triangle2$1.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2$1)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset * 3, l2 = (count + offset) * 3; i < l2; i += 3) {
        setTriangle(triangle$1, i, thisIndex, thisPos);
        triangle$1.a.applyMatrix4(invertedMat$1);
        triangle$1.b.applyMatrix4(invertedMat$1);
        triangle$1.c.applyMatrix4(invertedMat$1);
        triangle$1.needsUpdate = true;
        for (let i2 = 0, l22 = index.count; i2 < l22; i2 += 3) {
          setTriangle(triangle2$1, i2, index, pos);
          triangle2$1.needsUpdate = true;
          if (triangle$1.intersectsTriangle(triangle2$1)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array2[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array2, boundingBox$1);
    const leftIntersection = cachedObb.intersectsBox(boundingBox$1) && _intersectsGeometry$1(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection) return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array2, boundingBox$1);
    const rightIntersection = cachedObb.intersectsBox(boundingBox$1) && _intersectsGeometry$1(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection) return true;
    return false;
  }
}
const tempMatrix$1 = /* @__PURE__ */ new Matrix4();
const obb$3 = /* @__PURE__ */ new OrientedBox();
const obb2$2 = /* @__PURE__ */ new OrientedBox();
const temp1$1 = /* @__PURE__ */ new Vector3();
const temp2$1 = /* @__PURE__ */ new Vector3();
const temp3$1 = /* @__PURE__ */ new Vector3();
const temp4$1 = /* @__PURE__ */ new Vector3();
function closestPointToGeometry(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb$3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb$3.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle3 = ExtendedTrianglePool.getPrimitive();
  const triangle22 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp1$1;
  let tempTargetDest1 = temp2$1;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3$1;
    tempTargetDest2 = temp4$1;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix$1.copy(geometryToBvh).invert();
  obb2$2.matrix.copy(tempMatrix$1);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb$3.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb2$2.min.copy(box.min);
            obb2$2.max.copy(box.max);
            obb2$2.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb2$2.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                setTriangle(triangle22, 3 * i2, otherIndex, otherPos);
                triangle22.a.applyMatrix4(geometryToBvh);
                triangle22.b.applyMatrix4(geometryToBvh);
                triangle22.c.applyMatrix4(geometryToBvh);
                triangle22.needsUpdate = true;
                for (let i = offset, l3 = offset + count; i < l3; i++) {
                  setTriangle(triangle3, 3 * i, index, pos);
                  triangle3.needsUpdate = true;
                  const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle22, 3 * i2, otherIndex, otherPos);
            triangle22.a.applyMatrix4(geometryToBvh);
            triangle22.b.applyMatrix4(geometryToBvh);
            triangle22.c.applyMatrix4(geometryToBvh);
            triangle22.needsUpdate = true;
            for (let i = offset, l3 = offset + count; i < l3; i++) {
              setTriangle(triangle3, 3 * i, index, pos);
              triangle3.needsUpdate = true;
              const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle3);
  ExtendedTrianglePool.releasePrimitive(triangle22);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point) target2.point = tempTargetDest2.clone();
    else target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix$1);
    tempTargetDest1.applyMatrix4(tempMatrix$1);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}
function refit_indirect(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array2, uint16Array2, float32Array2;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l2 = roots.length; i < l2; i++) {
    buffer = roots[i];
    uint32Array2 = new Uint32Array(buffer);
    uint16Array2 = new Uint16Array(buffer);
    float32Array2 = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array2[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array2[node32Index + 6];
      const count = uint16Array2[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = offset, l2 = offset + count; i < l2; i++) {
        const t = 3 * bvh.resolveTriangleIndex(i);
        for (let j = 0; j < 3; j++) {
          let index = t + j;
          index = indexArr ? indexArr[index] : index;
          const x = posAttr.getX(index);
          const y = posAttr.getY(index);
          const z = posAttr.getZ(index);
          if (x < minx) minx = x;
          if (x > maxx) maxx = x;
          if (y < miny) miny = y;
          if (y > maxy) maxy = y;
          if (z < minz) minz = z;
          if (z > maxz) maxz = z;
        }
      }
      if (float32Array2[node32Index + 0] !== minx || float32Array2[node32Index + 1] !== miny || float32Array2[node32Index + 2] !== minz || float32Array2[node32Index + 3] !== maxx || float32Array2[node32Index + 4] !== maxy || float32Array2[node32Index + 5] !== maxz) {
        float32Array2[node32Index + 0] = minx;
        float32Array2[node32Index + 1] = miny;
        float32Array2[node32Index + 2] = minz;
        float32Array2[node32Index + 3] = maxx;
        float32Array2[node32Index + 4] = maxy;
        float32Array2[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array2[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array2[lefti];
          const maxLeftValue = float32Array2[lefti + 3];
          const minRightValue = float32Array2[righti];
          const maxRightValue = float32Array2[righti + 3];
          float32Array2[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array2[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}
function raycast_indirect(bvh, root, side, ray2, intersects2, near, far) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast(0, bvh, side, ray2, intersects2, near, far);
  BufferStack.clearBuffer();
}
function _raycast(nodeIndex32, bvh, side, ray2, intersects2, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    intersectTris_indirect(bvh, side, ray2, offset, count, intersects2, near, far);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array2, ray2, near, far)) {
      _raycast(leftIndex, bvh, side, ray2, intersects2, near, far);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array2);
    if (intersectRay(rightIndex, float32Array2, ray2, near, far)) {
      _raycast(rightIndex, bvh, side, ray2, intersects2, near, far);
    }
  }
}
const _xyzFields = ["x", "y", "z"];
function raycastFirst_indirect(bvh, root, side, ray2, near, far) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst(0, bvh, side, ray2, near, far);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst(nodeIndex32, bvh, side, ray2, near, far) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    return intersectClosestTri_indirect(bvh, side, ray2, offset, count, near, far);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array2);
    const xyzAxis = _xyzFields[splitAxis];
    const rayDir = ray2.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array2);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array2);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array2, ray2, near, far);
    const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray2, near, far) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array2[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array2[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array2, ray2, near, far);
    const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray2, near, far) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
const boundingBox = /* @__PURE__ */ new Box3();
const triangle = /* @__PURE__ */ new ExtendedTriangle();
const triangle2 = /* @__PURE__ */ new ExtendedTriangle();
const invertedMat = /* @__PURE__ */ new Matrix4();
const obb$2 = /* @__PURE__ */ new OrientedBox();
const obb2$1 = /* @__PURE__ */ new OrientedBox();
function intersectsGeometry_indirect(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array: float32Array2, uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb$2.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb$2;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array2);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array2);
    const count = COUNT(nodeIndex16, uint16Array2);
    invertedMat.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array2, obb2$1);
      obb2$1.matrix.copy(invertedMat);
      obb2$1.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2$1.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset, l2 = count + offset; i < l2; i++) {
            setTriangle(triangle2, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);
            triangle2.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset, l2 = count + offset; i < l2; i++) {
        const ti = bvh.resolveTriangleIndex(i);
        setTriangle(triangle, 3 * ti, thisIndex, thisPos);
        triangle.a.applyMatrix4(invertedMat);
        triangle.b.applyMatrix4(invertedMat);
        triangle.c.applyMatrix4(invertedMat);
        triangle.needsUpdate = true;
        for (let i2 = 0, l22 = index.count; i2 < l22; i2 += 3) {
          setTriangle(triangle2, i2, index, pos);
          triangle2.needsUpdate = true;
          if (triangle.intersectsTriangle(triangle2)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array2[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array2, boundingBox);
    const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection) return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array2, boundingBox);
    const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection) return true;
    return false;
  }
}
const tempMatrix = /* @__PURE__ */ new Matrix4();
const obb$1 = /* @__PURE__ */ new OrientedBox();
const obb2 = /* @__PURE__ */ new OrientedBox();
const temp1 = /* @__PURE__ */ new Vector3();
const temp2 = /* @__PURE__ */ new Vector3();
const temp3 = /* @__PURE__ */ new Vector3();
const temp4 = /* @__PURE__ */ new Vector3();
function closestPointToGeometry_indirect(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb$1.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb$1.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle3 = ExtendedTrianglePool.getPrimitive();
  const triangle22 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp1;
  let tempTargetDest1 = temp2;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3;
    tempTargetDest2 = temp4;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix.copy(geometryToBvh).invert();
  obb2.matrix.copy(tempMatrix);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb$1.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb2.min.copy(box.min);
            obb2.max.copy(box.max);
            obb2.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb2.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                const ti2 = otherBvh.resolveTriangleIndex(i2);
                setTriangle(triangle22, 3 * ti2, otherIndex, otherPos);
                triangle22.a.applyMatrix4(geometryToBvh);
                triangle22.b.applyMatrix4(geometryToBvh);
                triangle22.c.applyMatrix4(geometryToBvh);
                triangle22.needsUpdate = true;
                for (let i = offset, l3 = offset + count; i < l3; i++) {
                  const ti = bvh.resolveTriangleIndex(i);
                  setTriangle(triangle3, 3 * ti, index, pos);
                  triangle3.needsUpdate = true;
                  const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle22, 3 * i2, otherIndex, otherPos);
            triangle22.a.applyMatrix4(geometryToBvh);
            triangle22.b.applyMatrix4(geometryToBvh);
            triangle22.c.applyMatrix4(geometryToBvh);
            triangle22.needsUpdate = true;
            for (let i = offset, l3 = offset + count; i < l3; i++) {
              const ti = bvh.resolveTriangleIndex(i);
              setTriangle(triangle3, 3 * ti, index, pos);
              triangle3.needsUpdate = true;
              const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle3);
  ExtendedTrianglePool.releasePrimitive(triangle22);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point) target2.point = tempTargetDest2.clone();
    else target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix);
    tempTargetDest1.applyMatrix4(tempMatrix);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}
function isSharedArrayBufferSupported() {
  return typeof SharedArrayBuffer !== "undefined";
}
const _bufferStack1 = new BufferStack.constructor();
const _bufferStack2 = new BufferStack.constructor();
const _boxPool = new PrimitivePool(() => new Box3());
const _leftBox1 = new Box3();
const _rightBox1 = new Box3();
const _leftBox2 = new Box3();
const _rightBox2 = new Box3();
let _active = false;
function bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {
  if (_active) {
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  }
  _active = true;
  const roots = bvh._roots;
  const otherRoots = otherBvh._roots;
  let result;
  let offset1 = 0;
  let offset2 = 0;
  const invMat = new Matrix4().copy(matrixToLocal).invert();
  for (let i = 0, il = roots.length; i < il; i++) {
    _bufferStack1.setBuffer(roots[i]);
    offset2 = 0;
    const localBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, localBox);
    localBox.applyMatrix4(invMat);
    for (let j = 0, jl = otherRoots.length; j < jl; j++) {
      _bufferStack2.setBuffer(otherRoots[j]);
      result = _traverse(
        0,
        0,
        matrixToLocal,
        invMat,
        intersectsRanges,
        offset1,
        offset2,
        0,
        0,
        localBox
      );
      _bufferStack2.clearBuffer();
      offset2 += otherRoots[j].length;
      if (result) {
        break;
      }
    }
    _boxPool.releasePrimitive(localBox);
    _bufferStack1.clearBuffer();
    offset1 += roots[i].length;
    if (result) {
      break;
    }
  }
  _active = false;
  return result;
}
function _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset = 0, node2IndexByteOffset = 0, depth1 = 0, depth2 = 0, currBox = null, reversed = false) {
  let bufferStack1, bufferStack2;
  if (reversed) {
    bufferStack1 = _bufferStack2;
    bufferStack2 = _bufferStack1;
  } else {
    bufferStack1 = _bufferStack1;
    bufferStack2 = _bufferStack2;
  }
  const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;
  const node1Index16 = node1Index32 * 2;
  const node2Index16 = node2Index32 * 2;
  const isLeaf1 = IS_LEAF(node1Index16, uint16Array1);
  const isLeaf2 = IS_LEAF(node2Index16, uint16Array2);
  let result = false;
  if (isLeaf2 && isLeaf1) {
    if (reversed) {
      result = intersectsRangesFunc(
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        depth2,
        node2IndexByteOffset + node2Index32,
        depth1,
        node1IndexByteOffset + node1Index32
      );
    } else {
      result = intersectsRangesFunc(
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        depth1,
        node1IndexByteOffset + node1Index32,
        depth2,
        node2IndexByteOffset + node2Index32
      );
    }
  } else if (isLeaf2) {
    const newBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(node2Index32), float32Array2, newBox);
    newBox.applyMatrix4(matrix2to1);
    const cl1 = LEFT_NODE(node1Index32);
    const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
    arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
    arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
    const intersectCl1 = newBox.intersectsBox(_leftBox1);
    const intersectCr1 = newBox.intersectsBox(_rightBox1);
    result = intersectCl1 && _traverse(
      node2Index32,
      cl1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    ) || intersectCr1 && _traverse(
      node2Index32,
      cr1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    );
    _boxPool.releasePrimitive(newBox);
  } else {
    const cl2 = LEFT_NODE(node2Index32);
    const cr2 = RIGHT_NODE(node2Index32, uint32Array2);
    arrayToBox(BOUNDING_DATA_INDEX(cl2), float32Array2, _leftBox2);
    arrayToBox(BOUNDING_DATA_INDEX(cr2), float32Array2, _rightBox2);
    const leftIntersects = currBox.intersectsBox(_leftBox2);
    const rightIntersects = currBox.intersectsBox(_rightBox2);
    if (leftIntersects && rightIntersects) {
      result = _traverse(
        node1Index32,
        cl2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      ) || _traverse(
        node1Index32,
        cr2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      );
    } else if (leftIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cl2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_leftBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cl2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cl2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    } else if (rightIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cr2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_rightBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cr2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cr2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    }
  }
  return result;
}
const obb = /* @__PURE__ */ new OrientedBox();
const tempBox = /* @__PURE__ */ new Box3();
const DEFAULT_OPTIONS = {
  strategy: CENTER,
  maxDepth: 40,
  maxLeafTris: 10,
  useSharedArrayBuffer: false,
  setBoundingBox: true,
  onProgress: null,
  indirect: false,
  verbose: true,
  range: null
};
class MeshBVH {
  static serialize(bvh, options = {}) {
    options = {
      cloneBuffers: true,
      ...options
    };
    const geometry = bvh.geometry;
    const rootData = bvh._roots;
    const indirectBuffer = bvh._indirectBuffer;
    const indexAttribute = geometry.getIndex();
    let result;
    if (options.cloneBuffers) {
      result = {
        roots: rootData.map((root) => root.slice()),
        index: indexAttribute ? indexAttribute.array.slice() : null,
        indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null
      };
    } else {
      result = {
        roots: rootData,
        index: indexAttribute ? indexAttribute.array : null,
        indirectBuffer
      };
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    options = {
      setIndex: true,
      indirect: Boolean(data.indirectBuffer),
      ...options
    };
    const { index, roots, indirectBuffer } = data;
    const bvh = new MeshBVH(geometry, { ...options, [SKIP_GENERATION]: true });
    bvh._roots = roots;
    bvh._indirectBuffer = indirectBuffer || null;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      ...DEFAULT_OPTIONS,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [SKIP_GENERATION]: false
    }, options);
    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this.geometry = geometry;
    this._roots = null;
    this._indirectBuffer = null;
    if (!options[SKIP_GENERATION]) {
      buildPackedTree(this, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box3());
      }
    }
    this.resolveTriangleIndex = options.indirect ? (i) => this._indirectBuffer[i] : (i) => i;
  }
  refit(nodeIndices = null) {
    const refitFunc = this.indirect ? refit_indirect : refit;
    return refitFunc(this, nodeIndices);
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array2 = new Uint32Array(buffer);
    const uint16Array2 = new Uint16Array(buffer);
    _traverse2(0);
    function _traverse2(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array2[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array2[node32Index + 6];
        const count = uint16Array2[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = node32Index + BYTES_PER_NODE / 4;
        const right = uint32Array2[node32Index + 6];
        const splitAxis = uint32Array2[node32Index + 7];
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse2(left, depth + 1);
          _traverse2(right, depth + 1);
        }
      }
    }
  }
  /* Core Cast Functions */
  raycast(ray2, materialOrSide = FrontSide, near = 0, far = Infinity) {
    const roots = this._roots;
    const geometry = this.geometry;
    const intersects2 = [];
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFunc = this.indirect ? raycast_indirect : raycast;
    for (let i = 0, l2 = roots.length; i < l2; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const startCount = intersects2.length;
      raycastFunc(this, i, materialSide, ray2, intersects2, near, far);
      if (isArrayMaterial) {
        const materialIndex = groups[i].materialIndex;
        for (let j = startCount, jl = intersects2.length; j < jl; j++) {
          intersects2[j].face.materialIndex = materialIndex;
        }
      }
    }
    return intersects2;
  }
  raycastFirst(ray2, materialOrSide = FrontSide, near = 0, far = Infinity) {
    const roots = this._roots;
    const geometry = this.geometry;
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    let closestResult = null;
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;
    for (let i = 0, l2 = roots.length; i < l2; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const result = raycastFirstFunc(this, i, materialSide, ray2, near, far);
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
        if (isArrayMaterial) {
          result.face.materialIndex = groups[i].materialIndex;
        }
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    let result = false;
    const roots = this._roots;
    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;
    for (let i = 0, l2 = roots.length; i < l2; i++) {
      result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks) {
    const triangle3 = ExtendedTrianglePool.getPrimitive();
    const iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle3);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle3);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let byteOffset = 0;
    const roots = this._roots;
    for (let i = 0, l2 = roots.length; i < l2; i++) {
      const root = roots[i];
      result = shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
      if (result) {
        break;
      }
      byteOffset += root.byteLength;
    }
    ExtendedTrianglePool.releasePrimitive(triangle3);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const triangle1 = ExtendedTrianglePool.getPrimitive();
    const indexAttr1 = this.geometry.index;
    const positionAttr1 = this.geometry.attributes.position;
    const assignTriangle1 = this.indirect ? (i1) => {
      const ti = this.resolveTriangleIndex(i1);
      setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);
    } : (i1) => {
      setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);
    };
    const triangle22 = ExtendedTrianglePool.getPrimitive();
    const indexAttr2 = otherBvh.geometry.index;
    const positionAttr2 = otherBvh.geometry.attributes.position;
    const assignTriangle2 = otherBvh.indirect ? (i2) => {
      const ti2 = otherBvh.resolveTriangleIndex(i2);
      setTriangle(triangle22, ti2 * 3, indexAttr2, positionAttr2);
    } : (i2) => {
      setTriangle(triangle22, i2 * 3, indexAttr2, positionAttr2);
    };
    if (intersectsTriangles) {
      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {
        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {
          assignTriangle2(i2);
          triangle22.a.applyMatrix4(matrixToLocal);
          triangle22.b.applyMatrix4(matrixToLocal);
          triangle22.c.applyMatrix4(matrixToLocal);
          triangle22.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            assignTriangle1(i1);
            triangle1.needsUpdate = true;
            if (intersectsTriangles(triangle1, triangle22, i1, i2, depth1, index1, depth2, index2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    return bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);
  }
  /* Derived Cast Functions */
  intersectsBox(box, boxToMesh) {
    obb.set(box.min, box.max, boxToMesh);
    obb.needsUpdate = true;
    return this.shapecast(
      {
        intersectsBounds: (box2) => obb.intersectsBox(box2),
        intersectsTriangle: (tri) => obb.intersectsTriangle(tri)
      }
    );
  }
  intersectsSphere(sphere) {
    return this.shapecast(
      {
        intersectsBounds: (box) => sphere.intersectsBox(box),
        intersectsTriangle: (tri) => tri.intersectsSphere(sphere)
      }
    );
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;
    return closestPointToGeometryFunc(
      this,
      otherGeometry,
      geometryToBvh,
      target1,
      target2,
      minThreshold,
      maxThreshold
    );
  }
  closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
    return closestPointToPoint(
      this,
      point,
      target,
      minThreshold,
      maxThreshold
    );
  }
  getBoundingBox(target) {
    target.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox(0, new Float32Array(buffer), tempBox);
      target.union(tempBox);
    });
    return target;
  }
}
function convertRaycastIntersect(hit, object, raycaster) {
  if (hit === null) {
    return null;
  }
  hit.point.applyMatrix4(object.matrixWorld);
  hit.distance = hit.point.distanceTo(raycaster.ray.origin);
  hit.object = object;
  return hit;
}
const ray = /* @__PURE__ */ new Ray$1();
const direction = /* @__PURE__ */ new Vector3();
const tmpInverseMatrix = /* @__PURE__ */ new Matrix4();
const origMeshRaycastFunc = Mesh.prototype.raycast;
const origBatchedRaycastFunc = BatchedMesh.prototype.raycast;
const _worldScale = /* @__PURE__ */ new Vector3();
const _mesh = /* @__PURE__ */ new Mesh();
const _batchIntersects = [];
function acceleratedRaycast(raycaster, intersects2) {
  if (this.isBatchedMesh) {
    acceleratedBatchedMeshRaycast.call(this, raycaster, intersects2);
  } else {
    acceleratedMeshRaycast.call(this, raycaster, intersects2);
  }
}
function acceleratedBatchedMeshRaycast(raycaster, intersects2) {
  if (this.boundsTrees) {
    const boundsTrees = this.boundsTrees;
    const drawInfo = this._drawInfo;
    const drawRanges = this._drawRanges;
    const matrixWorld = this.matrixWorld;
    _mesh.material = this.material;
    _mesh.geometry = this.geometry;
    const oldBoundsTree = _mesh.geometry.boundsTree;
    const oldDrawRange = _mesh.geometry.drawRange;
    if (_mesh.geometry.boundingSphere === null) {
      _mesh.geometry.boundingSphere = new Sphere();
    }
    for (let i = 0, l2 = drawInfo.length; i < l2; i++) {
      if (!this.getVisibleAt(i)) {
        continue;
      }
      const geometryId = drawInfo[i].geometryIndex;
      _mesh.geometry.boundsTree = boundsTrees[geometryId];
      this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);
      if (!_mesh.geometry.boundsTree) {
        this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);
        this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);
        const drawRange = drawRanges[geometryId];
        _mesh.geometry.setDrawRange(drawRange.start, drawRange.count);
      }
      _mesh.raycast(raycaster, _batchIntersects);
      for (let j = 0, l3 = _batchIntersects.length; j < l3; j++) {
        const intersect2 = _batchIntersects[j];
        intersect2.object = this;
        intersect2.batchId = i;
        intersects2.push(intersect2);
      }
      _batchIntersects.length = 0;
    }
    _mesh.geometry.boundsTree = oldBoundsTree;
    _mesh.geometry.drawRange = oldDrawRange;
    _mesh.material = null;
    _mesh.geometry = null;
  } else {
    origBatchedRaycastFunc.call(this, raycaster, intersects2);
  }
}
function acceleratedMeshRaycast(raycaster, intersects2) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0) return;
    tmpInverseMatrix.copy(this.matrixWorld).invert();
    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
    _worldScale.setFromMatrixScale(this.matrixWorld);
    direction.copy(ray.direction).multiply(_worldScale);
    const scaleFactor = direction.length();
    const near = raycaster.near / scaleFactor;
    const far = raycaster.far / scaleFactor;
    const bvh = this.geometry.boundsTree;
    if (raycaster.firstHitOnly === true) {
      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material, near, far), this, raycaster);
      if (hit) {
        intersects2.push(hit);
      }
    } else {
      const hits = bvh.raycast(ray, this.material, near, far);
      for (let i = 0, l2 = hits.length; i < l2; i++) {
        const hit = convertRaycastIntersect(hits[i], this, raycaster);
        if (hit) {
          intersects2.push(hit);
        }
      }
    }
  } else {
    origMeshRaycastFunc.call(this, raycaster, intersects2);
  }
}
function computeBoundsTree(options = {}) {
  this.boundsTree = new MeshBVH(this, options);
  return this.boundsTree;
}
function disposeBoundsTree() {
  this.boundsTree = null;
}
var eMaterialReplace = /* @__PURE__ */ ((eMaterialReplace2) => {
  eMaterialReplace2["crown"] = "crown-origin";
  eMaterialReplace2["generateGum"] = "generate-gum";
  eMaterialReplace2["jawBone"] = "jaw-bone";
  eMaterialReplace2["fusionTooth"] = "fusion-tooth";
  return eMaterialReplace2;
})(eMaterialReplace || {});
const colorJawBone = new Color().setRGB(243 / 255, 219 / 255, 201 / 255, LinearSRGBColorSpace);
const colorFusionToothRoot = new Color().setRGB(232 / 255, 217 / 255, 213 / 255);
const colorFusionToothCrown = new Color().setRGB(180 / 255, 180 / 255, 180 / 255);
function attributeVFlag(geometry) {
  let colors = geometry.attributes.color.array;
  let vflag = void 0;
  if (geometry.attributes.VFlag) vflag = geometry.attributes.VFlag.array;
  for (let i = 0, il = colors.length; i < il; i += 3) {
    let idx = Math.floor(i / 3);
    if (vflag && vflag[idx] == 1) {
      setXYZ(colors, i, colorFusionToothRoot.r, colorFusionToothRoot.g, colorFusionToothRoot.b);
    } else {
      setXYZ(colors, i, colorFusionToothCrown.r, colorFusionToothCrown.g, colorFusionToothCrown.b);
    }
  }
}
function toMeshWithMaterialReplace(geometry, eType, userData = {}) {
  let material;
  if (eType == "fusion-tooth") {
    material = new MeshPhongMaterial({
      vertexColors: true,
      flatShading: true,
      side: DoubleSide
    });
    geometry.deleteAttribute("color");
    const colors = new Float32Array(geometry.attributes.position.array.length);
    geometry.setAttribute("color", new BufferAttribute(colors, 3));
    attributeVFlag(geometry);
    geometry.computeBoundingBox();
  } else if (eType == "jaw-bone") {
    material = new MeshStandardMaterial({
      vertexColors: true,
      flatShading: true,
      side: DoubleSide,
      opacity: 0.8,
      transparent: true
    });
    geometry.deleteAttribute("color");
    const colors = new Float32Array(geometry.attributes.position.array.length);
    for (let i = 0, il = colors.length; i < il; i += 3) setXYZ(colors, i, colorJawBone.r, colorJawBone.g, colorJawBone.b);
    geometry.setAttribute("color", new BufferAttribute(colors, 3));
    geometry.computeBoundingBox();
  } else if (eType == "crown-origin") {
    material = materialToothCrown(geometry, userData.isUpper);
  } else if (eType == "generate-gum") {
    material = materialGumShader();
  } else {
    throw new Error(`un-support material type ${eType}`);
  }
  if (material) return new Mesh(geometry, material);
}
new Color().setRGB(0.5, 0.5, 0.5);
const ColorMapKeywords = {
  "rainbow": [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],
  "cooltowarm": [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],
  "blackbody": [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],
  "grayscale": [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]
};
class Lut {
  constructor(colormap, count = 32) {
    this.isLut = true;
    this.lut = [];
    this.map = [];
    this.n = 0;
    this.minV = 0;
    this.maxV = 1;
    this.setColorMap(colormap, count);
  }
  set(value) {
    if (value.isLut === true) {
      this.copy(value);
    }
    return this;
  }
  setMin(min) {
    this.minV = min;
    return this;
  }
  setMax(max) {
    this.maxV = max;
    return this;
  }
  setColorMap(colormap, count = 32) {
    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;
    this.n = count;
    const step = 1 / this.n;
    const minColor = new Color();
    const maxColor = new Color();
    this.lut.length = 0;
    this.lut.push(new Color(this.map[0][1]));
    for (let i = 1; i < count; i++) {
      const alpha = i * step;
      for (let j = 0; j < this.map.length - 1; j++) {
        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {
          const min = this.map[j][0];
          const max = this.map[j + 1][0];
          minColor.setHex(this.map[j][1], LinearSRGBColorSpace);
          maxColor.setHex(this.map[j + 1][1], LinearSRGBColorSpace);
          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));
          this.lut.push(color);
        }
      }
    }
    this.lut.push(new Color(this.map[this.map.length - 1][1]));
    return this;
  }
  copy(lut) {
    this.lut = lut.lut;
    this.map = lut.map;
    this.n = lut.n;
    this.minV = lut.minV;
    this.maxV = lut.maxV;
    return this;
  }
  getColor(alpha) {
    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);
    alpha = (alpha - this.minV) / (this.maxV - this.minV);
    const colorPosition = Math.round(alpha * this.n);
    return this.lut[colorPosition];
  }
  getValue(alpha) {
    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);
    const index = (alpha - this.minV) / (this.maxV - this.minV);
    return index;
  }
  addColorMap(name, arrayOfColors) {
    ColorMapKeywords[name] = arrayOfColors;
    return this;
  }
  createCanvas(width = 1) {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = this.n;
    this.updateCanvas(canvas);
    return canvas;
  }
  updateCanvas(canvas) {
    const ctx = canvas.getContext("2d", { alpha: false });
    const imageData = ctx.getImageData(0, 0, canvas.width, this.n);
    const data = imageData.data;
    let k = 0;
    const step = 1 / this.n;
    const minColor = new Color();
    const maxColor = new Color();
    const finalColor = new Color();
    for (let i = 1; i >= 0; i -= step) {
      for (let j = this.map.length - 1; j >= 0; j--) {
        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {
          const min = this.map[j - 1][0];
          const max = this.map[j][0];
          minColor.setHex(this.map[j - 1][1], LinearSRGBColorSpace);
          maxColor.setHex(this.map[j][1], LinearSRGBColorSpace);
          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));
          data[k * 4] = Math.round(finalColor.r * 255);
          data[k * 4 + 1] = Math.round(finalColor.g * 255);
          data[k * 4 + 2] = Math.round(finalColor.b * 255);
          data[k * 4 + 3] = 255;
          k += canvas.width;
        }
      }
    }
    if (canvas.width > 1) {
      const LayerOffset = canvas.width * 4;
      for (let h = 1; h < canvas.width; h++) {
        for (let v = 0; v < this.n; v++) {
          let begin = v * LayerOffset;
          let index = begin + h * 4;
          data[index + 0] = data[begin + 0];
          data[index + 1] = data[begin + 1];
          data[index + 2] = data[begin + 2];
          data[index + 3] = data[begin + 3];
        }
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }
}
function computeMikkTSpaceTangents(geometry, MikkTSpace, negateSign = true) {
  if (!MikkTSpace || !MikkTSpace.isReady) {
    throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
  }
  if (!geometry.hasAttribute("position") || !geometry.hasAttribute("normal") || !geometry.hasAttribute("uv")) {
    throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');
  }
  function getAttributeArray(attribute) {
    if (attribute.normalized || attribute.isInterleavedBufferAttribute) {
      const dstArray = new Float32Array(attribute.count * attribute.itemSize);
      for (let i = 0, j = 0; i < attribute.count; i++) {
        dstArray[j++] = attribute.getX(i);
        dstArray[j++] = attribute.getY(i);
        if (attribute.itemSize > 2) {
          dstArray[j++] = attribute.getZ(i);
        }
      }
      return dstArray;
    }
    if (attribute.array instanceof Float32Array) {
      return attribute.array;
    }
    return new Float32Array(attribute.array);
  }
  const _geometry2 = geometry.index ? geometry.toNonIndexed() : geometry;
  const tangents = MikkTSpace.generateTangents(
    getAttributeArray(_geometry2.attributes.position),
    getAttributeArray(_geometry2.attributes.normal),
    getAttributeArray(_geometry2.attributes.uv)
  );
  if (negateSign) {
    for (let i = 3; i < tangents.length; i += 4) {
      tangents[i] *= -1;
    }
  }
  _geometry2.setAttribute("tangent", new BufferAttribute(tangents, 4));
  if (geometry !== _geometry2) {
    geometry.copy(_geometry2);
  }
  return geometry;
}
function mergeGeometries(geometries, useGroups = false) {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries.length; ++i) {
    const geometry = geometries[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0) attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0) morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    if (useGroups) {
      let count;
      if (isIndexed) {
        count = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i);
      offset += count;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries.length; ++i) {
      const index = geometries[i].index;
      for (let j = 0; j < index.count; ++j) {
        mergedIndex.push(index.getX(j) + indexOffset);
      }
      indexOffset += geometries[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0) break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let gpuType = -1;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (TypedArray === void 0) TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0) itemSize = attribute.itemSize;
    if (itemSize !== attribute.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0) normalized = attribute.normalized;
    if (normalized !== attribute.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    if (gpuType === -1) gpuType = attribute.gpuType;
    if (gpuType !== attribute.gpuType) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute.count * itemSize;
  }
  const array = new TypedArray(arrayLength);
  const result = new BufferAttribute(array, itemSize, normalized);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.isInterleavedBufferAttribute) {
      const tupleOffset = offset / itemSize;
      for (let j = 0, l2 = attribute.count; j < l2; j++) {
        for (let c = 0; c < itemSize; c++) {
          const value = attribute.getComponent(j, c);
          result.setComponent(j + tupleOffset, c, value);
        }
      }
    } else {
      array.set(attribute.array, offset);
    }
    offset += attribute.count * itemSize;
  }
  if (gpuType !== void 0) {
    result.gpuType = gpuType;
  }
  return result;
}
function deepCloneAttribute(attribute) {
  if (attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute) {
    return deinterleaveAttribute(attribute);
  }
  if (attribute.isInstancedBufferAttribute) {
    return new InstancedBufferAttribute().copy(attribute);
  }
  return new BufferAttribute().copy(attribute);
}
function interleaveAttributes(attributes) {
  let TypedArray;
  let arrayLength = 0;
  let stride = 0;
  for (let i = 0, l2 = attributes.length; i < l2; ++i) {
    const attribute = attributes[i];
    if (TypedArray === void 0) TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("AttributeBuffers of different types cannot be interleaved");
      return null;
    }
    arrayLength += attribute.array.length;
    stride += attribute.itemSize;
  }
  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);
  let offset = 0;
  const res = [];
  const getters = ["getX", "getY", "getZ", "getW"];
  const setters = ["setX", "setY", "setZ", "setW"];
  for (let j = 0, l2 = attributes.length; j < l2; j++) {
    const attribute = attributes[j];
    const itemSize = attribute.itemSize;
    const count = attribute.count;
    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);
    res.push(iba);
    offset += itemSize;
    for (let c = 0; c < count; c++) {
      for (let k = 0; k < itemSize; k++) {
        iba[setters[k]](c, attribute[getters[k]](c));
      }
    }
  }
  return res;
}
function deinterleaveAttribute(attribute) {
  const cons = attribute.data.array.constructor;
  const count = attribute.count;
  const itemSize = attribute.itemSize;
  const normalized = attribute.normalized;
  const array = new cons(count * itemSize);
  let newAttribute;
  if (attribute.isInstancedInterleavedBufferAttribute) {
    newAttribute = new InstancedBufferAttribute(array, itemSize, normalized, attribute.meshPerAttribute);
  } else {
    newAttribute = new BufferAttribute(array, itemSize, normalized);
  }
  for (let i = 0; i < count; i++) {
    newAttribute.setX(i, attribute.getX(i));
    if (itemSize >= 2) {
      newAttribute.setY(i, attribute.getY(i));
    }
    if (itemSize >= 3) {
      newAttribute.setZ(i, attribute.getZ(i));
    }
    if (itemSize >= 4) {
      newAttribute.setW(i, attribute.getW(i));
    }
  }
  return newAttribute;
}
function deinterleaveGeometry(geometry) {
  const attributes = geometry.attributes;
  const morphTargets = geometry.morphTargets;
  const attrMap = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const attr = attributes[key];
    if (attr.isInterleavedBufferAttribute) {
      if (!attrMap.has(attr)) {
        attrMap.set(attr, deinterleaveAttribute(attr));
      }
      attributes[key] = attrMap.get(attr);
    }
  }
  for (const key in morphTargets) {
    const attr = morphTargets[key];
    if (attr.isInterleavedBufferAttribute) {
      if (!attrMap.has(attr)) {
        attrMap.set(attr, deinterleaveAttribute(attr));
      }
      morphTargets[key] = attrMap.get(attr);
    }
  }
}
function estimateBytesUsed(geometry) {
  let mem = 0;
  for (const name in geometry.attributes) {
    const attr = geometry.getAttribute(name);
    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
  }
  const indices = geometry.getIndex();
  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
  return mem;
}
function mergeVertices(geometry, tolerance = 1e-4) {
  tolerance = Math.max(tolerance, Number.EPSILON);
  const hashToIndex = {};
  const indices = geometry.getIndex();
  const positions = geometry.getAttribute("position");
  const vertexCount = indices ? indices.count : positions.count;
  let nextIndex = 0;
  const attributeNames = Object.keys(geometry.attributes);
  const tmpAttributes = {};
  const tmpMorphAttributes = {};
  const newIndices = [];
  const getters = ["getX", "getY", "getZ", "getW"];
  const setters = ["setX", "setY", "setZ", "setW"];
  for (let i = 0, l2 = attributeNames.length; i < l2; i++) {
    const name = attributeNames[i];
    const attr = geometry.attributes[name];
    tmpAttributes[name] = new attr.constructor(
      new attr.array.constructor(attr.count * attr.itemSize),
      attr.itemSize,
      attr.normalized
    );
    const morphAttributes = geometry.morphAttributes[name];
    if (morphAttributes) {
      if (!tmpMorphAttributes[name]) tmpMorphAttributes[name] = [];
      morphAttributes.forEach((morphAttr, i2) => {
        const array = new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize);
        tmpMorphAttributes[name][i2] = new morphAttr.constructor(array, morphAttr.itemSize, morphAttr.normalized);
      });
    }
  }
  const halfTolerance = tolerance * 0.5;
  const exponent = Math.log10(1 / tolerance);
  const hashMultiplier = Math.pow(10, exponent);
  const hashAdditive = halfTolerance * hashMultiplier;
  for (let i = 0; i < vertexCount; i++) {
    const index = indices ? indices.getX(i) : i;
    let hash = "";
    for (let j = 0, l2 = attributeNames.length; j < l2; j++) {
      const name = attributeNames[j];
      const attribute = geometry.getAttribute(name);
      const itemSize = attribute.itemSize;
      for (let k = 0; k < itemSize; k++) {
        hash += `${~~(attribute[getters[k]](index) * hashMultiplier + hashAdditive)},`;
      }
    }
    if (hash in hashToIndex) {
      newIndices.push(hashToIndex[hash]);
    } else {
      for (let j = 0, l2 = attributeNames.length; j < l2; j++) {
        const name = attributeNames[j];
        const attribute = geometry.getAttribute(name);
        const morphAttributes = geometry.morphAttributes[name];
        const itemSize = attribute.itemSize;
        const newArray = tmpAttributes[name];
        const newMorphArrays = tmpMorphAttributes[name];
        for (let k = 0; k < itemSize; k++) {
          const getterFunc = getters[k];
          const setterFunc = setters[k];
          newArray[setterFunc](nextIndex, attribute[getterFunc](index));
          if (morphAttributes) {
            for (let m = 0, ml = morphAttributes.length; m < ml; m++) {
              newMorphArrays[m][setterFunc](nextIndex, morphAttributes[m][getterFunc](index));
            }
          }
        }
      }
      hashToIndex[hash] = nextIndex;
      newIndices.push(nextIndex);
      nextIndex++;
    }
  }
  const result = geometry.clone();
  for (const name in geometry.attributes) {
    const tmpAttribute = tmpAttributes[name];
    result.setAttribute(name, new tmpAttribute.constructor(
      tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize),
      tmpAttribute.itemSize,
      tmpAttribute.normalized
    ));
    if (!(name in tmpMorphAttributes)) continue;
    for (let j = 0; j < tmpMorphAttributes[name].length; j++) {
      const tmpMorphAttribute = tmpMorphAttributes[name][j];
      result.morphAttributes[name][j] = new tmpMorphAttribute.constructor(
        tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize),
        tmpMorphAttribute.itemSize,
        tmpMorphAttribute.normalized
      );
    }
  }
  result.setIndex(newIndices);
  return result;
}
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}
function computeMorphedAttributes(object) {
  const _vA2 = new Vector3();
  const _vB2 = new Vector3();
  const _vC2 = new Vector3();
  const _tempA2 = new Vector3();
  const _tempB = new Vector3();
  const _tempC = new Vector3();
  const _morphA2 = new Vector3();
  const _morphB = new Vector3();
  const _morphC = new Vector3();
  function _calculateMorphedAttributeData(object2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {
    _vA2.fromBufferAttribute(attribute, a2);
    _vB2.fromBufferAttribute(attribute, b2);
    _vC2.fromBufferAttribute(attribute, c2);
    const morphInfluences = object2.morphTargetInfluences;
    if (morphAttribute && morphInfluences) {
      _morphA2.set(0, 0, 0);
      _morphB.set(0, 0, 0);
      _morphC.set(0, 0, 0);
      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {
        const influence = morphInfluences[i2];
        const morph = morphAttribute[i2];
        if (influence === 0) continue;
        _tempA2.fromBufferAttribute(morph, a2);
        _tempB.fromBufferAttribute(morph, b2);
        _tempC.fromBufferAttribute(morph, c2);
        if (morphTargetsRelative2) {
          _morphA2.addScaledVector(_tempA2, influence);
          _morphB.addScaledVector(_tempB, influence);
          _morphC.addScaledVector(_tempC, influence);
        } else {
          _morphA2.addScaledVector(_tempA2.sub(_vA2), influence);
          _morphB.addScaledVector(_tempB.sub(_vB2), influence);
          _morphC.addScaledVector(_tempC.sub(_vC2), influence);
        }
      }
      _vA2.add(_morphA2);
      _vB2.add(_morphB);
      _vC2.add(_morphC);
    }
    if (object2.isSkinnedMesh) {
      object2.applyBoneTransform(a2, _vA2);
      object2.applyBoneTransform(b2, _vB2);
      object2.applyBoneTransform(c2, _vC2);
    }
    modifiedAttributeArray[a2 * 3 + 0] = _vA2.x;
    modifiedAttributeArray[a2 * 3 + 1] = _vA2.y;
    modifiedAttributeArray[a2 * 3 + 2] = _vA2.z;
    modifiedAttributeArray[b2 * 3 + 0] = _vB2.x;
    modifiedAttributeArray[b2 * 3 + 1] = _vB2.y;
    modifiedAttributeArray[b2 * 3 + 2] = _vB2.z;
    modifiedAttributeArray[c2 * 3 + 0] = _vC2.x;
    modifiedAttributeArray[c2 * 3 + 1] = _vC2.y;
    modifiedAttributeArray[c2 * 3 + 2] = _vC2.z;
  }
  const geometry = object.geometry;
  const material = object.material;
  let a, b, c;
  const index = geometry.index;
  const positionAttribute = geometry.attributes.position;
  const morphPosition = geometry.morphAttributes.position;
  const morphTargetsRelative = geometry.morphTargetsRelative;
  const normalAttribute = geometry.attributes.normal;
  const morphNormal = geometry.morphAttributes.position;
  const groups = geometry.groups;
  const drawRange = geometry.drawRange;
  let i, j, il, jl;
  let group;
  let start, end;
  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);
  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
  if (index !== null) {
    if (Array.isArray(material)) {
      for (i = 0, il = groups.length; i < il; i++) {
        group = groups[i];
        start = Math.max(group.start, drawRange.start);
        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
        for (j = start, jl = end; j < jl; j += 3) {
          a = index.getX(j);
          b = index.getX(j + 1);
          c = index.getX(j + 2);
          _calculateMorphedAttributeData(
            object,
            positionAttribute,
            morphPosition,
            morphTargetsRelative,
            a,
            b,
            c,
            modifiedPosition
          );
          _calculateMorphedAttributeData(
            object,
            normalAttribute,
            morphNormal,
            morphTargetsRelative,
            a,
            b,
            c,
            modifiedNormal
          );
        }
      }
    } else {
      start = Math.max(0, drawRange.start);
      end = Math.min(index.count, drawRange.start + drawRange.count);
      for (i = start, il = end; i < il; i += 3) {
        a = index.getX(i);
        b = index.getX(i + 1);
        c = index.getX(i + 2);
        _calculateMorphedAttributeData(
          object,
          positionAttribute,
          morphPosition,
          morphTargetsRelative,
          a,
          b,
          c,
          modifiedPosition
        );
        _calculateMorphedAttributeData(
          object,
          normalAttribute,
          morphNormal,
          morphTargetsRelative,
          a,
          b,
          c,
          modifiedNormal
        );
      }
    }
  } else {
    if (Array.isArray(material)) {
      for (i = 0, il = groups.length; i < il; i++) {
        group = groups[i];
        start = Math.max(group.start, drawRange.start);
        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
        for (j = start, jl = end; j < jl; j += 3) {
          a = j;
          b = j + 1;
          c = j + 2;
          _calculateMorphedAttributeData(
            object,
            positionAttribute,
            morphPosition,
            morphTargetsRelative,
            a,
            b,
            c,
            modifiedPosition
          );
          _calculateMorphedAttributeData(
            object,
            normalAttribute,
            morphNormal,
            morphTargetsRelative,
            a,
            b,
            c,
            modifiedNormal
          );
        }
      }
    } else {
      start = Math.max(0, drawRange.start);
      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (i = start, il = end; i < il; i += 3) {
        a = i;
        b = i + 1;
        c = i + 2;
        _calculateMorphedAttributeData(
          object,
          positionAttribute,
          morphPosition,
          morphTargetsRelative,
          a,
          b,
          c,
          modifiedPosition
        );
        _calculateMorphedAttributeData(
          object,
          normalAttribute,
          morphNormal,
          morphTargetsRelative,
          a,
          b,
          c,
          modifiedNormal
        );
      }
    }
  }
  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);
  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);
  return {
    positionAttribute,
    normalAttribute,
    morphedPositionAttribute,
    morphedNormalAttribute
  };
}
function mergeGroups(geometry) {
  if (geometry.groups.length === 0) {
    console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.");
    return geometry;
  }
  let groups = geometry.groups;
  groups = groups.sort((a, b) => {
    if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;
    return a.start - b.start;
  });
  if (geometry.getIndex() === null) {
    const positionAttribute = geometry.getAttribute("position");
    const indices = [];
    for (let i = 0; i < positionAttribute.count; i += 3) {
      indices.push(i, i + 1, i + 2);
    }
    geometry.setIndex(indices);
  }
  const index = geometry.getIndex();
  const newIndices = [];
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    const groupStart = group.start;
    const groupLength = groupStart + group.count;
    for (let j = groupStart; j < groupLength; j++) {
      newIndices.push(index.getX(j));
    }
  }
  geometry.dispose();
  geometry.setIndex(newIndices);
  let start = 0;
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    group.start = start;
    start += group.count;
  }
  let currentGroup = groups[0];
  geometry.groups = [currentGroup];
  for (let i = 1; i < groups.length; i++) {
    const group = groups[i];
    if (currentGroup.materialIndex === group.materialIndex) {
      currentGroup.count += group.count;
    } else {
      currentGroup = group;
      geometry.groups.push(currentGroup);
    }
  }
  return geometry;
}
function toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {
  const creaseDot = Math.cos(creaseAngle);
  const hashMultiplier = (1 + 1e-10) * 100;
  const verts = [new Vector3(), new Vector3(), new Vector3()];
  const tempVec1 = new Vector3();
  const tempVec2 = new Vector3();
  const tempNorm = new Vector3();
  const tempNorm2 = new Vector3();
  function hashVertex(v) {
    const x = ~~(v.x * hashMultiplier);
    const y = ~~(v.y * hashMultiplier);
    const z = ~~(v.z * hashMultiplier);
    return `${x},${y},${z}`;
  }
  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;
  const posAttr = resultGeometry.attributes.position;
  const vertexMap = {};
  for (let i = 0, l2 = posAttr.count / 3; i < l2; i++) {
    const i3 = 3 * i;
    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
    tempVec1.subVectors(c, b);
    tempVec2.subVectors(a, b);
    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();
    for (let n = 0; n < 3; n++) {
      const vert = verts[n];
      const hash = hashVertex(vert);
      if (!(hash in vertexMap)) {
        vertexMap[hash] = [];
      }
      vertexMap[hash].push(normal);
    }
  }
  const normalArray = new Float32Array(posAttr.count * 3);
  const normAttr = new BufferAttribute(normalArray, 3, false);
  for (let i = 0, l2 = posAttr.count / 3; i < l2; i++) {
    const i3 = 3 * i;
    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
    tempVec1.subVectors(c, b);
    tempVec2.subVectors(a, b);
    tempNorm.crossVectors(tempVec1, tempVec2).normalize();
    for (let n = 0; n < 3; n++) {
      const vert = verts[n];
      const hash = hashVertex(vert);
      const otherNormals = vertexMap[hash];
      tempNorm2.set(0, 0, 0);
      for (let k = 0, lk = otherNormals.length; k < lk; k++) {
        const otherNorm = otherNormals[k];
        if (tempNorm.dot(otherNorm) > creaseDot) {
          tempNorm2.add(otherNorm);
        }
      }
      tempNorm2.normalize();
      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);
    }
  }
  resultGeometry.setAttribute("normal", normAttr);
  return resultGeometry;
}
const BufferGeometryUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  computeMikkTSpaceTangents,
  computeMorphedAttributes,
  deepCloneAttribute,
  deinterleaveAttribute,
  deinterleaveGeometry,
  estimateBytesUsed,
  interleaveAttributes,
  mergeAttributes,
  mergeGeometries,
  mergeGroups,
  mergeVertices,
  toCreasedNormals,
  toTrianglesDrawMode
}, Symbol.toStringTag, { value: "Module" }));
BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
Mesh.prototype.raycast = acceleratedRaycast;
const alias3 = {
  ObjectLoader,
  Color,
  Camera,
  Scene,
  AxesHelper,
  Mesh,
  Vector2,
  Vector3,
  Euler,
  Quaternion,
  Matrix4,
  Line3,
  Box3,
  Plane: Plane$1,
  PerspectiveCamera,
  OrthographicCamera,
  BufferAttribute,
  BufferGeometry,
  Float32BufferAttribute,
  BoxGeometry,
  TubeGeometry,
  SphereGeometry,
  CylinderGeometry,
  ConeGeometry,
  PlaneGeometry,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  DoubleSide,
  ObjectSpaceNormalMap,
  CatmullRomCurve3,
  Raycaster,
  Ray: Ray$1,
  CanvasTexture,
  Sprite,
  SpriteMaterial,
  // constannts
  LinearSRGBColorSpace,
  SRGBColorSpace,
  // examples
  // geometry
  BufferGeometryUtils,
  // math
  Lut
};
const aliasBvh = {
  computeBoundsTree,
  MeshBVH
};
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop() {
}
function errorContext(cb) {
  {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x) {
  return x;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer.push(value);
  };
  var doInnerSub = function(value) {
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer.shift();
            if (innerSubScheduler) ;
            else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
  };
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}
var PEType = /* @__PURE__ */ ((PEType2) => {
  PEType2["down"] = "DOWN";
  PEType2["move"] = "MOVE";
  PEType2["up"] = "UP";
  PEType2["enter"] = "ENTER";
  PEType2["leave"] = "LEAVE";
  return PEType2;
})(PEType || {});
function listenDomEvent(canavs, callback, options = {}) {
  const pointerDown$ = fromEvent(canavs, "pointerdown");
  const pointerMove$ = fromEvent(canavs, "pointermove");
  const pointerUp$ = fromEvent(canavs, "pointerup");
  const testIn = options.testIn || false;
  let pointerEnter$;
  let pointerLeave$;
  if (testIn) {
    pointerEnter$ = fromEvent(canavs, "pointerenter");
    pointerLeave$ = fromEvent(canavs, "pointerleave");
  }
  let beIn = false;
  function normalizeCoords(evt) {
    const rc = canavs.getBoundingClientRect();
    let x = evt.clientX;
    let y = evt.clientY;
    let button = -1;
    if ([0, 1, 2].includes(evt.button)) button = evt.button;
    x = x - rc.left;
    y = y - rc.top;
    return { x, y, button, beIn, buttons: evt.buttons };
  }
  const downSubscribe = pointerDown$.pipe(
    map((e) => {
      callback("DOWN", normalizeCoords(e));
    })
  ).subscribe();
  const moveSubscribe = pointerMove$.pipe(
    map((e) => {
      callback("MOVE", normalizeCoords(e));
    })
  ).subscribe();
  const upSubscribe = pointerUp$.pipe(
    map((e) => {
      callback("UP", normalizeCoords(e));
    })
  ).subscribe();
  let enterSubscribe;
  let leaveSubscribe;
  if (testIn) {
    enterSubscribe = pointerEnter$.pipe(
      map((e) => {
        beIn = true;
        callback("ENTER", normalizeCoords(e));
      })
    ).subscribe();
    leaveSubscribe = pointerLeave$.pipe(
      map((e) => {
        beIn = false;
        callback("LEAVE", normalizeCoords(e));
      })
    ).subscribe();
  }
  const clearEvent = () => {
    downSubscribe.unsubscribe();
    moveSubscribe.unsubscribe();
    upSubscribe.unsubscribe();
    if (testIn) {
      enterSubscribe.unsubscribe();
      leaveSubscribe.unsubscribe();
    }
  };
  return {
    clearEvent
  };
}
function toIndexGeometry(geo, tolerance = 1e-6) {
  if (!geo.index) {
    bufferGeometryMergeVertices(geo);
  }
  return geo;
}
function colorUpdateByIndex(geo, cutIndex, color) {
  const arrColor = geo.attributes.color;
  const index = geo.index.array;
  cutIndex.forEach((idx, i) => {
    const realIdx = idx * 3;
    const idx1 = index[realIdx + 0];
    arrColor.setXYZ(idx1, color[0], color[1], color[2]);
    const idx2 = index[realIdx + 1];
    arrColor.setXYZ(idx2, color[0], color[1], color[2]);
    const idx3 = index[realIdx + 2];
    arrColor.setXYZ(idx3, color[0], color[1], color[2]);
  });
  arrColor.needsUpdate = true;
}
function bufferGeometryMergeVertices(geometry) {
  var verticesMap = {};
  var precisionPoints = 8;
  var precision = Math.pow(10, precisionPoints);
  var vertices = geometry.attributes.position.array;
  if (geometry.index) {
    var idx = geometry.index.array;
    var oldVertices = new Float32Array(idx.length * 3);
    for (var i = 0, il = idx.length; i < il; i++) {
      oldVertices[i * 3] = vertices[idx[i] * 3];
      oldVertices[i * 3 + 1] = vertices[idx[i] * 3 + 1];
      oldVertices[i * 3 + 2] = vertices[idx[i] * 3 + 2];
    }
    geometry.index = null;
    vertices = oldVertices;
  }
  geometry.setIndex(new BufferAttribute(new Uint32Array(Math.floor(vertices.length / 3)), 1));
  var indices = geometry.index.array;
  var vCount = 0, faceIndicesToRemove = [];
  for (let i2 = 0, il2 = vertices.length; i2 < il2; i2 += 3) {
    var iIndex = Math.floor(i2 / 3);
    var key = Math.round(vertices[i2] * precision) + "_" + Math.round(vertices[i2 + 1] * precision) + "_" + Math.round(vertices[i2 + 2] * precision);
    if (verticesMap[key] === void 0) {
      var vIndex = vCount * 3;
      verticesMap[key] = indices[iIndex] = vCount++;
      vertices[vIndex] = vertices[i2];
      vertices[vIndex + 1] = vertices[i2 + 1];
      vertices[vIndex + 2] = vertices[i2 + 2];
    } else {
      indices[iIndex] = verticesMap[key];
    }
    var prevIndex = iIndex - 2;
    if (prevIndex >= 0 && prevIndex % 3 == 0) {
      for (var n = 0; n < 3; n++) {
        if (indices[prevIndex + n] == indices[prevIndex + (n + 1) % 3]) {
          faceIndicesToRemove.push(prevIndex);
          break;
        }
      }
    }
  }
  var newVertices = new Float32Array(vCount * 3);
  for (let i2 = 0, il2 = newVertices.length; i2 < il2; i2++) {
    newVertices[i2] = vertices[i2];
  }
  geometry.setAttribute("position", new BufferAttribute(newVertices, 3));
  if (faceIndicesToRemove.length > 0) {
    var newIndices = new Uint32Array(indices.length - faceIndicesToRemove.length * 3);
    var nIndex = 0, iRemove = 0;
    for (let i2 = 0, il2 = indices.length; i2 < il2; i2 += 3) {
      if (i2 == faceIndicesToRemove[iRemove]) {
        iRemove++;
      } else {
        newIndices[nIndex] = indices[i2];
        newIndices[nIndex + 1] = indices[i2 + 1];
        newIndices[nIndex + 2] = indices[i2 + 2];
        nIndex += 3;
      }
    }
    geometry.setIndex(new BufferAttribute(newIndices, 1));
  }
  geometry.computeVertexNormals();
  return vCount;
}
function updateMaterialColor(material, strColor) {
  const color = new Color(strColor);
  if (material.color) material.color.copy(color);
}
function updateMaterialOpacity(material, opacity) {
  material.opacity = opacity;
  material.transparent = !(opacity == 1);
  material.needsUpdate = true;
}
const rShaderCrown = {
  vertexShader: `
    // 
    attribute float mqDistance;
    // attribute vec3 fixedMapcolor;

    varying vec3 vNormal;
    varying vec3 vViewPosition;
    varying float vDistance;
    varying vec3 vFixedMapcolor;

    void main() {
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vNormal = normalMatrix * normal;
        vViewPosition = -mvPosition.xyz;
        vDistance = mqDistance;
        // vFixedMapcolor = vec3(fixedMapcolor);

        gl_Position = projectionMatrix * mvPosition;
    }
`,
  fragmentShader: `
    uniform vec3 color;
    uniform vec3 emissive;
    uniform float roughness;
    uniform float metalness;
    uniform float opacity;
    uniform bool useMapColor;
    uniform vec3 ambientLightColor;
    uniform sampler2D textureMap;
    uniform sampler2D textureMapFixed;

    varying vec3 vNormal;
    varying vec3 vViewPosition;
    varying float vDistance;
    varying vec3 vFixedMapcolor;
    void main() {
        vec3 normal = normalize(vNormal);
        vec3 viewDir = normalize(vViewPosition);

        // 
        vec3 lightDirection = normalize(vec3(0.0, 10.0, 10.9));
        float diffuse = max(dot(normal, lightDirection), 0.0);

        // 
        vec3 halfwayDir = normalize(lightDirection + viewDir);
        float specular = pow(max(dot(normal, halfwayDir), 0.0), 64.0);

        // 
        vec3 ambient = ambientLightColor * color * 0.6;
        vec4 targetColor;

        if(useMapColor) {  
            if (vDistance < 1.0 && vDistance > 0.0) {
                targetColor = texture2D(textureMap, vec2(0, vDistance));
                // targetColor = vec4(0.0, 0.0, 1.0, 1.0);
            } else {
                targetColor = vec4(color.r, color.g, color.b, 1.0);
                // targetColor = vec4(1.0, 1.0, 0.0, 1.0);
            }
        } else {
            targetColor = vec4(color.r, color.g, color.b, 1.0);
        }

        // if(vFixedMapcolor.x != 0.0 || vFixedMapcolor.y != 0.0 || vFixedMapcolor.z != 0.0) {
        //     vec2 uv = vec2(0.5, 0.5);
        //     // 
        //     targetColor = texture2D(textureMapFixed, uv);
        // }

        // 
        // vec3 finalColor = vec3(targetColor) * diffuse + specular + emissive + ambient;
        vec3 finalColor = vec3(targetColor) * diffuse + ambient + emissive;
        gl_FragColor = vec4(finalColor, opacity);
    }
`
};
var eRModelType = /* @__PURE__ */ ((eRModelType2) => {
  eRModelType2["Jaw"] = "Jaw";
  eRModelType2["Crown"] = "Crown";
  eRModelType2["Inlay"] = "Inlay";
  eRModelType2["Onlay"] = "Onlays";
  eRModelType2["Veneer"] = "Veneer";
  eRModelType2["JawFullUpper"] = "uJawFull";
  eRModelType2["JawFullLower"] = "lJawFull";
  return eRModelType2;
})(eRModelType || {});
function rBufferToModel(info, options = {}) {
  let geo;
  if (info.buffer instanceof ArrayBuffer) {
    const loader = new CommonLoader(info.filename);
    geo = loader.parse(info.buffer);
  } else {
    geo = info.buffer;
  }
  if (options.type == eRModelType.Crown) {
    rAppendGeometryDistance(geo);
  } else {
    rAppendGeometryColor(geo, options.color);
  }
  const mesh = new Mesh(geo, getMaterialByOptions(options));
  mesh.name = info.ftype;
  mesh.userData = {
    ftype: info.ftype,
    filename: info.filename,
    isUpper: info.isUpper
  };
  return mesh;
}
function getMaterialByOptions(options = {}) {
  let mat;
  if (options.type == eRModelType.Crown) {
    mat = new ShaderMaterial({
      uniforms: {
        color: { value: new Color(options.color) },
        emissive: { value: new Color(0) },
        ambientLightColor: { value: new Color(2434341) },
        roughness: { value: 0.3 },
        metalness: { value: 0.6 },
        opacity: { value: 1 },
        useMapColor: { value: false },
        textureMap: { value: null }
      },
      vertexShader: rShaderCrown.vertexShader,
      fragmentShader: rShaderCrown.fragmentShader,
      side: DoubleSide,
      // vertexColors: true,
      transparent: false,
      shadowSide: DoubleSide
    });
  } else {
    mat = new MeshPhongMaterial({
      side: DoubleSide,
      transparent: false,
      depthTest: true,
      depthWrite: true,
      vertexColors: true,
      //
      // emissive: options.emissiveColor || 0x000000,
      reflectivity: 1,
      shininess: 30,
      ...options
    });
  }
  return mat;
}
function rAppendGeometryColor(geo, color) {
  const position = geo.attributes.position;
  const total = position.array.length;
  const colors = new Float32Array(total);
  for (let i = 0; i < total; i += 3) {
    setXYZ(colors, i, color.r, color.g, color.b);
  }
  geo.setAttribute("color", new BufferAttribute(colors, 3));
  if (!geo.attributes.normal) geo.computeVertexNormals();
  geo.normalizeNormals();
  geo.attributes.color.needsUpdate = true;
}
function rAppendGeometryDistance(geo) {
  const position = geo.attributes.position;
  const total = position.count / 1;
  const distances = new Float32Array(total).fill(2);
  geo.setAttribute("mqDistance", new BufferAttribute(distances, 1));
  if (!geo.attributes.normal) geo.computeVertexNormals();
  geo.normalizeNormals();
  geo.attributes.mqDistance.needsUpdate = true;
}
export {
  FilePathLoader,
  MarkerLines,
  MqMultiViewEditor,
  PEType,
  PathLoader,
  StrMesh,
  alias3,
  aliasBvh,
  bindDracoEncoder,
  colorUpdateByIndex,
  create4ToothNumberMesh,
  createGumMesh,
  debug_ToothVisualPoint,
  eEntryCode,
  eMaterialReplace,
  eMaterialType,
  geometry2Mesh,
  listenDomEvent,
  mat2Mesh,
  mat4Tooth,
  mesh2drc,
  mesh2ply,
  mesh2stl,
  rBufferToModel,
  toIndexGeometry,
  toMeshWithMaterialReplace,
  updateMaterialColor,
  updateMaterialOpacity
};
